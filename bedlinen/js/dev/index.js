import { d as dataMediaQueries, s as slideToggle, a as slideUp, b as slideDown, c as bodyLockToggle, e as bodyLockStatus, g as gotoBlock, u as uniqArray } from "./common.min.js";
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) return;
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) processPreload(link);
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") continue;
      for (const node2 of mutation.addedNodes) if (node2.tagName === "LINK" && node2.rel === "modulepreload") processPreload(node2);
    }
  }).observe(document, {
    childList: true,
    subtree: true
  });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep) return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
function spollers() {
  const spollersArray = document.querySelectorAll("[data-fls-spollers]");
  if (spollersArray.length > 0) {
    let initSpollers = function(spollersArray2, matchMedia = false) {
      spollersArray2.forEach((spollersBlock) => {
        spollersBlock = matchMedia ? spollersBlock.item : spollersBlock;
        if (matchMedia.matches || !matchMedia) {
          spollersBlock.classList.add("--spoller-init");
          initSpollerBody(spollersBlock);
        } else {
          spollersBlock.classList.remove("--spoller-init");
          initSpollerBody(spollersBlock, false);
        }
      });
    }, initSpollerBody = function(spollersBlock, hideSpollerBody = true) {
      let spollerItems = spollersBlock.querySelectorAll("details");
      if (spollerItems.length) {
        spollerItems.forEach((spollerItem) => {
          let spollerTitle = spollerItem.querySelector("summary");
          if (hideSpollerBody) {
            spollerTitle.removeAttribute("tabindex");
            if (!spollerItem.hasAttribute("data-fls-spollers-open")) {
              spollerItem.open = false;
              spollerTitle.nextElementSibling.hidden = true;
            } else {
              spollerTitle.classList.add("--spoller-active");
              spollerItem.open = true;
            }
          } else {
            spollerTitle.setAttribute("tabindex", "-1");
            spollerTitle.classList.remove("--spoller-active");
            spollerItem.open = true;
            spollerTitle.nextElementSibling.hidden = false;
          }
        });
      }
    }, setSpollerAction = function(e) {
      const el = e.target;
      if (el.closest("summary") && el.closest("[data-fls-spollers]")) {
        e.preventDefault();
        if (el.closest("[data-fls-spollers]").classList.contains("--spoller-init")) {
          const spollerTitle = el.closest("summary");
          const spollerBlock = spollerTitle.closest("details");
          const spollersBlock = spollerTitle.closest("[data-fls-spollers]");
          const oneSpoller = spollersBlock.hasAttribute("data-fls-spollers-one");
          const scrollSpoller = spollerBlock.hasAttribute("data-fls-spollers-scroll");
          const spollerSpeed = spollersBlock.dataset.flsSpollersSpeed ? parseInt(spollersBlock.dataset.flsSpollersSpeed) : 500;
          if (!spollersBlock.querySelectorAll(".--slide").length) {
            if (oneSpoller && !spollerBlock.open) {
              hideSpollersBody(spollersBlock);
            }
            !spollerBlock.open ? spollerBlock.open = true : setTimeout(() => {
              spollerBlock.open = false;
            }, spollerSpeed);
            spollerTitle.classList.toggle("--spoller-active");
            slideToggle(spollerTitle.nextElementSibling, spollerSpeed);
            if (scrollSpoller && spollerTitle.classList.contains("--spoller-active")) {
              const scrollSpollerValue = spollerBlock.dataset.flsSpollersScroll;
              const scrollSpollerOffset = +scrollSpollerValue ? +scrollSpollerValue : 0;
              const scrollSpollerNoHeader = spollerBlock.hasAttribute("data-fls-spollers-scroll-noheader") ? document.querySelector(".header").offsetHeight : 0;
              window.scrollTo(
                {
                  top: spollerBlock.offsetTop - (scrollSpollerOffset + scrollSpollerNoHeader),
                  behavior: "smooth"
                }
              );
            }
          }
        }
      }
      if (!el.closest("[data-fls-spollers]")) {
        const spollersClose = document.querySelectorAll("[data-fls-spollers-close]");
        if (spollersClose.length) {
          spollersClose.forEach((spollerClose) => {
            const spollersBlock = spollerClose.closest("[data-fls-spollers]");
            const spollerCloseBlock = spollerClose.parentNode;
            if (spollersBlock.classList.contains("--spoller-init")) {
              const spollerSpeed = spollersBlock.dataset.flsSpollersSpeed ? parseInt(spollersBlock.dataset.flsSpollersSpeed) : 500;
              spollerClose.classList.remove("--spoller-active");
              slideUp(spollerClose.nextElementSibling, spollerSpeed);
              setTimeout(() => {
                spollerCloseBlock.open = false;
              }, spollerSpeed);
            }
          });
        }
      }
    }, hideSpollersBody = function(spollersBlock) {
      const spollerActiveBlock = spollersBlock.querySelector("details[open]");
      if (spollerActiveBlock && !spollersBlock.querySelectorAll(".--slide").length) {
        const spollerActiveTitle = spollerActiveBlock.querySelector("summary");
        const spollerSpeed = spollersBlock.dataset.flsSpollersSpeed ? parseInt(spollersBlock.dataset.flsSpollersSpeed) : 500;
        spollerActiveTitle.classList.remove("--spoller-active");
        slideUp(spollerActiveTitle.nextElementSibling, spollerSpeed);
        setTimeout(() => {
          spollerActiveBlock.open = false;
        }, spollerSpeed);
      }
    };
    document.addEventListener("click", setSpollerAction);
    const spollersRegular = Array.from(spollersArray).filter(function(item, index, self) {
      return !item.dataset.flsSpollers.split(",")[0];
    });
    if (spollersRegular.length) {
      initSpollers(spollersRegular);
    }
    let mdQueriesArray = dataMediaQueries(spollersArray, "flsSpollers");
    if (mdQueriesArray && mdQueriesArray.length) {
      mdQueriesArray.forEach((mdQueriesItem) => {
        mdQueriesItem.matchMedia.addEventListener("change", function() {
          initSpollers(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);
        });
        initSpollers(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);
      });
    }
  }
}
window.addEventListener("load", spollers);
function isObject$2(obj) {
  return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
}
function extend$1(target = {}, src = {}) {
  const noExtend = ["__proto__", "constructor", "prototype"];
  Object.keys(src).filter((key) => noExtend.indexOf(key) < 0).forEach((key) => {
    if (typeof target[key] === "undefined") target[key] = src[key];
    else if (isObject$2(src[key]) && isObject$2(target[key]) && Object.keys(src[key]).length > 0) {
      extend$1(target[key], src[key]);
    }
  });
}
const ssrDocument = {
  body: {},
  addEventListener() {
  },
  removeEventListener() {
  },
  activeElement: {
    blur() {
    },
    nodeName: ""
  },
  querySelector() {
    return null;
  },
  querySelectorAll() {
    return [];
  },
  getElementById() {
    return null;
  },
  createEvent() {
    return {
      initEvent() {
      }
    };
  },
  createElement() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute() {
      },
      getElementsByTagName() {
        return [];
      }
    };
  },
  createElementNS() {
    return {};
  },
  importNode() {
    return null;
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  }
};
function getDocument() {
  const doc = typeof document !== "undefined" ? document : {};
  extend$1(doc, ssrDocument);
  return doc;
}
const ssrWindow = {
  document: ssrDocument,
  navigator: {
    userAgent: ""
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  },
  history: {
    replaceState() {
    },
    pushState() {
    },
    go() {
    },
    back() {
    }
  },
  CustomEvent: function CustomEvent2() {
    return this;
  },
  addEventListener() {
  },
  removeEventListener() {
  },
  getComputedStyle() {
    return {
      getPropertyValue() {
        return "";
      }
    };
  },
  Image() {
  },
  Date() {
  },
  screen: {},
  setTimeout() {
  },
  clearTimeout() {
  },
  matchMedia() {
    return {};
  },
  requestAnimationFrame(callback) {
    if (typeof setTimeout === "undefined") {
      callback();
      return null;
    }
    return setTimeout(callback, 0);
  },
  cancelAnimationFrame(id) {
    if (typeof setTimeout === "undefined") {
      return;
    }
    clearTimeout(id);
  }
};
function getWindow() {
  const win = typeof window !== "undefined" ? window : {};
  extend$1(win, ssrWindow);
  return win;
}
function classesToTokens(classes2 = "") {
  return classes2.trim().split(" ").filter((c) => !!c.trim());
}
function deleteProps(obj) {
  const object = obj;
  Object.keys(object).forEach((key) => {
    try {
      object[key] = null;
    } catch (e) {
    }
    try {
      delete object[key];
    } catch (e) {
    }
  });
}
function nextTick(callback, delay = 0) {
  return setTimeout(callback, delay);
}
function now() {
  return Date.now();
}
function getComputedStyle$1(el) {
  const window2 = getWindow();
  let style;
  if (window2.getComputedStyle) {
    style = window2.getComputedStyle(el, null);
  }
  if (!style && el.currentStyle) {
    style = el.currentStyle;
  }
  if (!style) {
    style = el.style;
  }
  return style;
}
function getTranslate(el, axis = "x") {
  const window2 = getWindow();
  let matrix;
  let curTransform;
  let transformMatrix;
  const curStyle = getComputedStyle$1(el);
  if (window2.WebKitCSSMatrix) {
    curTransform = curStyle.transform || curStyle.webkitTransform;
    if (curTransform.split(",").length > 6) {
      curTransform = curTransform.split(", ").map((a) => a.replace(",", ".")).join(", ");
    }
    transformMatrix = new window2.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
  } else {
    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
    matrix = transformMatrix.toString().split(",");
  }
  if (axis === "x") {
    if (window2.WebKitCSSMatrix) curTransform = transformMatrix.m41;
    else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
    else curTransform = parseFloat(matrix[4]);
  }
  if (axis === "y") {
    if (window2.WebKitCSSMatrix) curTransform = transformMatrix.m42;
    else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
    else curTransform = parseFloat(matrix[5]);
  }
  return curTransform || 0;
}
function isObject$1(o) {
  return typeof o === "object" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === "Object";
}
function isNode(node2) {
  if (typeof window !== "undefined" && typeof window.HTMLElement !== "undefined") {
    return node2 instanceof HTMLElement;
  }
  return node2 && (node2.nodeType === 1 || node2.nodeType === 11);
}
function extend(...args) {
  const to = Object(args[0]);
  const noExtend = ["__proto__", "constructor", "prototype"];
  for (let i = 1; i < args.length; i += 1) {
    const nextSource = args[i];
    if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {
      const keysArray = Object.keys(Object(nextSource)).filter((key) => noExtend.indexOf(key) < 0);
      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        const nextKey = keysArray[nextIndex];
        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== void 0 && desc.enumerable) {
          if (isObject$1(to[nextKey]) && isObject$1(nextSource[nextKey])) {
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend(to[nextKey], nextSource[nextKey]);
            }
          } else if (!isObject$1(to[nextKey]) && isObject$1(nextSource[nextKey])) {
            to[nextKey] = {};
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend(to[nextKey], nextSource[nextKey]);
            }
          } else {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }
  return to;
}
function setCSSProperty(el, varName, varValue) {
  el.style.setProperty(varName, varValue);
}
function animateCSSModeScroll({
  swiper,
  targetPosition,
  side
}) {
  const window2 = getWindow();
  const startPosition = -swiper.translate;
  let startTime = null;
  let time2;
  const duration = swiper.params.speed;
  swiper.wrapperEl.style.scrollSnapType = "none";
  window2.cancelAnimationFrame(swiper.cssModeFrameID);
  const dir = targetPosition > startPosition ? "next" : "prev";
  const isOutOfBound = (current, target) => {
    return dir === "next" && current >= target || dir === "prev" && current <= target;
  };
  const animate = () => {
    time2 = (/* @__PURE__ */ new Date()).getTime();
    if (startTime === null) {
      startTime = time2;
    }
    const progress = Math.max(Math.min((time2 - startTime) / duration, 1), 0);
    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
    let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
    if (isOutOfBound(currentPosition, targetPosition)) {
      currentPosition = targetPosition;
    }
    swiper.wrapperEl.scrollTo({
      [side]: currentPosition
    });
    if (isOutOfBound(currentPosition, targetPosition)) {
      swiper.wrapperEl.style.overflow = "hidden";
      swiper.wrapperEl.style.scrollSnapType = "";
      setTimeout(() => {
        swiper.wrapperEl.style.overflow = "";
        swiper.wrapperEl.scrollTo({
          [side]: currentPosition
        });
      });
      window2.cancelAnimationFrame(swiper.cssModeFrameID);
      return;
    }
    swiper.cssModeFrameID = window2.requestAnimationFrame(animate);
  };
  animate();
}
function elementChildren(element, selector2 = "") {
  const window2 = getWindow();
  const children = [...element.children];
  if (window2.HTMLSlotElement && element instanceof HTMLSlotElement) {
    children.push(...element.assignedElements());
  }
  if (!selector2) {
    return children;
  }
  return children.filter((el) => el.matches(selector2));
}
function elementIsChildOfSlot(el, slot) {
  const elementsQueue = [slot];
  while (elementsQueue.length > 0) {
    const elementToCheck = elementsQueue.shift();
    if (el === elementToCheck) {
      return true;
    }
    elementsQueue.push(...elementToCheck.children, ...elementToCheck.shadowRoot ? elementToCheck.shadowRoot.children : [], ...elementToCheck.assignedElements ? elementToCheck.assignedElements() : []);
  }
}
function elementIsChildOf(el, parent) {
  const window2 = getWindow();
  let isChild = parent.contains(el);
  if (!isChild && window2.HTMLSlotElement && parent instanceof HTMLSlotElement) {
    const children = [...parent.assignedElements()];
    isChild = children.includes(el);
    if (!isChild) {
      isChild = elementIsChildOfSlot(el, parent);
    }
  }
  return isChild;
}
function showWarning(text) {
  try {
    console.warn(text);
    return;
  } catch (err) {
  }
}
function createElement(tag, classes2 = []) {
  const el = document.createElement(tag);
  el.classList.add(...Array.isArray(classes2) ? classes2 : classesToTokens(classes2));
  return el;
}
function elementPrevAll(el, selector2) {
  const prevEls = [];
  while (el.previousElementSibling) {
    const prev = el.previousElementSibling;
    if (selector2) {
      if (prev.matches(selector2)) prevEls.push(prev);
    } else prevEls.push(prev);
    el = prev;
  }
  return prevEls;
}
function elementNextAll(el, selector2) {
  const nextEls = [];
  while (el.nextElementSibling) {
    const next = el.nextElementSibling;
    if (selector2) {
      if (next.matches(selector2)) nextEls.push(next);
    } else nextEls.push(next);
    el = next;
  }
  return nextEls;
}
function elementStyle(el, prop) {
  const window2 = getWindow();
  return window2.getComputedStyle(el, null).getPropertyValue(prop);
}
function elementIndex(el) {
  let child = el;
  let i;
  if (child) {
    i = 0;
    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1) i += 1;
    }
    return i;
  }
  return void 0;
}
function elementParents(el, selector2) {
  const parents = [];
  let parent = el.parentElement;
  while (parent) {
    if (selector2) {
      if (parent.matches(selector2)) parents.push(parent);
    } else {
      parents.push(parent);
    }
    parent = parent.parentElement;
  }
  return parents;
}
function elementOuterSize(el, size, includeMargins) {
  const window2 = getWindow();
  {
    return el[size === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(window2.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-right" : "margin-top")) + parseFloat(window2.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-left" : "margin-bottom"));
  }
}
function makeElementsArray(el) {
  return (Array.isArray(el) ? el : [el]).filter((e) => !!e);
}
function setInnerHTML(el, html = "") {
  if (typeof trustedTypes !== "undefined") {
    el.innerHTML = trustedTypes.createPolicy("html", {
      createHTML: (s) => s
    }).createHTML(html);
  } else {
    el.innerHTML = html;
  }
}
let support;
function calcSupport() {
  const window2 = getWindow();
  const document2 = getDocument();
  return {
    smoothScroll: document2.documentElement && document2.documentElement.style && "scrollBehavior" in document2.documentElement.style,
    touch: !!("ontouchstart" in window2 || window2.DocumentTouch && document2 instanceof window2.DocumentTouch)
  };
}
function getSupport() {
  if (!support) {
    support = calcSupport();
  }
  return support;
}
let deviceCached;
function calcDevice({
  userAgent
} = {}) {
  const support2 = getSupport();
  const window2 = getWindow();
  const platform = window2.navigator.platform;
  const ua = userAgent || window2.navigator.userAgent;
  const device = {
    ios: false,
    android: false
  };
  const screenWidth = window2.screen.width;
  const screenHeight = window2.screen.height;
  const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
  let ipad = ua.match(/(iPad)(?!\1).*OS\s([\d_]+)/);
  const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
  const windows = platform === "Win32";
  let macos = platform === "MacIntel";
  const iPadScreens = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
  if (!ipad && macos && support2.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
    ipad = ua.match(/(Version)\/([\d.]+)/);
    if (!ipad) ipad = [0, 1, "13_0_0"];
    macos = false;
  }
  if (android && !windows) {
    device.os = "android";
    device.android = true;
  }
  if (ipad || iphone || ipod) {
    device.os = "ios";
    device.ios = true;
  }
  return device;
}
function getDevice(overrides = {}) {
  if (!deviceCached) {
    deviceCached = calcDevice(overrides);
  }
  return deviceCached;
}
let browser;
function calcBrowser() {
  const window2 = getWindow();
  const device = getDevice();
  let needPerspectiveFix = false;
  function isSafari() {
    const ua = window2.navigator.userAgent.toLowerCase();
    return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
  }
  if (isSafari()) {
    const ua = String(window2.navigator.userAgent);
    if (ua.includes("Version/")) {
      const [major, minor] = ua.split("Version/")[1].split(" ")[0].split(".").map((num) => Number(num));
      needPerspectiveFix = major < 16 || major === 16 && minor < 2;
    }
  }
  const isWebView = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window2.navigator.userAgent);
  const isSafariBrowser = isSafari();
  const need3dFix = isSafariBrowser || isWebView && device.ios;
  return {
    isSafari: needPerspectiveFix || isSafariBrowser,
    needPerspectiveFix,
    need3dFix,
    isWebView
  };
}
function getBrowser() {
  if (!browser) {
    browser = calcBrowser();
  }
  return browser;
}
function Resize({
  swiper,
  on,
  emit
}) {
  const window2 = getWindow();
  let observer = null;
  let animationFrame = null;
  const resizeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    emit("beforeResize");
    emit("resize");
  };
  const createObserver = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    observer = new ResizeObserver((entries) => {
      animationFrame = window2.requestAnimationFrame(() => {
        const {
          width,
          height
        } = swiper;
        let newWidth = width;
        let newHeight = height;
        entries.forEach(({
          contentBoxSize,
          contentRect,
          target
        }) => {
          if (target && target !== swiper.el) return;
          newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
          newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
        });
        if (newWidth !== width || newHeight !== height) {
          resizeHandler();
        }
      });
    });
    observer.observe(swiper.el);
  };
  const removeObserver = () => {
    if (animationFrame) {
      window2.cancelAnimationFrame(animationFrame);
    }
    if (observer && observer.unobserve && swiper.el) {
      observer.unobserve(swiper.el);
      observer = null;
    }
  };
  const orientationChangeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    emit("orientationchange");
  };
  on("init", () => {
    if (swiper.params.resizeObserver && typeof window2.ResizeObserver !== "undefined") {
      createObserver();
      return;
    }
    window2.addEventListener("resize", resizeHandler);
    window2.addEventListener("orientationchange", orientationChangeHandler);
  });
  on("destroy", () => {
    removeObserver();
    window2.removeEventListener("resize", resizeHandler);
    window2.removeEventListener("orientationchange", orientationChangeHandler);
  });
}
function Observer({
  swiper,
  extendParams,
  on,
  emit
}) {
  const observers = [];
  const window2 = getWindow();
  const attach = (target, options = {}) => {
    const ObserverFunc = window2.MutationObserver || window2.WebkitMutationObserver;
    const observer = new ObserverFunc((mutations) => {
      if (swiper.__preventObserver__) return;
      if (mutations.length === 1) {
        emit("observerUpdate", mutations[0]);
        return;
      }
      const observerUpdate = function observerUpdate2() {
        emit("observerUpdate", mutations[0]);
      };
      if (window2.requestAnimationFrame) {
        window2.requestAnimationFrame(observerUpdate);
      } else {
        window2.setTimeout(observerUpdate, 0);
      }
    });
    observer.observe(target, {
      attributes: typeof options.attributes === "undefined" ? true : options.attributes,
      childList: swiper.isElement || (typeof options.childList === "undefined" ? true : options).childList,
      characterData: typeof options.characterData === "undefined" ? true : options.characterData
    });
    observers.push(observer);
  };
  const init = () => {
    if (!swiper.params.observer) return;
    if (swiper.params.observeParents) {
      const containerParents = elementParents(swiper.hostEl);
      for (let i = 0; i < containerParents.length; i += 1) {
        attach(containerParents[i]);
      }
    }
    attach(swiper.hostEl, {
      childList: swiper.params.observeSlideChildren
    });
    attach(swiper.wrapperEl, {
      attributes: false
    });
  };
  const destroy = () => {
    observers.forEach((observer) => {
      observer.disconnect();
    });
    observers.splice(0, observers.length);
  };
  extendParams({
    observer: false,
    observeParents: false,
    observeSlideChildren: false
  });
  on("init", init);
  on("destroy", destroy);
}
var eventsEmitter = {
  on(events2, handler, priority) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (typeof handler !== "function") return self;
    const method = priority ? "unshift" : "push";
    events2.split(" ").forEach((event) => {
      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
      self.eventsListeners[event][method](handler);
    });
    return self;
  },
  once(events2, handler, priority) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (typeof handler !== "function") return self;
    function onceHandler(...args) {
      self.off(events2, onceHandler);
      if (onceHandler.__emitterProxy) {
        delete onceHandler.__emitterProxy;
      }
      handler.apply(self, args);
    }
    onceHandler.__emitterProxy = handler;
    return self.on(events2, onceHandler, priority);
  },
  onAny(handler, priority) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (typeof handler !== "function") return self;
    const method = priority ? "unshift" : "push";
    if (self.eventsAnyListeners.indexOf(handler) < 0) {
      self.eventsAnyListeners[method](handler);
    }
    return self;
  },
  offAny(handler) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (!self.eventsAnyListeners) return self;
    const index = self.eventsAnyListeners.indexOf(handler);
    if (index >= 0) {
      self.eventsAnyListeners.splice(index, 1);
    }
    return self;
  },
  off(events2, handler) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (!self.eventsListeners) return self;
    events2.split(" ").forEach((event) => {
      if (typeof handler === "undefined") {
        self.eventsListeners[event] = [];
      } else if (self.eventsListeners[event]) {
        self.eventsListeners[event].forEach((eventHandler, index) => {
          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
            self.eventsListeners[event].splice(index, 1);
          }
        });
      }
    });
    return self;
  },
  emit(...args) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (!self.eventsListeners) return self;
    let events2;
    let data;
    let context;
    if (typeof args[0] === "string" || Array.isArray(args[0])) {
      events2 = args[0];
      data = args.slice(1, args.length);
      context = self;
    } else {
      events2 = args[0].events;
      data = args[0].data;
      context = args[0].context || self;
    }
    data.unshift(context);
    const eventsArray = Array.isArray(events2) ? events2 : events2.split(" ");
    eventsArray.forEach((event) => {
      if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
        self.eventsAnyListeners.forEach((eventHandler) => {
          eventHandler.apply(context, [event, ...data]);
        });
      }
      if (self.eventsListeners && self.eventsListeners[event]) {
        self.eventsListeners[event].forEach((eventHandler) => {
          eventHandler.apply(context, data);
        });
      }
    });
    return self;
  }
};
function updateSize() {
  const swiper = this;
  let width;
  let height;
  const el = swiper.el;
  if (typeof swiper.params.width !== "undefined" && swiper.params.width !== null) {
    width = swiper.params.width;
  } else {
    width = el.clientWidth;
  }
  if (typeof swiper.params.height !== "undefined" && swiper.params.height !== null) {
    height = swiper.params.height;
  } else {
    height = el.clientHeight;
  }
  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
    return;
  }
  width = width - parseInt(elementStyle(el, "padding-left") || 0, 10) - parseInt(elementStyle(el, "padding-right") || 0, 10);
  height = height - parseInt(elementStyle(el, "padding-top") || 0, 10) - parseInt(elementStyle(el, "padding-bottom") || 0, 10);
  if (Number.isNaN(width)) width = 0;
  if (Number.isNaN(height)) height = 0;
  Object.assign(swiper, {
    width,
    height,
    size: swiper.isHorizontal() ? width : height
  });
}
function updateSlides() {
  const swiper = this;
  function getDirectionPropertyValue(node2, label) {
    return parseFloat(node2.getPropertyValue(swiper.getDirectionLabel(label)) || 0);
  }
  const params = swiper.params;
  const {
    wrapperEl,
    slidesEl,
    rtlTranslate: rtl,
    wrongRTL
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
  const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);
  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
  let snapGrid = [];
  const slidesGrid = [];
  const slidesSizesGrid = [];
  let offsetBefore = params.slidesOffsetBefore;
  if (typeof offsetBefore === "function") {
    offsetBefore = params.slidesOffsetBefore.call(swiper);
  }
  let offsetAfter = params.slidesOffsetAfter;
  if (typeof offsetAfter === "function") {
    offsetAfter = params.slidesOffsetAfter.call(swiper);
  }
  const previousSnapGridLength = swiper.snapGrid.length;
  const previousSlidesGridLength = swiper.slidesGrid.length;
  const swiperSize = swiper.size - offsetBefore - offsetAfter;
  let spaceBetween = params.spaceBetween;
  let slidePosition = -offsetBefore;
  let prevSlideSize = 0;
  let index = 0;
  if (typeof swiperSize === "undefined") {
    return;
  }
  if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize;
  } else if (typeof spaceBetween === "string") {
    spaceBetween = parseFloat(spaceBetween);
  }
  swiper.virtualSize = -spaceBetween - offsetBefore - offsetAfter;
  slides.forEach((slideEl) => {
    if (rtl) {
      slideEl.style.marginLeft = "";
    } else {
      slideEl.style.marginRight = "";
    }
    slideEl.style.marginBottom = "";
    slideEl.style.marginTop = "";
  });
  if (params.centeredSlides && params.cssMode) {
    setCSSProperty(wrapperEl, "--swiper-centered-offset-before", "");
    setCSSProperty(wrapperEl, "--swiper-centered-offset-after", "");
  }
  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
  if (gridEnabled) {
    swiper.grid.initSlides(slides);
  } else if (swiper.grid) {
    swiper.grid.unsetSlides();
  }
  let slideSize;
  const shouldResetSlideSize = params.slidesPerView === "auto" && params.breakpoints && Object.keys(params.breakpoints).filter((key) => {
    return typeof params.breakpoints[key].slidesPerView !== "undefined";
  }).length > 0;
  for (let i = 0; i < slidesLength; i += 1) {
    slideSize = 0;
    const slide2 = slides[i];
    if (slide2) {
      if (gridEnabled) {
        swiper.grid.updateSlide(i, slide2, slides);
      }
      if (elementStyle(slide2, "display") === "none") continue;
    }
    if (isVirtual && params.slidesPerView === "auto") {
      if (params.virtual.slidesPerViewAutoSlideSize) {
        slideSize = params.virtual.slidesPerViewAutoSlideSize;
      }
      if (slideSize && slide2) {
        if (params.roundLengths) slideSize = Math.floor(slideSize);
        slide2.style[swiper.getDirectionLabel("width")] = `${slideSize}px`;
      }
    } else if (params.slidesPerView === "auto") {
      if (shouldResetSlideSize) {
        slide2.style[swiper.getDirectionLabel("width")] = ``;
      }
      const slideStyles = getComputedStyle(slide2);
      const currentTransform = slide2.style.transform;
      const currentWebKitTransform = slide2.style.webkitTransform;
      if (currentTransform) {
        slide2.style.transform = "none";
      }
      if (currentWebKitTransform) {
        slide2.style.webkitTransform = "none";
      }
      if (params.roundLengths) {
        slideSize = swiper.isHorizontal() ? elementOuterSize(slide2, "width") : elementOuterSize(slide2, "height");
      } else {
        const width = getDirectionPropertyValue(slideStyles, "width");
        const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
        const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
        const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
        const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
        const boxSizing = slideStyles.getPropertyValue("box-sizing");
        if (boxSizing && boxSizing === "border-box") {
          slideSize = width + marginLeft + marginRight;
        } else {
          const {
            clientWidth,
            offsetWidth
          } = slide2;
          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
        }
      }
      if (currentTransform) {
        slide2.style.transform = currentTransform;
      }
      if (currentWebKitTransform) {
        slide2.style.webkitTransform = currentWebKitTransform;
      }
      if (params.roundLengths) slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
      if (params.roundLengths) slideSize = Math.floor(slideSize);
      if (slide2) {
        slide2.style[swiper.getDirectionLabel("width")] = `${slideSize}px`;
      }
    }
    if (slide2) {
      slide2.swiperSlideSize = slideSize;
    }
    slidesSizesGrid.push(slideSize);
    if (params.centeredSlides) {
      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1e3) slidePosition = 0;
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }
    swiper.virtualSize += slideSize + spaceBetween;
    prevSlideSize = slideSize;
    index += 1;
  }
  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
  if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) {
    wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;
  }
  if (params.setWrapperSize) {
    wrapperEl.style[swiper.getDirectionLabel("width")] = `${swiper.virtualSize + spaceBetween}px`;
  }
  if (gridEnabled) {
    swiper.grid.updateWrapperSize(slideSize, snapGrid);
  }
  if (!params.centeredSlides) {
    const newSlidesGrid = [];
    for (let i = 0; i < snapGrid.length; i += 1) {
      let slidesGridItem = snapGrid[i];
      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
        newSlidesGrid.push(slidesGridItem);
      }
    }
    snapGrid = newSlidesGrid;
    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper.virtualSize - swiperSize);
    }
  }
  if (isVirtual && params.loop) {
    const size = slidesSizesGrid[0] + spaceBetween;
    if (params.slidesPerGroup > 1) {
      const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);
      const groupSize = size * params.slidesPerGroup;
      for (let i = 0; i < groups; i += 1) {
        snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
      }
    }
    for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {
      if (params.slidesPerGroup === 1) {
        snapGrid.push(snapGrid[snapGrid.length - 1] + size);
      }
      slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
      swiper.virtualSize += size;
    }
  }
  if (snapGrid.length === 0) snapGrid = [0];
  if (spaceBetween !== 0) {
    const key = swiper.isHorizontal() && rtl ? "marginLeft" : swiper.getDirectionLabel("marginRight");
    slides.filter((_, slideIndex) => {
      if (!params.cssMode || params.loop) return true;
      if (slideIndex === slides.length - 1) {
        return false;
      }
      return true;
    }).forEach((slideEl) => {
      slideEl.style[key] = `${spaceBetween}px`;
    });
  }
  if (params.centeredSlides && params.centeredSlidesBounds) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach((slideSizeValue) => {
      allSlidesSize += slideSizeValue + (spaceBetween || 0);
    });
    allSlidesSize -= spaceBetween;
    const maxSnap = allSlidesSize > swiperSize ? allSlidesSize - swiperSize : 0;
    snapGrid = snapGrid.map((snap) => {
      if (snap <= 0) return -offsetBefore;
      if (snap > maxSnap) return maxSnap + offsetAfter;
      return snap;
    });
  }
  if (params.centerInsufficientSlides) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach((slideSizeValue) => {
      allSlidesSize += slideSizeValue + (spaceBetween || 0);
    });
    allSlidesSize -= spaceBetween;
    const offsetSize = (offsetBefore || 0) + (offsetAfter || 0);
    if (allSlidesSize + offsetSize < swiperSize) {
      const allSlidesOffset = (swiperSize - allSlidesSize - offsetSize) / 2;
      snapGrid.forEach((snap, snapIndex) => {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      });
      slidesGrid.forEach((snap, snapIndex) => {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }
  Object.assign(swiper, {
    slides,
    snapGrid,
    slidesGrid,
    slidesSizesGrid
  });
  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
    setCSSProperty(wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`);
    setCSSProperty(wrapperEl, "--swiper-centered-offset-after", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
    const addToSnapGrid = -swiper.snapGrid[0];
    const addToSlidesGrid = -swiper.slidesGrid[0];
    swiper.snapGrid = swiper.snapGrid.map((v) => v + addToSnapGrid);
    swiper.slidesGrid = swiper.slidesGrid.map((v) => v + addToSlidesGrid);
  }
  if (slidesLength !== previousSlidesLength) {
    swiper.emit("slidesLengthChange");
  }
  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper.params.watchOverflow) swiper.checkOverflow();
    swiper.emit("snapGridLengthChange");
  }
  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper.emit("slidesGridLengthChange");
  }
  if (params.watchSlidesProgress) {
    swiper.updateSlidesOffset();
  }
  swiper.emit("slidesUpdated");
  if (!isVirtual && !params.cssMode && (params.effect === "slide" || params.effect === "fade")) {
    const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
    const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
    if (slidesLength <= params.maxBackfaceHiddenSlides) {
      if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);
    } else if (hasClassBackfaceClassAdded) {
      swiper.el.classList.remove(backFaceHiddenClass);
    }
  }
}
function updateAutoHeight(speed) {
  const swiper = this;
  const activeSlides = [];
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
  let newHeight = 0;
  let i;
  if (typeof speed === "number") {
    swiper.setTransition(speed);
  } else if (speed === true) {
    swiper.setTransition(swiper.params.speed);
  }
  const getSlideByIndex = (index) => {
    if (isVirtual) {
      return swiper.slides[swiper.getSlideIndexByData(index)];
    }
    return swiper.slides[index];
  };
  if (swiper.params.slidesPerView !== "auto" && swiper.params.slidesPerView > 1) {
    if (swiper.params.centeredSlides) {
      (swiper.visibleSlides || []).forEach((slide2) => {
        activeSlides.push(slide2);
      });
    } else {
      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
        const index = swiper.activeIndex + i;
        if (index > swiper.slides.length && !isVirtual) break;
        activeSlides.push(getSlideByIndex(index));
      }
    }
  } else {
    activeSlides.push(getSlideByIndex(swiper.activeIndex));
  }
  for (i = 0; i < activeSlides.length; i += 1) {
    if (typeof activeSlides[i] !== "undefined") {
      const height = activeSlides[i].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  }
  if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;
}
function updateSlidesOffset() {
  const swiper = this;
  const slides = swiper.slides;
  const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
  for (let i = 0; i < slides.length; i += 1) {
    slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();
  }
}
const toggleSlideClasses$1 = (slideEl, condition, className) => {
  if (condition && !slideEl.classList.contains(className)) {
    slideEl.classList.add(className);
  } else if (!condition && slideEl.classList.contains(className)) {
    slideEl.classList.remove(className);
  }
};
function updateSlidesProgress(translate2 = this && this.translate || 0) {
  const swiper = this;
  const params = swiper.params;
  const {
    slides,
    rtlTranslate: rtl,
    snapGrid
  } = swiper;
  if (slides.length === 0) return;
  if (typeof slides[0].swiperSlideOffset === "undefined") swiper.updateSlidesOffset();
  let offsetCenter = -translate2;
  if (rtl) offsetCenter = translate2;
  swiper.visibleSlidesIndexes = [];
  swiper.visibleSlides = [];
  let spaceBetween = params.spaceBetween;
  if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiper.size;
  } else if (typeof spaceBetween === "string") {
    spaceBetween = parseFloat(spaceBetween);
  }
  for (let i = 0; i < slides.length; i += 1) {
    const slide2 = slides[i];
    let slideOffset = slide2.swiperSlideOffset;
    if (params.cssMode && params.centeredSlides) {
      slideOffset -= slides[0].swiperSlideOffset;
    }
    const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);
    const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);
    const slideBefore = -(offsetCenter - slideOffset);
    const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
    const isFullyVisible = slideBefore >= 0 && slideBefore <= swiper.size - swiper.slidesSizesGrid[i];
    const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
    if (isVisible) {
      swiper.visibleSlides.push(slide2);
      swiper.visibleSlidesIndexes.push(i);
    }
    toggleSlideClasses$1(slide2, isVisible, params.slideVisibleClass);
    toggleSlideClasses$1(slide2, isFullyVisible, params.slideFullyVisibleClass);
    slide2.progress = rtl ? -slideProgress : slideProgress;
    slide2.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
  }
}
function updateProgress(translate2) {
  const swiper = this;
  if (typeof translate2 === "undefined") {
    const multiplier = swiper.rtlTranslate ? -1 : 1;
    translate2 = swiper && swiper.translate && swiper.translate * multiplier || 0;
  }
  const params = swiper.params;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  let {
    progress,
    isBeginning,
    isEnd,
    progressLoop
  } = swiper;
  const wasBeginning = isBeginning;
  const wasEnd = isEnd;
  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate2 - swiper.minTranslate()) / translatesDiff;
    const isBeginningRounded = Math.abs(translate2 - swiper.minTranslate()) < 1;
    const isEndRounded = Math.abs(translate2 - swiper.maxTranslate()) < 1;
    isBeginning = isBeginningRounded || progress <= 0;
    isEnd = isEndRounded || progress >= 1;
    if (isBeginningRounded) progress = 0;
    if (isEndRounded) progress = 1;
  }
  if (params.loop) {
    const firstSlideIndex = swiper.getSlideIndexByData(0);
    const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);
    const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
    const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
    const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];
    const translateAbs = Math.abs(translate2);
    if (translateAbs >= firstSlideTranslate) {
      progressLoop = (translateAbs - firstSlideTranslate) / translateMax;
    } else {
      progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
    }
    if (progressLoop > 1) progressLoop -= 1;
  }
  Object.assign(swiper, {
    progress,
    progressLoop,
    isBeginning,
    isEnd
  });
  if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate2);
  if (isBeginning && !wasBeginning) {
    swiper.emit("reachBeginning toEdge");
  }
  if (isEnd && !wasEnd) {
    swiper.emit("reachEnd toEdge");
  }
  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
    swiper.emit("fromEdge");
  }
  swiper.emit("progress", progress);
}
const toggleSlideClasses = (slideEl, condition, className) => {
  if (condition && !slideEl.classList.contains(className)) {
    slideEl.classList.add(className);
  } else if (!condition && slideEl.classList.contains(className)) {
    slideEl.classList.remove(className);
  }
};
function updateSlidesClasses() {
  const swiper = this;
  const {
    slides,
    params,
    slidesEl,
    activeIndex
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
  const getFilteredSlide = (selector2) => {
    return elementChildren(slidesEl, `.${params.slideClass}${selector2}, swiper-slide${selector2}`)[0];
  };
  let activeSlide;
  let prevSlide;
  let nextSlide;
  if (isVirtual) {
    if (params.loop) {
      let slideIndex = activeIndex - swiper.virtual.slidesBefore;
      if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;
      if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;
      activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
    } else {
      activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`);
    }
  } else {
    if (gridEnabled) {
      activeSlide = slides.find((slideEl) => slideEl.column === activeIndex);
      nextSlide = slides.find((slideEl) => slideEl.column === activeIndex + 1);
      prevSlide = slides.find((slideEl) => slideEl.column === activeIndex - 1);
    } else {
      activeSlide = slides[activeIndex];
    }
  }
  if (activeSlide) {
    if (!gridEnabled) {
      nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
      if (params.loop && !nextSlide) {
        nextSlide = slides[0];
      }
      prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
      if (params.loop && !prevSlide === 0) {
        prevSlide = slides[slides.length - 1];
      }
    }
  }
  slides.forEach((slideEl) => {
    toggleSlideClasses(slideEl, slideEl === activeSlide, params.slideActiveClass);
    toggleSlideClasses(slideEl, slideEl === nextSlide, params.slideNextClass);
    toggleSlideClasses(slideEl, slideEl === prevSlide, params.slidePrevClass);
  });
  swiper.emitSlidesClasses();
}
const processLazyPreloader = (swiper, imageEl) => {
  if (!swiper || swiper.destroyed || !swiper.params) return;
  const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
  const slideEl = imageEl.closest(slideSelector());
  if (slideEl) {
    let lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);
    if (!lazyEl && swiper.isElement) {
      if (slideEl.shadowRoot) {
        lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
      } else {
        requestAnimationFrame(() => {
          if (slideEl.shadowRoot) {
            lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
            if (lazyEl) lazyEl.remove();
          }
        });
      }
    }
    if (lazyEl) lazyEl.remove();
  }
};
const unlazy = (swiper, index) => {
  if (!swiper.slides[index]) return;
  const imageEl = swiper.slides[index].querySelector('[loading="lazy"]');
  if (imageEl) imageEl.removeAttribute("loading");
};
const preload = (swiper) => {
  if (!swiper || swiper.destroyed || !swiper.params) return;
  let amount = swiper.params.lazyPreloadPrevNext;
  const len = swiper.slides.length;
  if (!len || !amount || amount < 0) return;
  amount = Math.min(amount, len);
  const slidesPerView = swiper.params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);
  const activeIndex = swiper.activeIndex;
  if (swiper.params.grid && swiper.params.grid.rows > 1) {
    const activeColumn = activeIndex;
    const preloadColumns = [activeColumn - amount];
    preloadColumns.push(...Array.from({
      length: amount
    }).map((_, i) => {
      return activeColumn + slidesPerView + i;
    }));
    swiper.slides.forEach((slideEl, i) => {
      if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);
    });
    return;
  }
  const slideIndexLastInView = activeIndex + slidesPerView - 1;
  if (swiper.params.rewind || swiper.params.loop) {
    for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {
      const realIndex = (i % len + len) % len;
      if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);
    }
  } else {
    for (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) {
      if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {
        unlazy(swiper, i);
      }
    }
  }
};
function getActiveIndexByTranslate(swiper) {
  const {
    slidesGrid,
    params
  } = swiper;
  const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  let activeIndex;
  for (let i = 0; i < slidesGrid.length; i += 1) {
    if (typeof slidesGrid[i + 1] !== "undefined") {
      if (translate2 >= slidesGrid[i] && translate2 < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
        activeIndex = i;
      } else if (translate2 >= slidesGrid[i] && translate2 < slidesGrid[i + 1]) {
        activeIndex = i + 1;
      }
    } else if (translate2 >= slidesGrid[i]) {
      activeIndex = i;
    }
  }
  if (params.normalizeSlideIndex) {
    if (activeIndex < 0 || typeof activeIndex === "undefined") activeIndex = 0;
  }
  return activeIndex;
}
function updateActiveIndex(newActiveIndex) {
  const swiper = this;
  const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  const {
    snapGrid,
    params,
    activeIndex: previousIndex,
    realIndex: previousRealIndex,
    snapIndex: previousSnapIndex
  } = swiper;
  let activeIndex = newActiveIndex;
  let snapIndex;
  const getVirtualRealIndex = (aIndex) => {
    let realIndex2 = aIndex - swiper.virtual.slidesBefore;
    if (realIndex2 < 0) {
      realIndex2 = swiper.virtual.slides.length + realIndex2;
    }
    if (realIndex2 >= swiper.virtual.slides.length) {
      realIndex2 -= swiper.virtual.slides.length;
    }
    return realIndex2;
  };
  if (typeof activeIndex === "undefined") {
    activeIndex = getActiveIndexByTranslate(swiper);
  }
  if (snapGrid.indexOf(translate2) >= 0) {
    snapIndex = snapGrid.indexOf(translate2);
  } else {
    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
  }
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
  if (activeIndex === previousIndex && !swiper.params.loop) {
    if (snapIndex !== previousSnapIndex) {
      swiper.snapIndex = snapIndex;
      swiper.emit("snapIndexChange");
    }
    return;
  }
  if (activeIndex === previousIndex && swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
    swiper.realIndex = getVirtualRealIndex(activeIndex);
    return;
  }
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
  let realIndex;
  if (swiper.virtual && params.virtual.enabled && params.loop) {
    realIndex = getVirtualRealIndex(activeIndex);
  } else if (gridEnabled) {
    const firstSlideInColumn = swiper.slides.find((slideEl) => slideEl.column === activeIndex);
    let activeSlideIndex = parseInt(firstSlideInColumn.getAttribute("data-swiper-slide-index"), 10);
    if (Number.isNaN(activeSlideIndex)) {
      activeSlideIndex = Math.max(swiper.slides.indexOf(firstSlideInColumn), 0);
    }
    realIndex = Math.floor(activeSlideIndex / params.grid.rows);
  } else if (swiper.slides[activeIndex]) {
    const slideIndex = swiper.slides[activeIndex].getAttribute("data-swiper-slide-index");
    if (slideIndex) {
      realIndex = parseInt(slideIndex, 10);
    } else {
      realIndex = activeIndex;
    }
  } else {
    realIndex = activeIndex;
  }
  Object.assign(swiper, {
    previousSnapIndex,
    snapIndex,
    previousRealIndex,
    realIndex,
    previousIndex,
    activeIndex
  });
  if (swiper.initialized) {
    preload(swiper);
  }
  swiper.emit("activeIndexChange");
  swiper.emit("snapIndexChange");
  if (swiper.initialized || swiper.params.runCallbacksOnInit) {
    if (previousRealIndex !== realIndex) {
      swiper.emit("realIndexChange");
    }
    swiper.emit("slideChange");
  }
}
function updateClickedSlide(el, path) {
  const swiper = this;
  const params = swiper.params;
  let slide2 = el.closest(`.${params.slideClass}, swiper-slide`);
  if (!slide2 && swiper.isElement && path && path.length > 1 && path.includes(el)) {
    [...path.slice(path.indexOf(el) + 1, path.length)].forEach((pathEl) => {
      if (!slide2 && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) {
        slide2 = pathEl;
      }
    });
  }
  let slideFound = false;
  let slideIndex;
  if (slide2) {
    for (let i = 0; i < swiper.slides.length; i += 1) {
      if (swiper.slides[i] === slide2) {
        slideFound = true;
        slideIndex = i;
        break;
      }
    }
  }
  if (slide2 && slideFound) {
    swiper.clickedSlide = slide2;
    if (swiper.virtual && swiper.params.virtual.enabled) {
      swiper.clickedIndex = parseInt(slide2.getAttribute("data-swiper-slide-index"), 10);
    } else {
      swiper.clickedIndex = slideIndex;
    }
  } else {
    swiper.clickedSlide = void 0;
    swiper.clickedIndex = void 0;
    return;
  }
  if (params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex) {
    swiper.slideToClickedSlide();
  }
}
var update = {
  updateSize,
  updateSlides,
  updateAutoHeight,
  updateSlidesOffset,
  updateSlidesProgress,
  updateProgress,
  updateSlidesClasses,
  updateActiveIndex,
  updateClickedSlide
};
function getSwiperTranslate(axis = this.isHorizontal() ? "x" : "y") {
  const swiper = this;
  const {
    params,
    rtlTranslate: rtl,
    translate: translate2,
    wrapperEl
  } = swiper;
  if (params.virtualTranslate) {
    return rtl ? -translate2 : translate2;
  }
  if (params.cssMode) {
    return translate2;
  }
  let currentTranslate = getTranslate(wrapperEl, axis);
  currentTranslate += swiper.cssOverflowAdjustment();
  if (rtl) currentTranslate = -currentTranslate;
  return currentTranslate || 0;
}
function setTranslate(translate2, byController) {
  const swiper = this;
  const {
    rtlTranslate: rtl,
    params,
    wrapperEl,
    progress
  } = swiper;
  let x = 0;
  let y = 0;
  const z = 0;
  if (swiper.isHorizontal()) {
    x = rtl ? -translate2 : translate2;
  } else {
    y = translate2;
  }
  if (params.roundLengths) {
    x = Math.floor(x);
    y = Math.floor(y);
  }
  swiper.previousTranslate = swiper.translate;
  swiper.translate = swiper.isHorizontal() ? x : y;
  if (params.cssMode) {
    wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x : -y;
  } else if (!params.virtualTranslate) {
    if (swiper.isHorizontal()) {
      x -= swiper.cssOverflowAdjustment();
    } else {
      y -= swiper.cssOverflowAdjustment();
    }
    wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;
  }
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate2 - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== progress) {
    swiper.updateProgress(translate2);
  }
  swiper.emit("setTranslate", swiper.translate, byController);
}
function minTranslate() {
  return -this.snapGrid[0];
}
function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1];
}
function translateTo(translate2 = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {
  const swiper = this;
  const {
    params,
    wrapperEl
  } = swiper;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }
  const minTranslate2 = swiper.minTranslate();
  const maxTranslate2 = swiper.maxTranslate();
  let newTranslate;
  if (translateBounds && translate2 > minTranslate2) newTranslate = minTranslate2;
  else if (translateBounds && translate2 < maxTranslate2) newTranslate = maxTranslate2;
  else newTranslate = translate2;
  swiper.updateProgress(newTranslate);
  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    if (speed === 0) {
      wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate;
    } else {
      if (!swiper.support.smoothScroll) {
        animateCSSModeScroll({
          swiper,
          targetPosition: -newTranslate,
          side: isH ? "left" : "top"
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? "left" : "top"]: -newTranslate,
        behavior: "smooth"
      });
    }
    return true;
  }
  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit("beforeTransitionStart", speed, internal);
      swiper.emit("transitionEnd");
    }
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit("beforeTransitionStart", speed, internal);
      swiper.emit("transitionStart");
    }
    if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onTranslateToWrapperTransitionEnd) {
        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd2(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.wrapperEl.removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
          swiper.onTranslateToWrapperTransitionEnd = null;
          delete swiper.onTranslateToWrapperTransitionEnd;
          swiper.animating = false;
          if (runCallbacks) {
            swiper.emit("transitionEnd");
          }
        };
      }
      swiper.wrapperEl.addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
    }
  }
  return true;
}
var translate = {
  getTranslate: getSwiperTranslate,
  setTranslate,
  minTranslate,
  maxTranslate,
  translateTo
};
function setTransition(duration, byController) {
  const swiper = this;
  if (!swiper.params.cssMode) {
    swiper.wrapperEl.style.transitionDuration = `${duration}ms`;
    swiper.wrapperEl.style.transitionDelay = duration === 0 ? `0ms` : "";
  }
  swiper.emit("setTransition", duration, byController);
}
function transitionEmit({
  swiper,
  runCallbacks,
  direction,
  step
}) {
  const {
    activeIndex,
    previousIndex
  } = swiper;
  let dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex) dir = "next";
    else if (activeIndex < previousIndex) dir = "prev";
    else dir = "reset";
  }
  swiper.emit(`transition${step}`);
  if (runCallbacks && dir === "reset") {
    swiper.emit(`slideResetTransition${step}`);
  } else if (runCallbacks && activeIndex !== previousIndex) {
    swiper.emit(`slideChangeTransition${step}`);
    if (dir === "next") {
      swiper.emit(`slideNextTransition${step}`);
    } else {
      swiper.emit(`slidePrevTransition${step}`);
    }
  }
}
function transitionStart(runCallbacks = true, direction) {
  const swiper = this;
  const {
    params
  } = swiper;
  if (params.cssMode) return;
  if (params.autoHeight) {
    swiper.updateAutoHeight();
  }
  transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: "Start"
  });
}
function transitionEnd(runCallbacks = true, direction) {
  const swiper = this;
  const {
    params
  } = swiper;
  swiper.animating = false;
  if (params.cssMode) return;
  swiper.setTransition(0);
  transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: "End"
  });
}
var transition = {
  setTransition,
  transitionStart,
  transitionEnd
};
function slideTo(index = 0, speed, runCallbacks = true, internal, initial) {
  if (typeof index === "string") {
    index = parseInt(index, 10);
  }
  const swiper = this;
  let slideIndex = index;
  if (slideIndex < 0) slideIndex = 0;
  const {
    params,
    snapGrid,
    slidesGrid,
    previousIndex,
    activeIndex,
    rtlTranslate: rtl,
    wrapperEl,
    enabled
  } = swiper;
  if (!enabled && !internal && !initial || swiper.destroyed || swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }
  if (typeof speed === "undefined") {
    speed = swiper.params.speed;
  }
  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
  const translate2 = -snapGrid[snapIndex];
  if (params.normalizeSlideIndex) {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      const normalizedTranslate = -Math.floor(translate2 * 100);
      const normalizedGrid = Math.floor(slidesGrid[i] * 100);
      const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
      if (typeof slidesGrid[i + 1] !== "undefined") {
        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
          slideIndex = i;
        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
          slideIndex = i + 1;
        }
      } else if (normalizedTranslate >= normalizedGrid) {
        slideIndex = i;
      }
    }
  }
  if (swiper.initialized && slideIndex !== activeIndex) {
    if (!swiper.allowSlideNext && (rtl ? translate2 > swiper.translate && translate2 > swiper.minTranslate() : translate2 < swiper.translate && translate2 < swiper.minTranslate())) {
      return false;
    }
    if (!swiper.allowSlidePrev && translate2 > swiper.translate && translate2 > swiper.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex) {
        return false;
      }
    }
  }
  if (slideIndex !== (previousIndex || 0) && runCallbacks) {
    swiper.emit("beforeSlideChangeStart");
  }
  swiper.updateProgress(translate2);
  let direction;
  if (slideIndex > activeIndex) direction = "next";
  else if (slideIndex < activeIndex) direction = "prev";
  else direction = "reset";
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
  const isInitialVirtual = isVirtual && initial;
  if (!isInitialVirtual && (rtl && -translate2 === swiper.translate || !rtl && translate2 === swiper.translate)) {
    swiper.updateActiveIndex(slideIndex);
    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
    swiper.updateSlidesClasses();
    if (params.effect !== "slide") {
      swiper.setTranslate(translate2);
    }
    if (direction !== "reset") {
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    }
    return false;
  }
  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    const t = rtl ? translate2 : -translate2;
    if (speed === 0) {
      if (isVirtual) {
        swiper.wrapperEl.style.scrollSnapType = "none";
        swiper._immediateVirtual = true;
      }
      if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {
        swiper._cssModeVirtualInitialSet = true;
        requestAnimationFrame(() => {
          wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
        });
      } else {
        wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
      }
      if (isVirtual) {
        requestAnimationFrame(() => {
          swiper.wrapperEl.style.scrollSnapType = "";
          swiper._immediateVirtual = false;
        });
      }
    } else {
      if (!swiper.support.smoothScroll) {
        animateCSSModeScroll({
          swiper,
          targetPosition: t,
          side: isH ? "left" : "top"
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? "left" : "top"]: t,
        behavior: "smooth"
      });
    }
    return true;
  }
  const browser2 = getBrowser();
  const isSafari = browser2.isSafari;
  if (isVirtual && !initial && isSafari && swiper.isElement) {
    swiper.virtual.update(false, false, slideIndex);
  }
  swiper.setTransition(speed);
  swiper.setTranslate(translate2);
  swiper.updateActiveIndex(slideIndex);
  swiper.updateSlidesClasses();
  swiper.emit("beforeTransitionStart", speed, internal);
  swiper.transitionStart(runCallbacks, direction);
  if (speed === 0) {
    swiper.transitionEnd(runCallbacks, direction);
  } else if (!swiper.animating) {
    swiper.animating = true;
    if (!swiper.onSlideToWrapperTransitionEnd) {
      swiper.onSlideToWrapperTransitionEnd = function transitionEnd2(e) {
        if (!swiper || swiper.destroyed) return;
        if (e.target !== this) return;
        swiper.wrapperEl.removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
        swiper.onSlideToWrapperTransitionEnd = null;
        delete swiper.onSlideToWrapperTransitionEnd;
        swiper.transitionEnd(runCallbacks, direction);
      };
    }
    swiper.wrapperEl.addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
  }
  return true;
}
function slideToLoop(index = 0, speed, runCallbacks = true, internal) {
  if (typeof index === "string") {
    const indexAsNumber = parseInt(index, 10);
    index = indexAsNumber;
  }
  const swiper = this;
  if (swiper.destroyed) return;
  if (typeof speed === "undefined") {
    speed = swiper.params.speed;
  }
  const gridEnabled = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;
  let newIndex = index;
  if (swiper.params.loop) {
    if (swiper.virtual && swiper.params.virtual.enabled) {
      newIndex = newIndex + swiper.virtual.slidesBefore;
    } else {
      let targetSlideIndex;
      if (gridEnabled) {
        const slideIndex = newIndex * swiper.params.grid.rows;
        targetSlideIndex = swiper.slides.find((slideEl) => slideEl.getAttribute("data-swiper-slide-index") * 1 === slideIndex).column;
      } else {
        targetSlideIndex = swiper.getSlideIndexByData(newIndex);
      }
      const cols = gridEnabled ? Math.ceil(swiper.slides.length / swiper.params.grid.rows) : swiper.slides.length;
      const {
        centeredSlides,
        slidesOffsetBefore,
        slidesOffsetAfter
      } = swiper.params;
      const bothDirections = centeredSlides || !!slidesOffsetBefore || !!slidesOffsetAfter;
      let slidesPerView = swiper.params.slidesPerView;
      if (slidesPerView === "auto") {
        slidesPerView = swiper.slidesPerViewDynamic();
      } else {
        slidesPerView = Math.ceil(parseFloat(swiper.params.slidesPerView, 10));
        if (bothDirections && slidesPerView % 2 === 0) {
          slidesPerView = slidesPerView + 1;
        }
      }
      let needLoopFix = cols - targetSlideIndex < slidesPerView;
      if (bothDirections) {
        needLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2);
      }
      if (internal && bothDirections && swiper.params.slidesPerView !== "auto" && !gridEnabled) {
        needLoopFix = false;
      }
      if (needLoopFix) {
        const direction = bothDirections ? targetSlideIndex < swiper.activeIndex ? "prev" : "next" : targetSlideIndex - swiper.activeIndex - 1 < swiper.params.slidesPerView ? "next" : "prev";
        swiper.loopFix({
          direction,
          slideTo: true,
          activeSlideIndex: direction === "next" ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,
          slideRealIndex: direction === "next" ? swiper.realIndex : void 0
        });
      }
      if (gridEnabled) {
        const slideIndex = newIndex * swiper.params.grid.rows;
        newIndex = swiper.slides.find((slideEl) => slideEl.getAttribute("data-swiper-slide-index") * 1 === slideIndex).column;
      } else {
        newIndex = swiper.getSlideIndexByData(newIndex);
      }
    }
  }
  requestAnimationFrame(() => {
    swiper.slideTo(newIndex, speed, runCallbacks, internal);
  });
  return swiper;
}
function slideNext(speed, runCallbacks = true, internal) {
  const swiper = this;
  const {
    enabled,
    params,
    animating
  } = swiper;
  if (!enabled || swiper.destroyed) return swiper;
  if (typeof speed === "undefined") {
    speed = swiper.params.speed;
  }
  let perGroup = params.slidesPerGroup;
  if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
    perGroup = Math.max(swiper.slidesPerViewDynamic("current", true), 1);
  }
  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  if (params.loop) {
    if (animating && !isVirtual && params.loopPreventsSliding) return false;
    swiper.loopFix({
      direction: "next"
    });
    swiper._clientLeft = swiper.wrapperEl.clientLeft;
    if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {
      requestAnimationFrame(() => {
        swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
      });
      return true;
    }
  }
  if (params.rewind && swiper.isEnd) {
    return swiper.slideTo(0, speed, runCallbacks, internal);
  }
  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}
function slidePrev(speed, runCallbacks = true, internal) {
  const swiper = this;
  const {
    params,
    snapGrid,
    slidesGrid,
    rtlTranslate,
    enabled,
    animating
  } = swiper;
  if (!enabled || swiper.destroyed) return swiper;
  if (typeof speed === "undefined") {
    speed = swiper.params.speed;
  }
  const isVirtual = swiper.virtual && params.virtual.enabled;
  if (params.loop) {
    if (animating && !isVirtual && params.loopPreventsSliding) return false;
    swiper.loopFix({
      direction: "prev"
    });
    swiper._clientLeft = swiper.wrapperEl.clientLeft;
  }
  const translate2 = rtlTranslate ? swiper.translate : -swiper.translate;
  function normalize(val) {
    if (val < 0) return -Math.floor(Math.abs(val));
    return Math.floor(val);
  }
  const normalizedTranslate = normalize(translate2);
  const normalizedSnapGrid = snapGrid.map((val) => normalize(val));
  const isFreeMode = params.freeMode && params.freeMode.enabled;
  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
  if (typeof prevSnap === "undefined" && (params.cssMode || isFreeMode)) {
    let prevSnapIndex;
    snapGrid.forEach((snap, snapIndex) => {
      if (normalizedTranslate >= snap) {
        prevSnapIndex = snapIndex;
      }
    });
    if (typeof prevSnapIndex !== "undefined") {
      prevSnap = isFreeMode ? snapGrid[prevSnapIndex] : snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
    }
  }
  let prevIndex = 0;
  if (typeof prevSnap !== "undefined") {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
    if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
      prevIndex = prevIndex - swiper.slidesPerViewDynamic("previous", true) + 1;
      prevIndex = Math.max(prevIndex, 0);
    }
  }
  if (params.rewind && swiper.isBeginning) {
    const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
    return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
  } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {
    requestAnimationFrame(() => {
      swiper.slideTo(prevIndex, speed, runCallbacks, internal);
    });
    return true;
  }
  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}
function slideReset(speed, runCallbacks = true, internal) {
  const swiper = this;
  if (swiper.destroyed) return;
  if (typeof speed === "undefined") {
    speed = swiper.params.speed;
  }
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}
function slideToClosest(speed, runCallbacks = true, internal, threshold = 0.5) {
  const swiper = this;
  if (swiper.destroyed) return;
  if (typeof speed === "undefined") {
    speed = swiper.params.speed;
  }
  let index = swiper.activeIndex;
  const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
  const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
  const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  if (translate2 >= swiper.snapGrid[snapIndex]) {
    const currentSnap = swiper.snapGrid[snapIndex];
    const nextSnap = swiper.snapGrid[snapIndex + 1];
    if (translate2 - currentSnap > (nextSnap - currentSnap) * threshold) {
      index += swiper.params.slidesPerGroup;
    }
  } else {
    const prevSnap = swiper.snapGrid[snapIndex - 1];
    const currentSnap = swiper.snapGrid[snapIndex];
    if (translate2 - prevSnap <= (currentSnap - prevSnap) * threshold) {
      index -= swiper.params.slidesPerGroup;
    }
  }
  index = Math.max(index, 0);
  index = Math.min(index, swiper.slidesGrid.length - 1);
  return swiper.slideTo(index, speed, runCallbacks, internal);
}
function slideToClickedSlide() {
  const swiper = this;
  if (swiper.destroyed) return;
  const {
    params,
    slidesEl
  } = swiper;
  const slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : params.slidesPerView;
  let slideToIndex = swiper.getSlideIndexWhenGrid(swiper.clickedIndex);
  let realIndex;
  const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;
  const isGrid = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;
  if (params.loop) {
    if (swiper.animating) return;
    realIndex = parseInt(swiper.clickedSlide.getAttribute("data-swiper-slide-index"), 10);
    if (params.centeredSlides) {
      swiper.slideToLoop(realIndex);
    } else if (slideToIndex > (isGrid ? (swiper.slides.length - slidesPerView) / 2 - (swiper.params.grid.rows - 1) : swiper.slides.length - slidesPerView)) {
      swiper.loopFix();
      slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
      nextTick(() => {
        swiper.slideTo(slideToIndex);
      });
    } else {
      swiper.slideTo(slideToIndex);
    }
  } else {
    swiper.slideTo(slideToIndex);
  }
}
var slide = {
  slideTo,
  slideToLoop,
  slideNext,
  slidePrev,
  slideReset,
  slideToClosest,
  slideToClickedSlide
};
function loopCreate(slideRealIndex, initial) {
  const swiper = this;
  const {
    params,
    slidesEl
  } = swiper;
  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
  const initSlides = () => {
    const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
    slides.forEach((el, index) => {
      el.setAttribute("data-swiper-slide-index", index);
    });
  };
  const clearBlankSlides = () => {
    const slides = elementChildren(slidesEl, `.${params.slideBlankClass}`);
    slides.forEach((el) => {
      el.remove();
    });
    if (slides.length > 0) {
      swiper.recalcSlides();
      swiper.updateSlides();
    }
  };
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
  if (params.loopAddBlankSlides && (params.slidesPerGroup > 1 || gridEnabled)) {
    clearBlankSlides();
  }
  const slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);
  const shouldFillGroup = swiper.slides.length % slidesPerGroup !== 0;
  const shouldFillGrid = gridEnabled && swiper.slides.length % params.grid.rows !== 0;
  const addBlankSlides = (amountOfSlides) => {
    for (let i = 0; i < amountOfSlides; i += 1) {
      const slideEl = swiper.isElement ? createElement("swiper-slide", [params.slideBlankClass]) : createElement("div", [params.slideClass, params.slideBlankClass]);
      swiper.slidesEl.append(slideEl);
    }
  };
  if (shouldFillGroup) {
    if (params.loopAddBlankSlides) {
      const slidesToAdd = slidesPerGroup - swiper.slides.length % slidesPerGroup;
      addBlankSlides(slidesToAdd);
      swiper.recalcSlides();
      swiper.updateSlides();
    } else {
      showWarning("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
    }
    initSlides();
  } else if (shouldFillGrid) {
    if (params.loopAddBlankSlides) {
      const slidesToAdd = params.grid.rows - swiper.slides.length % params.grid.rows;
      addBlankSlides(slidesToAdd);
      swiper.recalcSlides();
      swiper.updateSlides();
    } else {
      showWarning("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
    }
    initSlides();
  } else {
    initSlides();
  }
  const bothDirections = params.centeredSlides || !!params.slidesOffsetBefore || !!params.slidesOffsetAfter;
  swiper.loopFix({
    slideRealIndex,
    direction: bothDirections ? void 0 : "next",
    initial
  });
}
function loopFix({
  slideRealIndex,
  slideTo: slideTo2 = true,
  direction,
  setTranslate: setTranslate2,
  activeSlideIndex,
  initial,
  byController,
  byMousewheel
} = {}) {
  const swiper = this;
  if (!swiper.params.loop) return;
  swiper.emit("beforeLoopFix");
  const {
    slides,
    allowSlidePrev,
    allowSlideNext,
    slidesEl,
    params
  } = swiper;
  const {
    centeredSlides,
    slidesOffsetBefore,
    slidesOffsetAfter,
    initialSlide
  } = params;
  const bothDirections = centeredSlides || !!slidesOffsetBefore || !!slidesOffsetAfter;
  swiper.allowSlidePrev = true;
  swiper.allowSlideNext = true;
  if (swiper.virtual && params.virtual.enabled) {
    if (slideTo2) {
      if (!bothDirections && swiper.snapIndex === 0) {
        swiper.slideTo(swiper.virtual.slides.length, 0, false, true);
      } else if (bothDirections && swiper.snapIndex < params.slidesPerView) {
        swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);
      } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {
        swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);
      }
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    swiper.emit("loopFix");
    return;
  }
  let slidesPerView = params.slidesPerView;
  if (slidesPerView === "auto") {
    slidesPerView = swiper.slidesPerViewDynamic();
  } else {
    slidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));
    if (bothDirections && slidesPerView % 2 === 0) {
      slidesPerView = slidesPerView + 1;
    }
  }
  const slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;
  let loopedSlides = bothDirections ? Math.max(slidesPerGroup, Math.ceil(slidesPerView / 2)) : slidesPerGroup;
  if (loopedSlides % slidesPerGroup !== 0) {
    loopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup;
  }
  loopedSlides += params.loopAdditionalSlides;
  swiper.loopedSlides = loopedSlides;
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
  if (slides.length < slidesPerView + loopedSlides || swiper.params.effect === "cards" && slides.length < slidesPerView + loopedSlides * 2) {
    showWarning("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled or not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters");
  } else if (gridEnabled && params.grid.fill === "row") {
    showWarning("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
  }
  const prependSlidesIndexes = [];
  const appendSlidesIndexes = [];
  const cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;
  const isInitialOverflow = initial && cols - initialSlide < slidesPerView && !bothDirections;
  let activeIndex = isInitialOverflow ? initialSlide : swiper.activeIndex;
  if (typeof activeSlideIndex === "undefined") {
    activeSlideIndex = swiper.getSlideIndex(slides.find((el) => el.classList.contains(params.slideActiveClass)));
  } else {
    activeIndex = activeSlideIndex;
  }
  const isNext = direction === "next" || !direction;
  const isPrev = direction === "prev" || !direction;
  let slidesPrepended = 0;
  let slidesAppended = 0;
  const activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;
  const activeColIndexWithShift = activeColIndex + (bothDirections && typeof setTranslate2 === "undefined" ? -slidesPerView / 2 + 0.5 : 0);
  if (activeColIndexWithShift < loopedSlides) {
    slidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);
    for (let i = 0; i < loopedSlides - activeColIndexWithShift; i += 1) {
      const index = i - Math.floor(i / cols) * cols;
      if (gridEnabled) {
        const colIndexToPrepend = cols - index - 1;
        for (let i2 = slides.length - 1; i2 >= 0; i2 -= 1) {
          if (slides[i2].column === colIndexToPrepend) prependSlidesIndexes.push(i2);
        }
      } else {
        prependSlidesIndexes.push(cols - index - 1);
      }
    }
  } else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {
    slidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);
    if (isInitialOverflow) {
      slidesAppended = Math.max(slidesAppended, slidesPerView - cols + initialSlide + 1);
    }
    for (let i = 0; i < slidesAppended; i += 1) {
      const index = i - Math.floor(i / cols) * cols;
      if (gridEnabled) {
        slides.forEach((slide2, slideIndex) => {
          if (slide2.column === index) appendSlidesIndexes.push(slideIndex);
        });
      } else {
        appendSlidesIndexes.push(index);
      }
    }
  }
  swiper.__preventObserver__ = true;
  requestAnimationFrame(() => {
    swiper.__preventObserver__ = false;
  });
  if (swiper.params.effect === "cards" && slides.length < slidesPerView + loopedSlides * 2) {
    if (appendSlidesIndexes.includes(activeSlideIndex)) {
      appendSlidesIndexes.splice(appendSlidesIndexes.indexOf(activeSlideIndex), 1);
    }
    if (prependSlidesIndexes.includes(activeSlideIndex)) {
      prependSlidesIndexes.splice(prependSlidesIndexes.indexOf(activeSlideIndex), 1);
    }
  }
  if (isPrev) {
    prependSlidesIndexes.forEach((index) => {
      slides[index].swiperLoopMoveDOM = true;
      slidesEl.prepend(slides[index]);
      slides[index].swiperLoopMoveDOM = false;
    });
  }
  if (isNext) {
    appendSlidesIndexes.forEach((index) => {
      slides[index].swiperLoopMoveDOM = true;
      slidesEl.append(slides[index]);
      slides[index].swiperLoopMoveDOM = false;
    });
  }
  swiper.recalcSlides();
  if (params.slidesPerView === "auto") {
    swiper.updateSlides();
  } else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) {
    swiper.slides.forEach((slide2, slideIndex) => {
      swiper.grid.updateSlide(slideIndex, slide2, swiper.slides);
    });
  }
  if (params.watchSlidesProgress) {
    swiper.updateSlidesOffset();
  }
  if (slideTo2) {
    if (prependSlidesIndexes.length > 0 && isPrev) {
      if (typeof slideRealIndex === "undefined") {
        const currentSlideTranslate = swiper.slidesGrid[activeIndex];
        const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];
        const diff = newSlideTranslate - currentSlideTranslate;
        if (byMousewheel) {
          swiper.setTranslate(swiper.translate - diff);
        } else {
          swiper.slideTo(activeIndex + Math.ceil(slidesPrepended), 0, false, true);
          if (setTranslate2) {
            swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
            swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
          }
        }
      } else {
        if (setTranslate2) {
          const shift = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;
          swiper.slideTo(swiper.activeIndex + shift, 0, false, true);
          swiper.touchEventsData.currentTranslate = swiper.translate;
        }
      }
    } else if (appendSlidesIndexes.length > 0 && isNext) {
      if (typeof slideRealIndex === "undefined") {
        const currentSlideTranslate = swiper.slidesGrid[activeIndex];
        const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];
        const diff = newSlideTranslate - currentSlideTranslate;
        if (byMousewheel) {
          swiper.setTranslate(swiper.translate - diff);
        } else {
          swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
          if (setTranslate2) {
            swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
            swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
          }
        }
      } else {
        const shift = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;
        swiper.slideTo(swiper.activeIndex - shift, 0, false, true);
      }
    }
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  if (swiper.controller && swiper.controller.control && !byController) {
    const loopParams = {
      slideRealIndex,
      direction,
      setTranslate: setTranslate2,
      activeSlideIndex,
      byController: true
    };
    if (Array.isArray(swiper.controller.control)) {
      swiper.controller.control.forEach((c) => {
        if (!c.destroyed && c.params.loop) c.loopFix({
          ...loopParams,
          slideTo: c.params.slidesPerView === params.slidesPerView ? slideTo2 : false
        });
      });
    } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {
      swiper.controller.control.loopFix({
        ...loopParams,
        slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo2 : false
      });
    }
  }
  swiper.emit("loopFix");
}
function loopDestroy() {
  const swiper = this;
  const {
    params,
    slidesEl
  } = swiper;
  if (!params.loop || !slidesEl || swiper.virtual && swiper.params.virtual.enabled) return;
  swiper.recalcSlides();
  const newSlidesOrder = [];
  swiper.slides.forEach((slideEl) => {
    const index = typeof slideEl.swiperSlideIndex === "undefined" ? slideEl.getAttribute("data-swiper-slide-index") * 1 : slideEl.swiperSlideIndex;
    newSlidesOrder[index] = slideEl;
  });
  swiper.slides.forEach((slideEl) => {
    slideEl.removeAttribute("data-swiper-slide-index");
  });
  newSlidesOrder.forEach((slideEl) => {
    slidesEl.append(slideEl);
  });
  swiper.recalcSlides();
  swiper.slideTo(swiper.realIndex, 0);
}
var loop = {
  loopCreate,
  loopFix,
  loopDestroy
};
function setGrabCursor(moving) {
  const swiper = this;
  if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
  const el = swiper.params.touchEventsTarget === "container" ? swiper.el : swiper.wrapperEl;
  if (swiper.isElement) {
    swiper.__preventObserver__ = true;
  }
  el.style.cursor = "move";
  el.style.cursor = moving ? "grabbing" : "grab";
  if (swiper.isElement) {
    requestAnimationFrame(() => {
      swiper.__preventObserver__ = false;
    });
  }
}
function unsetGrabCursor() {
  const swiper = this;
  if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
    return;
  }
  if (swiper.isElement) {
    swiper.__preventObserver__ = true;
  }
  swiper[swiper.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "";
  if (swiper.isElement) {
    requestAnimationFrame(() => {
      swiper.__preventObserver__ = false;
    });
  }
}
var grabCursor = {
  setGrabCursor,
  unsetGrabCursor
};
function closestElement(selector2, base = this) {
  function __closestFrom(el) {
    if (!el || el === getDocument() || el === getWindow()) return null;
    if (el.assignedSlot) el = el.assignedSlot;
    const found = el.closest(selector2);
    if (!found && !el.getRootNode) {
      return null;
    }
    return found || __closestFrom(el.getRootNode().host);
  }
  return __closestFrom(base);
}
function preventEdgeSwipe(swiper, event, startX) {
  const window2 = getWindow();
  const {
    params
  } = swiper;
  const edgeSwipeDetection = params.edgeSwipeDetection;
  const edgeSwipeThreshold = params.edgeSwipeThreshold;
  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window2.innerWidth - edgeSwipeThreshold)) {
    if (edgeSwipeDetection === "prevent") {
      event.preventDefault();
      return true;
    }
    return false;
  }
  return true;
}
function onTouchStart(event) {
  const swiper = this;
  const document2 = getDocument();
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  const data = swiper.touchEventsData;
  if (e.type === "pointerdown") {
    if (data.pointerId !== null && data.pointerId !== e.pointerId) {
      return;
    }
    data.pointerId = e.pointerId;
  } else if (e.type === "touchstart" && e.targetTouches.length === 1) {
    data.touchId = e.targetTouches[0].identifier;
  }
  if (e.type === "touchstart") {
    preventEdgeSwipe(swiper, e, e.targetTouches[0].pageX);
    return;
  }
  const {
    params,
    touches,
    enabled
  } = swiper;
  if (!enabled) return;
  if (!params.simulateTouch && e.pointerType === "mouse") return;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return;
  }
  if (!swiper.animating && params.cssMode && params.loop) {
    swiper.loopFix();
  }
  let targetEl = e.target;
  if (params.touchEventsTarget === "wrapper") {
    if (!elementIsChildOf(targetEl, swiper.wrapperEl)) return;
  }
  if ("which" in e && e.which === 3) return;
  if ("button" in e && e.button > 0) return;
  if (data.isTouched && data.isMoved) return;
  const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
  const eventPath = e.composedPath ? e.composedPath() : e.path;
  if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {
    targetEl = eventPath[0];
  }
  const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
  const isTargetShadow = !!(e.target && e.target.shadowRoot);
  if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
    swiper.allowClick = true;
    return;
  }
  if (params.swipeHandler) {
    if (!targetEl.closest(params.swipeHandler)) return;
  }
  touches.currentX = e.pageX;
  touches.currentY = e.pageY;
  const startX = touches.currentX;
  const startY = touches.currentY;
  if (!preventEdgeSwipe(swiper, e, startX)) {
    return;
  }
  Object.assign(data, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: void 0,
    startMoving: void 0
  });
  touches.startX = startX;
  touches.startY = startY;
  data.touchStartTime = now();
  swiper.allowClick = true;
  swiper.updateSize();
  swiper.swipeDirection = void 0;
  if (params.threshold > 0) data.allowThresholdMove = false;
  let preventDefault = true;
  if (targetEl.matches(data.focusableElements)) {
    preventDefault = false;
    if (targetEl.nodeName === "SELECT") {
      data.isTouched = false;
    }
  }
  if (document2.activeElement && document2.activeElement.matches(data.focusableElements) && document2.activeElement !== targetEl && (e.pointerType === "mouse" || e.pointerType !== "mouse" && !targetEl.matches(data.focusableElements))) {
    document2.activeElement.blur();
  }
  const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
  if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {
    e.preventDefault();
  }
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
    swiper.freeMode.onTouchStart();
  }
  swiper.emit("touchStart", e);
}
function onTouchMove(event) {
  const document2 = getDocument();
  const swiper = this;
  const data = swiper.touchEventsData;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    enabled
  } = swiper;
  if (!enabled) return;
  if (!params.simulateTouch && event.pointerType === "mouse") return;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  if (e.type === "pointermove") {
    if (data.touchId !== null) return;
    const id = e.pointerId;
    if (id !== data.pointerId) return;
  }
  let targetTouch;
  if (e.type === "touchmove") {
    targetTouch = [...e.changedTouches].find((t) => t.identifier === data.touchId);
    if (!targetTouch || targetTouch.identifier !== data.touchId) return;
  } else {
    targetTouch = e;
  }
  if (!data.isTouched) {
    if (data.startMoving && data.isScrolling) {
      swiper.emit("touchMoveOpposite", e);
    }
    return;
  }
  const pageX = targetTouch.pageX;
  const pageY = targetTouch.pageY;
  if (e.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }
  if (!swiper.allowTouchMove) {
    if (!e.target.matches(data.focusableElements)) {
      swiper.allowClick = false;
    }
    if (data.isTouched) {
      Object.assign(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY
      });
      data.touchStartTime = now();
    }
    return;
  }
  if (params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
        data.isTouched = false;
        data.isMoved = false;
        return;
      }
    } else if (rtl && (pageX > touches.startX && -swiper.translate <= swiper.maxTranslate() || pageX < touches.startX && -swiper.translate >= swiper.minTranslate())) {
      return;
    } else if (!rtl && (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate())) {
      return;
    }
  }
  if (document2.activeElement && document2.activeElement.matches(data.focusableElements) && document2.activeElement !== e.target && e.pointerType !== "mouse") {
    document2.activeElement.blur();
  }
  if (document2.activeElement) {
    if (e.target === document2.activeElement && e.target.matches(data.focusableElements)) {
      data.isMoved = true;
      swiper.allowClick = false;
      return;
    }
  }
  if (data.allowTouchCallbacks) {
    swiper.emit("touchMove", e);
  }
  touches.previousX = touches.currentX;
  touches.previousY = touches.currentY;
  touches.currentX = pageX;
  touches.currentY = pageY;
  const diffX = touches.currentX - touches.startX;
  const diffY = touches.currentY - touches.startY;
  if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
  if (typeof data.isScrolling === "undefined") {
    let touchAngle;
    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
      data.isScrolling = false;
    } else {
      if (diffX * diffX + diffY * diffY >= 25) {
        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
      }
    }
  }
  if (data.isScrolling) {
    swiper.emit("touchMoveOpposite", e);
  }
  if (typeof data.startMoving === "undefined") {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data.startMoving = true;
    }
  }
  if (data.isScrolling || e.type === "touchmove" && data.preventTouchMoveFromPointerMove) {
    data.isTouched = false;
    return;
  }
  if (!data.startMoving) {
    return;
  }
  swiper.allowClick = false;
  if (!params.cssMode && e.cancelable) {
    e.preventDefault();
  }
  if (params.touchMoveStopPropagation && !params.nested) {
    e.stopPropagation();
  }
  let diff = swiper.isHorizontal() ? diffX : diffY;
  let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
  if (params.oneWayMovement) {
    diff = Math.abs(diff) * (rtl ? 1 : -1);
    touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
  }
  touches.diff = diff;
  diff *= params.touchRatio;
  if (rtl) {
    diff = -diff;
    touchesDiff = -touchesDiff;
  }
  const prevTouchesDirection = swiper.touchesDirection;
  swiper.swipeDirection = diff > 0 ? "prev" : "next";
  swiper.touchesDirection = touchesDiff > 0 ? "prev" : "next";
  const isLoop = swiper.params.loop && !params.cssMode;
  const allowLoopFix = swiper.touchesDirection === "next" && swiper.allowSlideNext || swiper.touchesDirection === "prev" && swiper.allowSlidePrev;
  if (!data.isMoved) {
    if (isLoop && allowLoopFix) {
      swiper.loopFix({
        direction: swiper.swipeDirection
      });
    }
    data.startTranslate = swiper.getTranslate();
    swiper.setTransition(0);
    if (swiper.animating) {
      const evt = new window.CustomEvent("transitionend", {
        bubbles: true,
        cancelable: true,
        detail: {
          bySwiperTouchMove: true
        }
      });
      swiper.wrapperEl.dispatchEvent(evt);
    }
    data.allowMomentumBounce = false;
    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(true);
    }
    swiper.emit("sliderFirstMove", e);
  }
  (/* @__PURE__ */ new Date()).getTime();
  if (params._loopSwapReset !== false && data.isMoved && data.allowThresholdMove && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {
    Object.assign(touches, {
      startX: pageX,
      startY: pageY,
      currentX: pageX,
      currentY: pageY,
      startTranslate: data.currentTranslate
    });
    data.loopSwapReset = true;
    data.startTranslate = data.currentTranslate;
    return;
  }
  swiper.emit("sliderMove", e);
  data.isMoved = true;
  data.currentTranslate = diff + data.startTranslate;
  let disableParentSwiper = true;
  let resistanceRatio = params.resistanceRatio;
  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }
  if (diff > 0) {
    if (isLoop && allowLoopFix && true && data.allowThresholdMove && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.slidesSizesGrid[swiper.activeIndex + 1] - (params.slidesPerView !== "auto" && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.activeIndex + 1] + swiper.params.spaceBetween : 0) - swiper.params.spaceBetween : swiper.minTranslate())) {
      swiper.loopFix({
        direction: "prev",
        setTranslate: true,
        activeSlideIndex: 0
      });
    }
    if (data.currentTranslate > swiper.minTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) {
        data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
      }
    }
  } else if (diff < 0) {
    if (isLoop && allowLoopFix && true && data.allowThresholdMove && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween + (params.slidesPerView !== "auto" && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween : 0) : swiper.maxTranslate())) {
      swiper.loopFix({
        direction: "next",
        setTranslate: true,
        activeSlideIndex: swiper.slides.length - (params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
      });
    }
    if (data.currentTranslate < swiper.maxTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) {
        data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
      }
    }
  }
  if (disableParentSwiper) {
    e.preventedByNestedSwiper = true;
  }
  if (!swiper.allowSlideNext && swiper.swipeDirection === "next" && data.currentTranslate < data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && swiper.swipeDirection === "prev" && data.currentTranslate > data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
    data.currentTranslate = data.startTranslate;
  }
  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
      if (!data.allowThresholdMove) {
        data.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data.currentTranslate = data.startTranslate;
        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data.currentTranslate = data.startTranslate;
      return;
    }
  }
  if (!params.followFinger || params.cssMode) return;
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {
    swiper.freeMode.onTouchMove();
  }
  swiper.updateProgress(data.currentTranslate);
  swiper.setTranslate(data.currentTranslate);
}
function onTouchEnd(event) {
  const swiper = this;
  const data = swiper.touchEventsData;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  let targetTouch;
  const isTouchEvent = e.type === "touchend" || e.type === "touchcancel";
  if (!isTouchEvent) {
    if (data.touchId !== null) return;
    if (e.pointerId !== data.pointerId) return;
    targetTouch = e;
  } else {
    targetTouch = [...e.changedTouches].find((t) => t.identifier === data.touchId);
    if (!targetTouch || targetTouch.identifier !== data.touchId) return;
  }
  if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(e.type)) {
    const proceed = ["pointercancel", "contextmenu"].includes(e.type) && (swiper.browser.isSafari || swiper.browser.isWebView);
    if (!proceed) {
      return;
    }
  }
  data.pointerId = null;
  data.touchId = null;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    slidesGrid,
    enabled
  } = swiper;
  if (!enabled) return;
  if (!params.simulateTouch && e.pointerType === "mouse") return;
  if (data.allowTouchCallbacks) {
    swiper.emit("touchEnd", e);
  }
  data.allowTouchCallbacks = false;
  if (!data.isTouched) {
    if (data.isMoved && params.grabCursor) {
      swiper.setGrabCursor(false);
    }
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
    swiper.setGrabCursor(false);
  }
  const touchEndTime = now();
  const timeDiff = touchEndTime - data.touchStartTime;
  if (swiper.allowClick) {
    const pathTree = e.path || e.composedPath && e.composedPath();
    swiper.updateClickedSlide(pathTree && pathTree[0] || e.target, pathTree);
    swiper.emit("tap click", e);
    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
      swiper.emit("doubleTap doubleClick", e);
    }
  }
  data.lastClickTime = now();
  nextTick(() => {
    if (!swiper.destroyed) swiper.allowClick = true;
  });
  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 && !data.loopSwapReset || data.currentTranslate === data.startTranslate && !data.loopSwapReset) {
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  data.isTouched = false;
  data.isMoved = false;
  data.startMoving = false;
  let currentPos;
  if (params.followFinger) {
    currentPos = rtl ? swiper.translate : -swiper.translate;
  } else {
    currentPos = -data.currentTranslate;
  }
  if (params.cssMode) {
    return;
  }
  if (params.freeMode && params.freeMode.enabled) {
    swiper.freeMode.onTouchEnd({
      currentPos
    });
    return;
  }
  const swipeToLast = currentPos >= -swiper.maxTranslate() && !swiper.params.loop;
  let stopIndex = 0;
  let groupSize = swiper.slidesSizesGrid[0];
  for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
    const increment2 = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (typeof slidesGrid[i + increment2] !== "undefined") {
      if (swipeToLast || currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment2]) {
        stopIndex = i;
        groupSize = slidesGrid[i + increment2] - slidesGrid[i];
      }
    } else if (swipeToLast || currentPos >= slidesGrid[i]) {
      stopIndex = i;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  }
  let rewindFirstIndex = null;
  let rewindLastIndex = null;
  if (params.rewind) {
    if (swiper.isBeginning) {
      rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
    } else if (swiper.isEnd) {
      rewindFirstIndex = 0;
    }
  }
  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
  if (timeDiff > params.longSwipesMs) {
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (swiper.swipeDirection === "next") {
      if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);
      else swiper.slideTo(stopIndex);
    }
    if (swiper.swipeDirection === "prev") {
      if (ratio > 1 - params.longSwipesRatio) {
        swiper.slideTo(stopIndex + increment);
      } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
        swiper.slideTo(rewindLastIndex);
      } else {
        swiper.slideTo(stopIndex);
      }
    }
  } else {
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
    if (!isNavButtonTarget) {
      if (swiper.swipeDirection === "next") {
        swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
      }
      if (swiper.swipeDirection === "prev") {
        swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
      }
    } else if (e.target === swiper.navigation.nextEl) {
      swiper.slideTo(stopIndex + increment);
    } else {
      swiper.slideTo(stopIndex);
    }
  }
}
function onResize() {
  const swiper = this;
  const {
    params,
    el
  } = swiper;
  if (el && el.offsetWidth === 0) return;
  if (params.breakpoints) {
    swiper.setBreakpoint();
  }
  const {
    allowSlideNext,
    allowSlidePrev,
    snapGrid
  } = swiper;
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
  swiper.allowSlideNext = true;
  swiper.allowSlidePrev = true;
  swiper.updateSize();
  swiper.updateSlides();
  swiper.updateSlidesClasses();
  const isVirtualLoop = isVirtual && params.loop;
  if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {
    swiper.slideTo(swiper.slides.length - 1, 0, false, true);
  } else {
    if (swiper.params.loop && !isVirtual) {
      swiper.slideToLoop(swiper.realIndex, 0, false, true);
    } else {
      swiper.slideTo(swiper.activeIndex, 0, false, true);
    }
  }
  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
    clearTimeout(swiper.autoplay.resizeTimeout);
    swiper.autoplay.resizeTimeout = setTimeout(() => {
      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
        swiper.autoplay.resume();
      }
    }, 500);
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
    swiper.checkOverflow();
  }
}
function onClick(e) {
  const swiper = this;
  if (!swiper.enabled) return;
  if (!swiper.allowClick) {
    if (swiper.params.preventClicks) e.preventDefault();
    if (swiper.params.preventClicksPropagation && swiper.animating) {
      e.stopPropagation();
      e.stopImmediatePropagation();
    }
  }
}
function onScroll() {
  const swiper = this;
  const {
    wrapperEl,
    rtlTranslate,
    enabled
  } = swiper;
  if (!enabled) return;
  swiper.previousTranslate = swiper.translate;
  if (swiper.isHorizontal()) {
    swiper.translate = -wrapperEl.scrollLeft;
  } else {
    swiper.translate = -wrapperEl.scrollTop;
  }
  if (swiper.translate === 0) swiper.translate = 0;
  swiper.updateActiveIndex();
  swiper.updateSlidesClasses();
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== swiper.progress) {
    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
  }
  swiper.emit("setTranslate", swiper.translate, false);
}
function onLoad(e) {
  const swiper = this;
  processLazyPreloader(swiper, e.target);
  if (swiper.params.cssMode || swiper.params.slidesPerView !== "auto" && !swiper.params.autoHeight) {
    return;
  }
  swiper.update();
}
function onDocumentTouchStart() {
  const swiper = this;
  if (swiper.documentTouchHandlerProceeded) return;
  swiper.documentTouchHandlerProceeded = true;
  if (swiper.params.touchReleaseOnEdges) {
    swiper.el.style.touchAction = "auto";
  }
}
const events = (swiper, method) => {
  const document2 = getDocument();
  const {
    params,
    el,
    wrapperEl,
    device
  } = swiper;
  const capture = !!params.nested;
  const domMethod = method === "on" ? "addEventListener" : "removeEventListener";
  const swiperMethod = method;
  if (!el || typeof el === "string") return;
  document2[domMethod]("touchstart", swiper.onDocumentTouchStart, {
    passive: false,
    capture
  });
  el[domMethod]("touchstart", swiper.onTouchStart, {
    passive: false
  });
  el[domMethod]("pointerdown", swiper.onTouchStart, {
    passive: false
  });
  document2[domMethod]("touchmove", swiper.onTouchMove, {
    passive: false,
    capture
  });
  document2[domMethod]("pointermove", swiper.onTouchMove, {
    passive: false,
    capture
  });
  document2[domMethod]("touchend", swiper.onTouchEnd, {
    passive: true
  });
  document2[domMethod]("pointerup", swiper.onTouchEnd, {
    passive: true
  });
  document2[domMethod]("pointercancel", swiper.onTouchEnd, {
    passive: true
  });
  document2[domMethod]("touchcancel", swiper.onTouchEnd, {
    passive: true
  });
  document2[domMethod]("pointerout", swiper.onTouchEnd, {
    passive: true
  });
  document2[domMethod]("pointerleave", swiper.onTouchEnd, {
    passive: true
  });
  document2[domMethod]("contextmenu", swiper.onTouchEnd, {
    passive: true
  });
  if (params.preventClicks || params.preventClicksPropagation) {
    el[domMethod]("click", swiper.onClick, true);
  }
  if (params.cssMode) {
    wrapperEl[domMethod]("scroll", swiper.onScroll);
  }
  if (params.updateOnWindowResize) {
    swiper[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true);
  } else {
    swiper[swiperMethod]("observerUpdate", onResize, true);
  }
  el[domMethod]("load", swiper.onLoad, {
    capture: true
  });
};
function attachEvents() {
  const swiper = this;
  const {
    params
  } = swiper;
  swiper.onTouchStart = onTouchStart.bind(swiper);
  swiper.onTouchMove = onTouchMove.bind(swiper);
  swiper.onTouchEnd = onTouchEnd.bind(swiper);
  swiper.onDocumentTouchStart = onDocumentTouchStart.bind(swiper);
  if (params.cssMode) {
    swiper.onScroll = onScroll.bind(swiper);
  }
  swiper.onClick = onClick.bind(swiper);
  swiper.onLoad = onLoad.bind(swiper);
  events(swiper, "on");
}
function detachEvents() {
  const swiper = this;
  events(swiper, "off");
}
var events$1 = {
  attachEvents,
  detachEvents
};
const isGridEnabled = (swiper, params) => {
  return swiper.grid && params.grid && params.grid.rows > 1;
};
function setBreakpoint() {
  const swiper = this;
  const {
    realIndex,
    initialized,
    params,
    el
  } = swiper;
  const breakpoints2 = params.breakpoints;
  if (!breakpoints2 || breakpoints2 && Object.keys(breakpoints2).length === 0) return;
  const document2 = getDocument();
  const breakpointsBase = params.breakpointsBase === "window" || !params.breakpointsBase ? params.breakpointsBase : "container";
  const breakpointContainer = ["window", "container"].includes(params.breakpointsBase) || !params.breakpointsBase ? swiper.el : document2.querySelector(params.breakpointsBase);
  const breakpoint = swiper.getBreakpoint(breakpoints2, breakpointsBase, breakpointContainer);
  if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
  const breakpointOnlyParams = breakpoint in breakpoints2 ? breakpoints2[breakpoint] : void 0;
  const breakpointParams = breakpointOnlyParams || swiper.originalParams;
  const wasMultiRow = isGridEnabled(swiper, params);
  const isMultiRow = isGridEnabled(swiper, breakpointParams);
  const wasGrabCursor = swiper.params.grabCursor;
  const isGrabCursor = breakpointParams.grabCursor;
  const wasEnabled = params.enabled;
  if (wasMultiRow && !isMultiRow) {
    el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
    swiper.emitContainerClasses();
  } else if (!wasMultiRow && isMultiRow) {
    el.classList.add(`${params.containerModifierClass}grid`);
    if (breakpointParams.grid.fill && breakpointParams.grid.fill === "column" || !breakpointParams.grid.fill && params.grid.fill === "column") {
      el.classList.add(`${params.containerModifierClass}grid-column`);
    }
    swiper.emitContainerClasses();
  }
  if (wasGrabCursor && !isGrabCursor) {
    swiper.unsetGrabCursor();
  } else if (!wasGrabCursor && isGrabCursor) {
    swiper.setGrabCursor();
  }
  ["navigation", "pagination", "scrollbar"].forEach((prop) => {
    if (typeof breakpointParams[prop] === "undefined") return;
    const wasModuleEnabled = params[prop] && params[prop].enabled;
    const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
    if (wasModuleEnabled && !isModuleEnabled) {
      swiper[prop].disable();
    }
    if (!wasModuleEnabled && isModuleEnabled) {
      swiper[prop].enable();
    }
  });
  const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
  const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
  const wasLoop = params.loop;
  if (directionChanged && initialized) {
    swiper.changeDirection();
  }
  extend(swiper.params, breakpointParams);
  const isEnabled = swiper.params.enabled;
  const hasLoop = swiper.params.loop;
  Object.assign(swiper, {
    allowTouchMove: swiper.params.allowTouchMove,
    allowSlideNext: swiper.params.allowSlideNext,
    allowSlidePrev: swiper.params.allowSlidePrev
  });
  if (wasEnabled && !isEnabled) {
    swiper.disable();
  } else if (!wasEnabled && isEnabled) {
    swiper.enable();
  }
  swiper.currentBreakpoint = breakpoint;
  swiper.emit("_beforeBreakpoint", breakpointParams);
  if (initialized) {
    if (needsReLoop) {
      swiper.loopDestroy();
      swiper.loopCreate(realIndex);
      swiper.updateSlides();
    } else if (!wasLoop && hasLoop) {
      swiper.loopCreate(realIndex);
      swiper.updateSlides();
    } else if (wasLoop && !hasLoop) {
      swiper.loopDestroy();
    }
  }
  swiper.emit("breakpoint", breakpointParams);
}
function getBreakpoint(breakpoints2, base = "window", containerEl) {
  if (!breakpoints2 || base === "container" && !containerEl) return void 0;
  let breakpoint = false;
  const window2 = getWindow();
  const currentHeight = base === "window" ? window2.innerHeight : containerEl.clientHeight;
  const points = Object.keys(breakpoints2).map((point) => {
    if (typeof point === "string" && point.indexOf("@") === 0) {
      const minRatio = parseFloat(point.substr(1));
      const value2 = currentHeight * minRatio;
      return {
        value: value2,
        point
      };
    }
    return {
      value: point,
      point
    };
  });
  points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
  for (let i = 0; i < points.length; i += 1) {
    const {
      point,
      value: value2
    } = points[i];
    if (base === "window") {
      if (window2.matchMedia(`(min-width: ${value2}px)`).matches) {
        breakpoint = point;
      }
    } else if (value2 <= containerEl.clientWidth) {
      breakpoint = point;
    }
  }
  return breakpoint || "max";
}
var breakpoints = {
  setBreakpoint,
  getBreakpoint
};
function prepareClasses(entries, prefix) {
  const resultClasses = [];
  entries.forEach((item) => {
    if (typeof item === "object") {
      Object.keys(item).forEach((classNames) => {
        if (item[classNames]) {
          resultClasses.push(prefix + classNames);
        }
      });
    } else if (typeof item === "string") {
      resultClasses.push(prefix + item);
    }
  });
  return resultClasses;
}
function addClasses() {
  const swiper = this;
  const {
    classNames,
    params,
    rtl,
    el,
    device
  } = swiper;
  const suffixes = prepareClasses(["initialized", params.direction, {
    "free-mode": swiper.params.freeMode && params.freeMode.enabled
  }, {
    "autoheight": params.autoHeight
  }, {
    "rtl": rtl
  }, {
    "grid": params.grid && params.grid.rows > 1
  }, {
    "grid-column": params.grid && params.grid.rows > 1 && params.grid.fill === "column"
  }, {
    "android": device.android
  }, {
    "ios": device.ios
  }, {
    "css-mode": params.cssMode
  }, {
    "centered": params.cssMode && params.centeredSlides
  }, {
    "watch-progress": params.watchSlidesProgress
  }], params.containerModifierClass);
  classNames.push(...suffixes);
  el.classList.add(...classNames);
  swiper.emitContainerClasses();
}
function removeClasses() {
  const swiper = this;
  const {
    el,
    classNames
  } = swiper;
  if (!el || typeof el === "string") return;
  el.classList.remove(...classNames);
  swiper.emitContainerClasses();
}
var classes = {
  addClasses,
  removeClasses
};
function checkOverflow() {
  const swiper = this;
  const {
    isLocked: wasLocked,
    params
  } = swiper;
  const {
    slidesOffsetBefore
  } = params;
  if (slidesOffsetBefore) {
    const lastSlideIndex = swiper.slides.length - 1;
    const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
    swiper.isLocked = swiper.size > lastSlideRightEdge;
  } else {
    swiper.isLocked = swiper.snapGrid.length === 1;
  }
  if (params.allowSlideNext === true) {
    swiper.allowSlideNext = !swiper.isLocked;
  }
  if (params.allowSlidePrev === true) {
    swiper.allowSlidePrev = !swiper.isLocked;
  }
  if (wasLocked && wasLocked !== swiper.isLocked) {
    swiper.isEnd = false;
  }
  if (wasLocked !== swiper.isLocked) {
    swiper.emit(swiper.isLocked ? "lock" : "unlock");
  }
}
var checkOverflow$1 = {
  checkOverflow
};
var defaults = {
  init: true,
  direction: "horizontal",
  oneWayMovement: false,
  swiperElementNodeName: "SWIPER-CONTAINER",
  touchEventsTarget: "wrapper",
  initialSlide: 0,
  speed: 300,
  cssMode: false,
  updateOnWindowResize: true,
  resizeObserver: true,
  nested: false,
  createElements: false,
  eventsPrefix: "swiper",
  enabled: true,
  focusableElements: "input, select, option, textarea, button, video, label",
  // Overrides
  width: null,
  height: null,
  //
  preventInteractionOnTransition: false,
  // ssr
  userAgent: null,
  url: null,
  // To support iOS's swipe-to-go-back gesture (when being used in-app).
  edgeSwipeDetection: false,
  edgeSwipeThreshold: 20,
  // Autoheight
  autoHeight: false,
  // Set wrapper width
  setWrapperSize: false,
  // Virtual Translate
  virtualTranslate: false,
  // Effects
  effect: "slide",
  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
  // Breakpoints
  breakpoints: void 0,
  breakpointsBase: "window",
  // Slides grid
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  slidesPerGroupAuto: false,
  centeredSlides: false,
  centeredSlidesBounds: false,
  slidesOffsetBefore: 0,
  // in px
  slidesOffsetAfter: 0,
  // in px
  normalizeSlideIndex: true,
  centerInsufficientSlides: false,
  // Disable swiper and hide navigation when container not overflow
  watchOverflow: true,
  // Round length
  roundLengths: false,
  // Touches
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 5,
  touchMoveStopPropagation: false,
  touchStartPreventDefault: true,
  touchStartForcePreventDefault: false,
  touchReleaseOnEdges: false,
  // Unique Navigation Elements
  uniqueNavElements: true,
  // Resistance
  resistance: true,
  resistanceRatio: 0.85,
  // Progress
  watchSlidesProgress: false,
  // Cursor
  grabCursor: false,
  // Clicks
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,
  // loop
  loop: false,
  loopAddBlankSlides: true,
  loopAdditionalSlides: 0,
  loopPreventsSliding: true,
  // rewind
  rewind: false,
  // Swiping/no swiping
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null,
  // '.swipe-handler',
  noSwiping: true,
  noSwipingClass: "swiper-no-swiping",
  noSwipingSelector: null,
  // Passive Listeners
  passiveListeners: true,
  maxBackfaceHiddenSlides: 10,
  // NS
  containerModifierClass: "swiper-",
  // NEW
  slideClass: "swiper-slide",
  slideBlankClass: "swiper-slide-blank",
  slideActiveClass: "swiper-slide-active",
  slideVisibleClass: "swiper-slide-visible",
  slideFullyVisibleClass: "swiper-slide-fully-visible",
  slideNextClass: "swiper-slide-next",
  slidePrevClass: "swiper-slide-prev",
  wrapperClass: "swiper-wrapper",
  lazyPreloaderClass: "swiper-lazy-preloader",
  lazyPreloadPrevNext: 0,
  // Callbacks
  runCallbacksOnInit: true,
  // Internals
  _emitClasses: false
};
function moduleExtendParams(params, allModulesParams) {
  return function extendParams(obj = {}) {
    const moduleParamName = Object.keys(obj)[0];
    const moduleParams = obj[moduleParamName];
    if (typeof moduleParams !== "object" || moduleParams === null) {
      extend(allModulesParams, obj);
      return;
    }
    if (params[moduleParamName] === true) {
      params[moduleParamName] = {
        enabled: true
      };
    }
    if (moduleParamName === "navigation" && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) {
      params[moduleParamName].auto = true;
    }
    if (["pagination", "scrollbar"].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) {
      params[moduleParamName].auto = true;
    }
    if (!(moduleParamName in params && "enabled" in moduleParams)) {
      extend(allModulesParams, obj);
      return;
    }
    if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) {
      params[moduleParamName].enabled = true;
    }
    if (!params[moduleParamName]) params[moduleParamName] = {
      enabled: false
    };
    extend(allModulesParams, obj);
  };
}
const prototypes = {
  eventsEmitter,
  update,
  translate,
  transition,
  slide,
  loop,
  grabCursor,
  events: events$1,
  breakpoints,
  checkOverflow: checkOverflow$1,
  classes
};
const extendedDefaults = {};
class Swiper {
  constructor(...args) {
    let el;
    let params;
    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") {
      params = args[0];
    } else {
      [el, params] = args;
    }
    if (!params) params = {};
    params = extend({}, params);
    if (el && !params.el) params.el = el;
    const document2 = getDocument();
    if (params.el && typeof params.el === "string" && document2.querySelectorAll(params.el).length > 1) {
      const swipers = [];
      document2.querySelectorAll(params.el).forEach((containerEl) => {
        const newParams = extend({}, params, {
          el: containerEl
        });
        swipers.push(new Swiper(newParams));
      });
      return swipers;
    }
    const swiper = this;
    swiper.__swiper__ = true;
    swiper.support = getSupport();
    swiper.device = getDevice({
      userAgent: params.userAgent
    });
    swiper.browser = getBrowser();
    swiper.eventsListeners = {};
    swiper.eventsAnyListeners = [];
    swiper.modules = [...swiper.__modules__];
    if (params.modules && Array.isArray(params.modules)) {
      swiper.modules.push(...params.modules);
    }
    const allModulesParams = {};
    swiper.modules.forEach((mod) => {
      mod({
        params,
        swiper,
        extendParams: moduleExtendParams(params, allModulesParams),
        on: swiper.on.bind(swiper),
        once: swiper.once.bind(swiper),
        off: swiper.off.bind(swiper),
        emit: swiper.emit.bind(swiper)
      });
    });
    const swiperParams = extend({}, defaults, allModulesParams);
    swiper.params = extend({}, swiperParams, extendedDefaults, params);
    swiper.originalParams = extend({}, swiper.params);
    swiper.passedParams = extend({}, params);
    if (swiper.params && swiper.params.on) {
      Object.keys(swiper.params.on).forEach((eventName) => {
        swiper.on(eventName, swiper.params.on[eventName]);
      });
    }
    if (swiper.params && swiper.params.onAny) {
      swiper.onAny(swiper.params.onAny);
    }
    Object.assign(swiper, {
      enabled: swiper.params.enabled,
      el,
      // Classes
      classNames: [],
      // Slides
      slides: [],
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],
      // isDirection
      isHorizontal() {
        return swiper.params.direction === "horizontal";
      },
      isVertical() {
        return swiper.params.direction === "vertical";
      },
      // Indexes
      activeIndex: 0,
      realIndex: 0,
      //
      isBeginning: true,
      isEnd: false,
      // Props
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: false,
      cssOverflowAdjustment() {
        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
      },
      // Locks
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,
      // Touch Events
      touchEventsData: {
        isTouched: void 0,
        isMoved: void 0,
        allowTouchCallbacks: void 0,
        touchStartTime: void 0,
        isScrolling: void 0,
        currentTranslate: void 0,
        startTranslate: void 0,
        allowThresholdMove: void 0,
        // Form elements to match
        focusableElements: swiper.params.focusableElements,
        // Last click time
        lastClickTime: 0,
        clickTimeout: void 0,
        // Velocities
        velocities: [],
        allowMomentumBounce: void 0,
        startMoving: void 0,
        pointerId: null,
        touchId: null
      },
      // Clicks
      allowClick: true,
      // Touches
      allowTouchMove: swiper.params.allowTouchMove,
      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0
      },
      // Images
      imagesToLoad: [],
      imagesLoaded: 0
    });
    swiper.emit("_swiper");
    if (swiper.params.init) {
      swiper.init();
    }
    return swiper;
  }
  getDirectionLabel(property2) {
    if (this.isHorizontal()) {
      return property2;
    }
    return {
      "width": "height",
      "margin-top": "margin-left",
      "margin-bottom ": "margin-right",
      "margin-left": "margin-top",
      "margin-right": "margin-bottom",
      "padding-left": "padding-top",
      "padding-right": "padding-bottom",
      "marginRight": "marginBottom"
    }[property2];
  }
  getSlideIndex(slideEl) {
    const {
      slidesEl,
      params
    } = this;
    const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
    const firstSlideIndex = elementIndex(slides[0]);
    return elementIndex(slideEl) - firstSlideIndex;
  }
  getSlideIndexByData(index) {
    return this.getSlideIndex(this.slides.find((slideEl) => slideEl.getAttribute("data-swiper-slide-index") * 1 === index));
  }
  getSlideIndexWhenGrid(index) {
    if (this.grid && this.params.grid && this.params.grid.rows > 1) {
      if (this.params.grid.fill === "column") {
        index = Math.floor(index / this.params.grid.rows);
      } else if (this.params.grid.fill === "row") {
        index = index % Math.ceil(this.slides.length / this.params.grid.rows);
      }
    }
    return index;
  }
  recalcSlides() {
    const swiper = this;
    const {
      slidesEl,
      params
    } = swiper;
    swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
  }
  enable() {
    const swiper = this;
    if (swiper.enabled) return;
    swiper.enabled = true;
    if (swiper.params.grabCursor) {
      swiper.setGrabCursor();
    }
    swiper.emit("enable");
  }
  disable() {
    const swiper = this;
    if (!swiper.enabled) return;
    swiper.enabled = false;
    if (swiper.params.grabCursor) {
      swiper.unsetGrabCursor();
    }
    swiper.emit("disable");
  }
  setProgress(progress, speed) {
    const swiper = this;
    progress = Math.min(Math.max(progress, 0), 1);
    const min = swiper.minTranslate();
    const max = swiper.maxTranslate();
    const current = (max - min) * progress + min;
    swiper.translateTo(current, typeof speed === "undefined" ? 0 : speed);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  emitContainerClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el) return;
    const cls = swiper.el.className.split(" ").filter((className) => {
      return className.indexOf("swiper") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
    });
    swiper.emit("_containerClasses", cls.join(" "));
  }
  getSlideClasses(slideEl) {
    const swiper = this;
    if (swiper.destroyed) return "";
    return slideEl.className.split(" ").filter((className) => {
      return className.indexOf("swiper-slide") === 0 || className.indexOf(swiper.params.slideClass) === 0;
    }).join(" ");
  }
  emitSlidesClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el) return;
    const updates = [];
    swiper.slides.forEach((slideEl) => {
      const classNames = swiper.getSlideClasses(slideEl);
      updates.push({
        slideEl,
        classNames
      });
      swiper.emit("_slideClass", slideEl, classNames);
    });
    swiper.emit("_slideClasses", updates);
  }
  slidesPerViewDynamic(view = "current", exact = false) {
    const swiper = this;
    const {
      params,
      slides,
      slidesGrid,
      slidesSizesGrid,
      size: swiperSize,
      activeIndex
    } = swiper;
    let spv = 1;
    if (typeof params.slidesPerView === "number") return params.slidesPerView;
    if (params.centeredSlides) {
      let slideSize = slides[activeIndex] ? Math.ceil(slides[activeIndex].swiperSlideSize) : 0;
      let breakLoop;
      for (let i = activeIndex + 1; i < slides.length; i += 1) {
        if (slides[i] && !breakLoop) {
          slideSize += Math.ceil(slides[i].swiperSlideSize);
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
      for (let i = activeIndex - 1; i >= 0; i -= 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
    } else {
      if (view === "current") {
        for (let i = activeIndex + 1; i < slides.length; i += 1) {
          const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      } else {
        for (let i = activeIndex - 1; i >= 0; i -= 1) {
          const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      }
    }
    return spv;
  }
  update() {
    const swiper = this;
    if (!swiper || swiper.destroyed) return;
    const {
      snapGrid,
      params
    } = swiper;
    if (params.breakpoints) {
      swiper.setBreakpoint();
    }
    [...swiper.el.querySelectorAll('[loading="lazy"]')].forEach((imageEl) => {
      if (imageEl.complete) {
        processLazyPreloader(swiper, imageEl);
      }
    });
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateProgress();
    swiper.updateSlidesClasses();
    function setTranslate2() {
      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
      swiper.setTranslate(newTranslate);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    let translated;
    if (params.freeMode && params.freeMode.enabled && !params.cssMode) {
      setTranslate2();
      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }
    } else {
      if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {
        const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;
        translated = swiper.slideTo(slides.length - 1, 0, false, true);
      } else {
        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
      if (!translated) {
        setTranslate2();
      }
    }
    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
    swiper.emit("update");
  }
  changeDirection(newDirection, needUpdate = true) {
    const swiper = this;
    const currentDirection = swiper.params.direction;
    if (!newDirection) {
      newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
    }
    if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") {
      return swiper;
    }
    swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);
    swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);
    swiper.emitContainerClasses();
    swiper.params.direction = newDirection;
    swiper.slides.forEach((slideEl) => {
      if (newDirection === "vertical") {
        slideEl.style.width = "";
      } else {
        slideEl.style.height = "";
      }
    });
    swiper.emit("changeDirection");
    if (needUpdate) swiper.update();
    return swiper;
  }
  changeLanguageDirection(direction) {
    const swiper = this;
    if (swiper.rtl && direction === "rtl" || !swiper.rtl && direction === "ltr") return;
    swiper.rtl = direction === "rtl";
    swiper.rtlTranslate = swiper.params.direction === "horizontal" && swiper.rtl;
    if (swiper.rtl) {
      swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);
      swiper.el.dir = "rtl";
    } else {
      swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);
      swiper.el.dir = "ltr";
    }
    swiper.update();
  }
  mount(element) {
    const swiper = this;
    if (swiper.mounted) return true;
    let el = element || swiper.params.el;
    if (typeof el === "string") {
      el = document.querySelector(el);
    }
    if (!el) {
      return false;
    }
    el.swiper = swiper;
    if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === swiper.params.swiperElementNodeName.toUpperCase()) {
      swiper.isElement = true;
    }
    const getWrapperSelector = () => {
      return `.${(swiper.params.wrapperClass || "").trim().split(" ").join(".")}`;
    };
    const getWrapper = () => {
      if (el && el.shadowRoot && el.shadowRoot.querySelector) {
        const res = el.shadowRoot.querySelector(getWrapperSelector());
        return res;
      }
      return elementChildren(el, getWrapperSelector())[0];
    };
    let wrapperEl = getWrapper();
    if (!wrapperEl && swiper.params.createElements) {
      wrapperEl = createElement("div", swiper.params.wrapperClass);
      el.append(wrapperEl);
      elementChildren(el, `.${swiper.params.slideClass}`).forEach((slideEl) => {
        wrapperEl.append(slideEl);
      });
    }
    Object.assign(swiper, {
      el,
      wrapperEl,
      slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,
      hostEl: swiper.isElement ? el.parentNode.host : el,
      mounted: true,
      // RTL
      rtl: el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl",
      rtlTranslate: swiper.params.direction === "horizontal" && (el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl"),
      wrongRTL: elementStyle(wrapperEl, "display") === "-webkit-box"
    });
    return true;
  }
  init(el) {
    const swiper = this;
    if (swiper.initialized) return swiper;
    const mounted = swiper.mount(el);
    if (mounted === false) return swiper;
    swiper.emit("beforeInit");
    if (swiper.params.breakpoints) {
      swiper.setBreakpoint();
    }
    swiper.addClasses();
    swiper.updateSize();
    swiper.updateSlides();
    if (swiper.params.watchOverflow) {
      swiper.checkOverflow();
    }
    if (swiper.params.grabCursor && swiper.enabled) {
      swiper.setGrabCursor();
    }
    if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
      swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);
    } else {
      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
    }
    if (swiper.params.loop) {
      swiper.loopCreate(void 0, true);
    }
    swiper.attachEvents();
    const lazyElements = [...swiper.el.querySelectorAll('[loading="lazy"]')];
    if (swiper.isElement) {
      lazyElements.push(...swiper.hostEl.querySelectorAll('[loading="lazy"]'));
    }
    lazyElements.forEach((imageEl) => {
      if (imageEl.complete) {
        processLazyPreloader(swiper, imageEl);
      } else {
        imageEl.addEventListener("load", (e) => {
          processLazyPreloader(swiper, e.target);
        });
      }
    });
    preload(swiper);
    swiper.initialized = true;
    preload(swiper);
    swiper.emit("init");
    swiper.emit("afterInit");
    return swiper;
  }
  destroy(deleteInstance = true, cleanStyles = true) {
    const swiper = this;
    const {
      params,
      el,
      wrapperEl,
      slides
    } = swiper;
    if (typeof swiper.params === "undefined" || swiper.destroyed) {
      return null;
    }
    swiper.emit("beforeDestroy");
    swiper.initialized = false;
    swiper.detachEvents();
    if (params.loop) {
      swiper.loopDestroy();
    }
    if (cleanStyles) {
      swiper.removeClasses();
      if (el && typeof el !== "string") {
        el.removeAttribute("style");
      }
      if (wrapperEl) {
        wrapperEl.removeAttribute("style");
      }
      if (slides && slides.length) {
        slides.forEach((slideEl) => {
          slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
          slideEl.removeAttribute("style");
          slideEl.removeAttribute("data-swiper-slide-index");
        });
      }
    }
    swiper.emit("destroy");
    Object.keys(swiper.eventsListeners).forEach((eventName) => {
      swiper.off(eventName);
    });
    if (deleteInstance !== false) {
      if (swiper.el && typeof swiper.el !== "string") {
        swiper.el.swiper = null;
      }
      deleteProps(swiper);
    }
    swiper.destroyed = true;
    return null;
  }
  static extendDefaults(newDefaults) {
    extend(extendedDefaults, newDefaults);
  }
  static get extendedDefaults() {
    return extendedDefaults;
  }
  static get defaults() {
    return defaults;
  }
  static installModule(mod) {
    if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
    const modules = Swiper.prototype.__modules__;
    if (typeof mod === "function" && modules.indexOf(mod) < 0) {
      modules.push(mod);
    }
  }
  static use(module) {
    if (Array.isArray(module)) {
      module.forEach((m) => Swiper.installModule(m));
      return Swiper;
    }
    Swiper.installModule(module);
    return Swiper;
  }
}
Object.keys(prototypes).forEach((prototypeGroup) => {
  Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
    Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
  });
});
Swiper.use([Resize, Observer]);
function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
  if (swiper.params.createElements) {
    Object.keys(checkProps).forEach((key) => {
      if (!params[key] && params.auto === true) {
        let element = elementChildren(swiper.el, `.${checkProps[key]}`)[0];
        if (!element) {
          element = createElement("div", checkProps[key]);
          element.className = checkProps[key];
          swiper.el.append(element);
        }
        params[key] = element;
        originalParams[key] = element;
      }
    });
  }
  return params;
}
const arrowSvg = `<svg class="swiper-navigation-icon" width="11" height="20" viewBox="0 0 11 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0.38296 20.0762C0.111788 19.805 0.111788 19.3654 0.38296 19.0942L9.19758 10.2796L0.38296 1.46497C0.111788 1.19379 0.111788 0.754138 0.38296 0.482966C0.654131 0.211794 1.09379 0.211794 1.36496 0.482966L10.4341 9.55214C10.8359 9.9539 10.8359 10.6053 10.4341 11.007L1.36496 20.0762C1.09379 20.3474 0.654131 20.3474 0.38296 20.0762Z" fill="currentColor"/></svg>`;
function Navigation({
  swiper,
  extendParams,
  on,
  emit
}) {
  extendParams({
    navigation: {
      nextEl: null,
      prevEl: null,
      addIcons: true,
      hideOnClick: false,
      disabledClass: "swiper-button-disabled",
      hiddenClass: "swiper-button-hidden",
      lockClass: "swiper-button-lock",
      navigationDisabledClass: "swiper-navigation-disabled"
    }
  });
  swiper.navigation = {
    nextEl: null,
    prevEl: null
  };
  function getEl(el) {
    let res;
    if (el && typeof el === "string" && swiper.isElement) {
      res = swiper.el.querySelector(el) || swiper.hostEl.querySelector(el);
      if (res) return res;
    }
    if (el) {
      if (typeof el === "string") res = [...document.querySelectorAll(el)];
      if (swiper.params.uniqueNavElements && typeof el === "string" && res && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) {
        res = swiper.el.querySelector(el);
      } else if (res && res.length === 1) {
        res = res[0];
      }
    }
    if (el && !res) return el;
    return res;
  }
  function toggleEl(el, disabled) {
    const params = swiper.params.navigation;
    el = makeElementsArray(el);
    el.forEach((subEl) => {
      if (subEl) {
        subEl.classList[disabled ? "add" : "remove"](...params.disabledClass.split(" "));
        if (subEl.tagName === "BUTTON") subEl.disabled = disabled;
        if (swiper.params.watchOverflow && swiper.enabled) {
          subEl.classList[swiper.isLocked ? "add" : "remove"](params.lockClass);
        }
      }
    });
  }
  function update2() {
    const {
      nextEl,
      prevEl
    } = swiper.navigation;
    if (swiper.params.loop) {
      toggleEl(prevEl, false);
      toggleEl(nextEl, false);
      return;
    }
    toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);
    toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);
  }
  function onPrevClick(e) {
    e.preventDefault();
    if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
    swiper.slidePrev();
    emit("navigationPrev");
  }
  function onNextClick(e) {
    e.preventDefault();
    if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
    swiper.slideNext();
    emit("navigationNext");
  }
  function init() {
    const params = swiper.params.navigation;
    swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
      nextEl: "swiper-button-next",
      prevEl: "swiper-button-prev"
    });
    if (!(params.nextEl || params.prevEl)) return;
    let nextEl = getEl(params.nextEl);
    let prevEl = getEl(params.prevEl);
    Object.assign(swiper.navigation, {
      nextEl,
      prevEl
    });
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    const initButton = (el, dir) => {
      if (el) {
        if (params.addIcons && el.matches(".swiper-button-next,.swiper-button-prev") && !el.querySelector("svg")) {
          const tempEl = document.createElement("div");
          setInnerHTML(tempEl, arrowSvg);
          el.appendChild(tempEl.querySelector("svg"));
          tempEl.remove();
        }
        el.addEventListener("click", dir === "next" ? onNextClick : onPrevClick);
      }
      if (!swiper.enabled && el) {
        el.classList.add(...params.lockClass.split(" "));
      }
    };
    nextEl.forEach((el) => initButton(el, "next"));
    prevEl.forEach((el) => initButton(el, "prev"));
  }
  function destroy() {
    let {
      nextEl,
      prevEl
    } = swiper.navigation;
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    const destroyButton = (el, dir) => {
      el.removeEventListener("click", dir === "next" ? onNextClick : onPrevClick);
      el.classList.remove(...swiper.params.navigation.disabledClass.split(" "));
    };
    nextEl.forEach((el) => destroyButton(el, "next"));
    prevEl.forEach((el) => destroyButton(el, "prev"));
  }
  on("init", () => {
    if (swiper.params.navigation.enabled === false) {
      disable();
    } else {
      init();
      update2();
    }
  });
  on("toEdge fromEdge lock unlock", () => {
    update2();
  });
  on("destroy", () => {
    destroy();
  });
  on("enable disable", () => {
    let {
      nextEl,
      prevEl
    } = swiper.navigation;
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    if (swiper.enabled) {
      update2();
      return;
    }
    [...nextEl, ...prevEl].filter((el) => !!el).forEach((el) => el.classList.add(swiper.params.navigation.lockClass));
  });
  on("click", (_s, e) => {
    let {
      nextEl,
      prevEl
    } = swiper.navigation;
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    const targetEl = e.target;
    let targetIsButton = prevEl.includes(targetEl) || nextEl.includes(targetEl);
    if (swiper.isElement && !targetIsButton) {
      const path = e.path || e.composedPath && e.composedPath();
      if (path) {
        targetIsButton = path.find((pathEl) => nextEl.includes(pathEl) || prevEl.includes(pathEl));
      }
    }
    if (swiper.params.navigation.hideOnClick && !targetIsButton) {
      if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
      let isHidden;
      if (nextEl.length) {
        isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);
      } else if (prevEl.length) {
        isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);
      }
      if (isHidden === true) {
        emit("navigationShow");
      } else {
        emit("navigationHide");
      }
      [...nextEl, ...prevEl].filter((el) => !!el).forEach((el) => el.classList.toggle(swiper.params.navigation.hiddenClass));
    }
  });
  const enable = () => {
    swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(" "));
    init();
    update2();
  };
  const disable = () => {
    swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(" "));
    destroy();
  };
  Object.assign(swiper.navigation, {
    enable,
    disable,
    update: update2,
    init,
    destroy
  });
}
function classesToSelector(classes2 = "") {
  return `.${classes2.trim().replace(/([\.:!+\/()[\]])/g, "\\$1").replace(/ /g, ".")}`;
}
function Pagination({
  swiper,
  extendParams,
  on,
  emit
}) {
  const pfx = "swiper-pagination";
  extendParams({
    pagination: {
      el: null,
      bulletElement: "span",
      clickable: false,
      hideOnClick: false,
      renderBullet: null,
      renderProgressbar: null,
      renderFraction: null,
      renderCustom: null,
      progressbarOpposite: false,
      type: "bullets",
      // 'bullets' or 'progressbar' or 'fraction' or 'custom'
      dynamicBullets: false,
      dynamicMainBullets: 1,
      formatFractionCurrent: (number2) => number2,
      formatFractionTotal: (number2) => number2,
      bulletClass: `${pfx}-bullet`,
      bulletActiveClass: `${pfx}-bullet-active`,
      modifierClass: `${pfx}-`,
      currentClass: `${pfx}-current`,
      totalClass: `${pfx}-total`,
      hiddenClass: `${pfx}-hidden`,
      progressbarFillClass: `${pfx}-progressbar-fill`,
      progressbarOppositeClass: `${pfx}-progressbar-opposite`,
      clickableClass: `${pfx}-clickable`,
      lockClass: `${pfx}-lock`,
      horizontalClass: `${pfx}-horizontal`,
      verticalClass: `${pfx}-vertical`,
      paginationDisabledClass: `${pfx}-disabled`
    }
  });
  swiper.pagination = {
    el: null,
    bullets: []
  };
  let bulletSize;
  let dynamicBulletIndex = 0;
  function isPaginationDisabled() {
    return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;
  }
  function setSideBullets(bulletEl, position) {
    const {
      bulletActiveClass
    } = swiper.params.pagination;
    if (!bulletEl) return;
    bulletEl = bulletEl[`${position === "prev" ? "previous" : "next"}ElementSibling`];
    if (bulletEl) {
      bulletEl.classList.add(`${bulletActiveClass}-${position}`);
      bulletEl = bulletEl[`${position === "prev" ? "previous" : "next"}ElementSibling`];
      if (bulletEl) {
        bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);
      }
    }
  }
  function getMoveDirection(prevIndex, nextIndex, length2) {
    prevIndex = prevIndex % length2;
    nextIndex = nextIndex % length2;
    if (nextIndex === prevIndex + 1) {
      return "next";
    } else if (nextIndex === prevIndex - 1) {
      return "previous";
    }
    return;
  }
  function onBulletClick(e) {
    const bulletEl = e.target.closest(classesToSelector(swiper.params.pagination.bulletClass));
    if (!bulletEl) {
      return;
    }
    e.preventDefault();
    const index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;
    if (swiper.params.loop) {
      if (swiper.realIndex === index) return;
      const moveDirection = getMoveDirection(swiper.realIndex, index, swiper.slides.length);
      if (moveDirection === "next") {
        swiper.slideNext();
      } else if (moveDirection === "previous") {
        swiper.slidePrev();
      } else {
        swiper.slideToLoop(index);
      }
    } else {
      swiper.slideTo(index);
    }
  }
  function update2() {
    const rtl = swiper.rtl;
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    let el = swiper.pagination.el;
    el = makeElementsArray(el);
    let current;
    let previousIndex;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
    if (swiper.params.loop) {
      previousIndex = swiper.previousRealIndex || 0;
      current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;
    } else if (typeof swiper.snapIndex !== "undefined") {
      current = swiper.snapIndex;
      previousIndex = swiper.previousSnapIndex;
    } else {
      previousIndex = swiper.previousIndex || 0;
      current = swiper.activeIndex || 0;
    }
    if (params.type === "bullets" && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
      const bullets = swiper.pagination.bullets;
      let firstIndex;
      let lastIndex;
      let midIndex;
      if (params.dynamicBullets) {
        bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? "width" : "height");
        el.forEach((subEl) => {
          subEl.style[swiper.isHorizontal() ? "width" : "height"] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;
        });
        if (params.dynamicMainBullets > 1 && previousIndex !== void 0) {
          dynamicBulletIndex += current - (previousIndex || 0);
          if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
            dynamicBulletIndex = params.dynamicMainBullets - 1;
          } else if (dynamicBulletIndex < 0) {
            dynamicBulletIndex = 0;
          }
        }
        firstIndex = Math.max(current - dynamicBulletIndex, 0);
        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
        midIndex = (lastIndex + firstIndex) / 2;
      }
      bullets.forEach((bulletEl) => {
        const classesToRemove = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((suffix) => `${params.bulletActiveClass}${suffix}`)].map((s) => typeof s === "string" && s.includes(" ") ? s.split(" ") : s).flat();
        bulletEl.classList.remove(...classesToRemove);
      });
      if (el.length > 1) {
        bullets.forEach((bullet) => {
          const bulletIndex = elementIndex(bullet);
          if (bulletIndex === current) {
            bullet.classList.add(...params.bulletActiveClass.split(" "));
          } else if (swiper.isElement) {
            bullet.setAttribute("part", "bullet");
          }
          if (params.dynamicBullets) {
            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
              bullet.classList.add(...`${params.bulletActiveClass}-main`.split(" "));
            }
            if (bulletIndex === firstIndex) {
              setSideBullets(bullet, "prev");
            }
            if (bulletIndex === lastIndex) {
              setSideBullets(bullet, "next");
            }
          }
        });
      } else {
        const bullet = bullets[current];
        if (bullet) {
          bullet.classList.add(...params.bulletActiveClass.split(" "));
        }
        if (swiper.isElement) {
          bullets.forEach((bulletEl, bulletIndex) => {
            bulletEl.setAttribute("part", bulletIndex === current ? "bullet-active" : "bullet");
          });
        }
        if (params.dynamicBullets) {
          const firstDisplayedBullet = bullets[firstIndex];
          const lastDisplayedBullet = bullets[lastIndex];
          for (let i = firstIndex; i <= lastIndex; i += 1) {
            if (bullets[i]) {
              bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(" "));
            }
          }
          setSideBullets(firstDisplayedBullet, "prev");
          setSideBullets(lastDisplayedBullet, "next");
        }
      }
      if (params.dynamicBullets) {
        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
        const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
        const offsetProp = rtl ? "right" : "left";
        bullets.forEach((bullet) => {
          bullet.style[swiper.isHorizontal() ? offsetProp : "top"] = `${bulletsOffset}px`;
        });
      }
    }
    el.forEach((subEl, subElIndex) => {
      if (params.type === "fraction") {
        subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach((fractionEl) => {
          fractionEl.textContent = params.formatFractionCurrent(current + 1);
        });
        subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach((totalEl) => {
          totalEl.textContent = params.formatFractionTotal(total);
        });
      }
      if (params.type === "progressbar") {
        let progressbarDirection;
        if (params.progressbarOpposite) {
          progressbarDirection = swiper.isHorizontal() ? "vertical" : "horizontal";
        } else {
          progressbarDirection = swiper.isHorizontal() ? "horizontal" : "vertical";
        }
        const scale = (current + 1) / total;
        let scaleX = 1;
        let scaleY = 1;
        if (progressbarDirection === "horizontal") {
          scaleX = scale;
        } else {
          scaleY = scale;
        }
        subEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach((progressEl) => {
          progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;
          progressEl.style.transitionDuration = `${swiper.params.speed}ms`;
        });
      }
      if (params.type === "custom" && params.renderCustom) {
        setInnerHTML(subEl, params.renderCustom(swiper, current + 1, total));
        if (subElIndex === 0) emit("paginationRender", subEl);
      } else {
        if (subElIndex === 0) emit("paginationRender", subEl);
        emit("paginationUpdate", subEl);
      }
      if (swiper.params.watchOverflow && swiper.enabled) {
        subEl.classList[swiper.isLocked ? "add" : "remove"](params.lockClass);
      }
    });
  }
  function render2() {
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.grid && swiper.params.grid.rows > 1 ? swiper.slides.length / Math.ceil(swiper.params.grid.rows) : swiper.slides.length;
    let el = swiper.pagination.el;
    el = makeElementsArray(el);
    let paginationHTML = "";
    if (params.type === "bullets") {
      let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
      if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) {
        numberOfBullets = slidesLength;
      }
      for (let i = 0; i < numberOfBullets; i += 1) {
        if (params.renderBullet) {
          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
        } else {
          paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part="bullet"' : ""} class="${params.bulletClass}"></${params.bulletElement}>`;
        }
      }
    }
    if (params.type === "fraction") {
      if (params.renderFraction) {
        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
      } else {
        paginationHTML = `<span class="${params.currentClass}"></span> / <span class="${params.totalClass}"></span>`;
      }
    }
    if (params.type === "progressbar") {
      if (params.renderProgressbar) {
        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
      } else {
        paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
      }
    }
    swiper.pagination.bullets = [];
    el.forEach((subEl) => {
      if (params.type !== "custom") {
        setInnerHTML(subEl, paginationHTML || "");
      }
      if (params.type === "bullets") {
        swiper.pagination.bullets.push(...subEl.querySelectorAll(classesToSelector(params.bulletClass)));
      }
    });
    if (params.type !== "custom") {
      emit("paginationRender", el[0]);
    }
  }
  function init() {
    swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
      el: "swiper-pagination"
    });
    const params = swiper.params.pagination;
    if (!params.el) return;
    let el;
    if (typeof params.el === "string" && swiper.isElement) {
      el = swiper.el.querySelector(params.el);
    }
    if (!el && typeof params.el === "string") {
      el = [...document.querySelectorAll(params.el)];
    }
    if (!el) {
      el = params.el;
    }
    if (!el || el.length === 0) return;
    if (swiper.params.uniqueNavElements && typeof params.el === "string" && Array.isArray(el) && el.length > 1) {
      el = [...swiper.el.querySelectorAll(params.el)];
      if (el.length > 1) {
        el = el.find((subEl) => {
          if (elementParents(subEl, ".swiper")[0] !== swiper.el) return false;
          return true;
        });
      }
    }
    if (Array.isArray(el) && el.length === 1) el = el[0];
    Object.assign(swiper.pagination, {
      el
    });
    el = makeElementsArray(el);
    el.forEach((subEl) => {
      if (params.type === "bullets" && params.clickable) {
        subEl.classList.add(...(params.clickableClass || "").split(" "));
      }
      subEl.classList.add(params.modifierClass + params.type);
      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
      if (params.type === "bullets" && params.dynamicBullets) {
        subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);
        dynamicBulletIndex = 0;
        if (params.dynamicMainBullets < 1) {
          params.dynamicMainBullets = 1;
        }
      }
      if (params.type === "progressbar" && params.progressbarOpposite) {
        subEl.classList.add(params.progressbarOppositeClass);
      }
      if (params.clickable) {
        subEl.addEventListener("click", onBulletClick);
      }
      if (!swiper.enabled) {
        subEl.classList.add(params.lockClass);
      }
    });
  }
  function destroy() {
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    let el = swiper.pagination.el;
    if (el) {
      el = makeElementsArray(el);
      el.forEach((subEl) => {
        subEl.classList.remove(params.hiddenClass);
        subEl.classList.remove(params.modifierClass + params.type);
        subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
        if (params.clickable) {
          subEl.classList.remove(...(params.clickableClass || "").split(" "));
          subEl.removeEventListener("click", onBulletClick);
        }
      });
    }
    if (swiper.pagination.bullets) swiper.pagination.bullets.forEach((subEl) => subEl.classList.remove(...params.bulletActiveClass.split(" ")));
  }
  on("changeDirection", () => {
    if (!swiper.pagination || !swiper.pagination.el) return;
    const params = swiper.params.pagination;
    let {
      el
    } = swiper.pagination;
    el = makeElementsArray(el);
    el.forEach((subEl) => {
      subEl.classList.remove(params.horizontalClass, params.verticalClass);
      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
    });
  });
  on("init", () => {
    if (swiper.params.pagination.enabled === false) {
      disable();
    } else {
      init();
      render2();
      update2();
    }
  });
  on("activeIndexChange", () => {
    if (typeof swiper.snapIndex === "undefined") {
      update2();
    }
  });
  on("snapIndexChange", () => {
    update2();
  });
  on("snapGridLengthChange", () => {
    render2();
    update2();
  });
  on("destroy", () => {
    destroy();
  });
  on("enable disable", () => {
    let {
      el
    } = swiper.pagination;
    if (el) {
      el = makeElementsArray(el);
      el.forEach((subEl) => subEl.classList[swiper.enabled ? "remove" : "add"](swiper.params.pagination.lockClass));
    }
  });
  on("lock unlock", () => {
    update2();
  });
  on("click", (_s, e) => {
    const targetEl = e.target;
    const el = makeElementsArray(swiper.pagination.el);
    if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {
      if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
      const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);
      if (isHidden === true) {
        emit("paginationShow");
      } else {
        emit("paginationHide");
      }
      el.forEach((subEl) => subEl.classList.toggle(swiper.params.pagination.hiddenClass));
    }
  });
  const enable = () => {
    swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);
    let {
      el
    } = swiper.pagination;
    if (el) {
      el = makeElementsArray(el);
      el.forEach((subEl) => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));
    }
    init();
    render2();
    update2();
  };
  const disable = () => {
    swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);
    let {
      el
    } = swiper.pagination;
    if (el) {
      el = makeElementsArray(el);
      el.forEach((subEl) => subEl.classList.add(swiper.params.pagination.paginationDisabledClass));
    }
    destroy();
  };
  Object.assign(swiper.pagination, {
    enable,
    disable,
    render: render2,
    update: update2,
    init,
    destroy
  });
}
function initSliders() {
  if (document.querySelector(".swiper-category")) {
    window.categorySwiper = new Swiper(".swiper-category", {
      // <- Вказуємо склас потрібного слайдера
      // Підключаємо модулі слайдера
      // для конкретного випадку
      modules: [Navigation],
      observer: true,
      observeParents: true,
      //slidesPerView: 'auto',
      spaceBetween: 20,
      initialSlide: 1,
      centeredSlides: true,
      //centeredSlidesBounds: true,
      slideToClickedSlide: true,
      //autoHeight: true,
      speed: 600,
      loop: false,
      //touchRatio: 0,
      //simulateTouch: false,
      //loop: true,
      //preloadImages: false,
      //lazy: true,
      /*
      // Ефекти
      effect: 'fade',
      autoplay: {
      	delay: 3000,
      	disableOnInteraction: false,
      },
      */
      // Пагінація
      /*
      pagination: {
      	el: '.swiper-pagination',
      	clickable: true,
      },
      */
      // Скроллбар
      /*
      scrollbar: {
      	el: '.swiper-scrollbar',
      	draggable: true,
      },
      */
      // Кнопки "вліво/вправо"
      // navigation: {
      // 	prevEl: '.swiper-button-prev',
      // 	nextEl: '.swiper-button-next',
      // },
      // Брейкпоінти
      breakpoints: {
        320: {
          slidesPerView: 1.6,
          spaceBetween: 0
        },
        560: {
          slidesPerView: 2,
          spaceBetween: 0
        },
        768: {
          slidesPerView: 2.5,
          spaceBetween: 20
        },
        992: {
          slidesPerView: 3,
          spaceBetween: 20
        },
        1268: {
          slidesPerView: 3.7,
          spaceBetween: 30
        }
      },
      // Події
      on: {}
    });
  }
  if (document.querySelector(".blog__slider")) {
    new Swiper(".blog__slider", {
      // <- Вказуємо склас потрібного слайдера
      // Підключаємо модулі слайдера
      // для конкретного випадку
      modules: [Navigation, Pagination],
      slidesPerView: 1,
      spaceBetween: 10,
      //autoHeight: true,
      speed: 600,
      loop: true,
      //touchRatio: 0,
      //simulateTouch: false,
      //loop: true,
      //preloadImages: false,
      //lazy: true,
      /*
      // Ефекти
      effect: 'fade',
      autoplay: {
      	delay: 3000,
      	disableOnInteraction: false,
      },
      */
      // Пагінація
      pagination: {
        el: ".blog__button-pagination",
        clickable: true
      },
      // Скроллбар
      /*
      scrollbar: {
      	el: '.swiper-scrollbar',
      	draggable: true,
      },
      */
      // Кнопки "вліво/вправо"
      navigation: {
        prevEl: ".blog__button-prev",
        nextEl: ".blog__button-next"
      },
      // Брейкпоінти
      // breakpoints: {
      // 	320: {
      // 		slidesPerView: 1.6,
      // 		spaceBetween: 0,
      // 	},
      // 	560: {
      // 		slidesPerView: 2,
      // 		spaceBetween: 0,
      // 	},
      // 	768: {
      // 		slidesPerView: 2.5,
      // 		spaceBetween: 20,
      // 	},
      // 	992: {
      // 		slidesPerView: 3,
      // 		spaceBetween: 20,
      // 	},
      // 	1268: {
      // 		slidesPerView: 3.7,
      // 		spaceBetween: 30,
      // 	},
      // },
      // Події
      on: {}
    });
  }
}
document.querySelector("[data-fls-slider]") ? window.addEventListener("load", initSliders) : null;
function showMore() {
  const showMoreBlocks = document.querySelectorAll("[data-fls-showmore]");
  let showMoreBlocksRegular;
  let mdQueriesArray;
  if (showMoreBlocks.length) {
    showMoreBlocksRegular = Array.from(showMoreBlocks).filter(function(item, index, self) {
      return !item.dataset.flsShowmoreMedia;
    });
    showMoreBlocksRegular.length ? initItems(showMoreBlocksRegular) : null;
    document.addEventListener("click", showMoreActions);
    window.addEventListener("resize", showMoreActions);
    mdQueriesArray = dataMediaQueries(showMoreBlocks, "flsShowmoreMedia");
    if (mdQueriesArray && mdQueriesArray.length) {
      mdQueriesArray.forEach((mdQueriesItem) => {
        mdQueriesItem.matchMedia.addEventListener("change", function() {
          initItems(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);
        });
      });
      initItemsMedia(mdQueriesArray);
    }
  }
  function initItemsMedia(mdQueriesArray2) {
    mdQueriesArray2.forEach((mdQueriesItem) => {
      initItems(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);
    });
  }
  function initItems(showMoreBlocks2, matchMedia) {
    showMoreBlocks2.forEach((showMoreBlock) => {
      initItem(showMoreBlock, matchMedia);
    });
  }
  function initItem(showMoreBlock, matchMedia = false) {
    showMoreBlock = matchMedia ? showMoreBlock.item : showMoreBlock;
    let showMoreContent = showMoreBlock.querySelectorAll("[data-fls-showmore-content]");
    let showMoreButton = showMoreBlock.querySelectorAll("[data-fls-showmore-button]");
    showMoreContent = Array.from(showMoreContent).filter((item) => item.closest("[data-fls-showmore]") === showMoreBlock)[0];
    showMoreButton = Array.from(showMoreButton).filter((item) => item.closest("[data-fls-showmore]") === showMoreBlock)[0];
    const hiddenHeight = getHeight(showMoreBlock, showMoreContent);
    if (matchMedia.matches || !matchMedia) {
      if (hiddenHeight < getOriginalHeight(showMoreContent)) {
        slideUp(showMoreContent, 0, showMoreBlock.classList.contains("--showmore-active") ? getOriginalHeight(showMoreContent) : hiddenHeight);
        showMoreButton.hidden = false;
      } else {
        slideDown(showMoreContent, 0, hiddenHeight);
        showMoreButton.hidden = true;
      }
    } else {
      slideDown(showMoreContent, 0, hiddenHeight);
      showMoreButton.hidden = true;
    }
  }
  function getHeight(showMoreBlock, showMoreContent) {
    let hiddenHeight = 0;
    const showMoreType = showMoreBlock.dataset.flsShowmore ? showMoreBlock.dataset.flsShowmore : "size";
    const rowGap = parseFloat(getComputedStyle(showMoreContent).rowGap) ? parseFloat(getComputedStyle(showMoreContent).rowGap) : 0;
    if (showMoreType === "items") {
      const showMoreTypeValue = showMoreContent.dataset.flsShowmoreContent ? showMoreContent.dataset.flsShowmoreContent : 3;
      const showMoreItems = showMoreContent.children;
      for (let index = 1; index < showMoreItems.length; index++) {
        const showMoreItem = showMoreItems[index - 1];
        const marginTop = parseFloat(getComputedStyle(showMoreItem).marginTop) ? parseFloat(getComputedStyle(showMoreItem).marginTop) : 0;
        const marginBottom = parseFloat(getComputedStyle(showMoreItem).marginBottom) ? parseFloat(getComputedStyle(showMoreItem).marginBottom) : 0;
        hiddenHeight += showMoreItem.offsetHeight + marginTop;
        if (index == showMoreTypeValue) break;
        hiddenHeight += marginBottom;
      }
      rowGap ? hiddenHeight += (showMoreTypeValue - 1) * rowGap : null;
    } else {
      const showMoreTypeValue = showMoreContent.dataset.flsShowmoreContent ? showMoreContent.dataset.flsShowmoreContent : 150;
      hiddenHeight = showMoreTypeValue;
    }
    return hiddenHeight;
  }
  function getOriginalHeight(showMoreContent) {
    let parentHidden;
    let hiddenHeight = showMoreContent.offsetHeight;
    showMoreContent.style.removeProperty("height");
    if (showMoreContent.closest(`[hidden]`)) {
      parentHidden = showMoreContent.closest(`[hidden]`);
      parentHidden.hidden = false;
    }
    let originalHeight = showMoreContent.offsetHeight;
    parentHidden ? parentHidden.hidden = true : null;
    showMoreContent.style.height = `${hiddenHeight}px`;
    return originalHeight;
  }
  function showMoreActions(e) {
    const targetEvent = e.target;
    const targetType = e.type;
    if (targetType === "click") {
      if (targetEvent.closest("[data-fls-showmore-button]")) {
        const showMoreButton = targetEvent.closest("[data-fls-showmore-button]");
        const showMoreBlock = showMoreButton.closest("[data-fls-showmore]");
        const showMoreContent = showMoreBlock.querySelector("[data-fls-showmore-content]");
        const showMoreSpeed = showMoreBlock.dataset.flsShowmoreButton ? showMoreBlock.dataset.flsShowmoreButton : "500";
        const hiddenHeight = getHeight(showMoreBlock, showMoreContent);
        if (!showMoreContent.classList.contains("--slide")) {
          showMoreBlock.classList.contains("--showmore-active") ? slideUp(showMoreContent, showMoreSpeed, hiddenHeight) : slideDown(showMoreContent, showMoreSpeed, hiddenHeight);
          showMoreBlock.classList.toggle("--showmore-active");
        }
      }
    } else if (targetType === "resize") {
      showMoreBlocksRegular && showMoreBlocksRegular.length ? initItems(showMoreBlocksRegular) : null;
      mdQueriesArray && mdQueriesArray.length ? initItemsMedia(mdQueriesArray) : null;
    }
  }
}
window.addEventListener("load", showMore);
function menuInit() {
  document.addEventListener("click", function(e) {
    if (bodyLockStatus && e.target.closest("[data-fls-menu]")) {
      bodyLockToggle();
      document.documentElement.toggleAttribute("data-fls-menu-open");
    }
  });
}
document.querySelector("[data-fls-menu]") ? window.addEventListener("load", menuInit) : null;
function scrollAction() {
  const header = document.querySelector(".header");
  header.classList.toggle("header--scroll", scrollY > 20);
}
function navigation() {
  const lineParent = document.querySelector("[data-line-parent]");
  const lineItems = document.querySelectorAll("[data-line-item]");
  if (lineParent) {
    const line = document.createElement("div");
    line.className = "line";
    lineParent.appendChild(line);
  }
  const lineStyle = getComputedStyle(document.querySelector(".line"));
  const lineTransition = lineStyle.transition;
  function setValues(target, hide) {
    const line = target.closest("[data-line-parent]").querySelector(".line");
    if (!hide) {
      const rect = target.getBoundingClientRect();
      const parentRect = target.closest("[data-line-parent]").getBoundingClientRect();
      const center = rect.left - parentRect.left + rect.width / 2;
      const bottom = parentRect.bottom - rect.bottom - 20;
      line.style.left = `${center}px`;
      line.style.bottom = `${bottom}px`;
    } else {
      line.style.left = `0`;
    }
  }
  function mouseEnterFunc() {
    setValues(this);
  }
  function mouseLeaveFunc() {
    const activeLink2 = document.querySelector(".menu__link--active");
    if (activeLink2) {
      setValues(activeLink2);
    } else {
      setValues(this, true);
    }
  }
  function resizeFunc() {
    const activeLink2 = document.querySelector(".menu__link--active");
    if (activeLink2) {
      const line = activeLink2.closest("[data-line-parent]").querySelector(".line");
      line.style.transition = "none";
      setValues(activeLink2);
      setTimeout(() => line.style.transition = lineTransition, 1);
    }
  }
  const activeLink = document.querySelector(".menu__link--active");
  if (activeLink) {
    setValues(activeLink);
  }
  window.addEventListener("resize", resizeFunc);
  lineItems.forEach((lineItem) => {
    lineItem.addEventListener("mouseenter", mouseEnterFunc);
    lineItem.addEventListener("mouseleave", mouseLeaveFunc);
  });
}
document.querySelector("[data-line-parent]") ? window.addEventListener("load", navigation) : null;
window.addEventListener("scroll", scrollAction);
let formValidate = {
  getErrors(form) {
    let error2 = 0;
    let formRequiredItems = form.querySelectorAll("[required]");
    if (formRequiredItems.length) {
      formRequiredItems.forEach((formRequiredItem) => {
        if ((formRequiredItem.offsetParent !== null || formRequiredItem.tagName === "SELECT") && !formRequiredItem.disabled) {
          error2 += this.validateInput(formRequiredItem);
        }
      });
    }
    return error2;
  },
  validateInput(formRequiredItem) {
    let error2 = 0;
    if (formRequiredItem.type === "email") {
      formRequiredItem.value = formRequiredItem.value.replace(" ", "");
      if (this.emailTest(formRequiredItem)) {
        this.addError(formRequiredItem);
        this.removeSuccess(formRequiredItem);
        error2++;
      } else {
        this.removeError(formRequiredItem);
        this.addSuccess(formRequiredItem);
      }
    } else if (formRequiredItem.type === "checkbox" && !formRequiredItem.checked) {
      this.addError(formRequiredItem);
      this.removeSuccess(formRequiredItem);
      error2++;
    } else {
      if (!formRequiredItem.value.trim()) {
        this.addError(formRequiredItem);
        this.removeSuccess(formRequiredItem);
        error2++;
      } else {
        this.removeError(formRequiredItem);
        this.addSuccess(formRequiredItem);
      }
    }
    return error2;
  },
  addError(formRequiredItem) {
    formRequiredItem.classList.add("--form-error");
    formRequiredItem.parentElement.classList.add("--form-error");
    let inputError = formRequiredItem.parentElement.querySelector("[data-fls-form-error]");
    if (inputError) formRequiredItem.parentElement.removeChild(inputError);
    if (formRequiredItem.dataset.flsFormErrtext) {
      formRequiredItem.parentElement.insertAdjacentHTML("beforeend", `<div data-fls-form-error>${formRequiredItem.dataset.flsFormErrtext}</div>`);
    }
  },
  removeError(formRequiredItem) {
    formRequiredItem.classList.remove("--form-error");
    formRequiredItem.parentElement.classList.remove("--form-error");
    if (formRequiredItem.parentElement.querySelector("[data-fls-form-error]")) {
      formRequiredItem.parentElement.removeChild(formRequiredItem.parentElement.querySelector("[data-fls-form-error]"));
    }
  },
  addSuccess(formRequiredItem) {
    formRequiredItem.classList.add("--form-success");
    formRequiredItem.parentElement.classList.add("--form-success");
  },
  removeSuccess(formRequiredItem) {
    formRequiredItem.classList.remove("--form-success");
    formRequiredItem.parentElement.classList.remove("--form-success");
  },
  formClean(form) {
    form.reset();
    setTimeout(() => {
      let inputs = form.querySelectorAll("input,textarea");
      for (let index = 0; index < inputs.length; index++) {
        const el = inputs[index];
        el.parentElement.classList.remove("--form-focus");
        el.classList.remove("--form-focus");
        formValidate.removeError(el);
      }
      let checkboxes = form.querySelectorAll('input[type="checkbox"]');
      if (checkboxes.length) {
        checkboxes.forEach((checkbox) => {
          checkbox.checked = false;
        });
      }
      if (window["flsSelect"]) {
        let selects = form.querySelectorAll("select[data-fls-select]");
        if (selects.length) {
          selects.forEach((select) => {
            window["flsSelect"].selectBuild(select);
          });
        }
      }
    }, 0);
  },
  emailTest(formRequiredItem) {
    return !/^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,8})+$/.test(formRequiredItem.value);
  }
};
function formInit() {
  function formSubmit() {
    const forms = document.forms;
    if (forms.length) {
      for (const form of forms) {
        !form.hasAttribute("data-fls-form-novalidate") ? form.setAttribute("novalidate", true) : null;
        form.addEventListener("submit", function(e) {
          const form2 = e.target;
          formSubmitAction(form2, e);
        });
        form.addEventListener("reset", function(e) {
          const form2 = e.target;
          formValidate.formClean(form2);
        });
      }
    }
    async function formSubmitAction(form, e) {
      const error2 = formValidate.getErrors(form);
      if (error2 === 0) {
        if (form.dataset.flsForm === "ajax") {
          e.preventDefault();
          const formAction = form.getAttribute("action") ? form.getAttribute("action").trim() : "#";
          const formMethod = form.getAttribute("method") ? form.getAttribute("method").trim() : "GET";
          const formData = new FormData(form);
          form.classList.add("--sending");
          const response = await fetch(formAction, {
            method: formMethod,
            body: formData
          });
          if (response.ok) {
            let responseResult = await response.json();
            form.classList.remove("--sending");
            formSent(form, responseResult);
          } else {
            form.classList.remove("--sending");
          }
        } else if (form.dataset.flsForm === "dev") {
          e.preventDefault();
          formSent(form);
        }
      } else {
        e.preventDefault();
        if (form.querySelector(".--form-error") && form.hasAttribute("data-fls-form-gotoerr")) {
          const formGoToErrorClass = form.dataset.flsFormGotoerr ? form.dataset.flsFormGotoerr : ".--form-error";
          gotoBlock(formGoToErrorClass);
        }
      }
    }
    function formSent(form, responseResult = ``) {
      document.dispatchEvent(new CustomEvent("formSent", {
        detail: {
          form
        }
      }));
      setTimeout(() => {
        if (window.flsPopup) {
          const popup = form.dataset.flsFormPopup;
          popup ? window.flsPopup.open(popup) : null;
        }
      }, 0);
      formValidate.formClean(form);
    }
  }
  function formFieldsInit() {
    document.body.addEventListener("focusin", function(e) {
      const targetElement = e.target;
      if (targetElement.tagName === "INPUT" || targetElement.tagName === "TEXTAREA") {
        if (!targetElement.hasAttribute("data-fls-form-nofocus")) {
          targetElement.classList.add("--form-focus");
          targetElement.parentElement.classList.add("--form-focus");
        }
        targetElement.hasAttribute("data-fls-form-validatenow") ? formValidate.removeError(targetElement) : null;
      }
    });
    document.body.addEventListener("focusout", function(e) {
      const targetElement = e.target;
      if (targetElement.tagName === "INPUT" || targetElement.tagName === "TEXTAREA") {
        if (!targetElement.hasAttribute("data-fls-form-nofocus")) {
          targetElement.classList.remove("--form-focus");
          targetElement.parentElement.classList.remove("--form-focus");
        }
        targetElement.hasAttribute("data-fls-form-validatenow") ? formValidate.validateInput(targetElement) : null;
      }
    });
  }
  formSubmit();
  formFieldsInit();
}
document.querySelector("[data-fls-form]") ? window.addEventListener("load", formInit) : null;
class ScrollWatcher {
  constructor(props) {
    let defaultConfig = {
      logging: true
    };
    this.config = Object.assign(defaultConfig, props);
    this.observer;
    !document.documentElement.hasAttribute("data-fls-watch") ? this.scrollWatcherRun() : null;
  }
  // Оновлюємо конструктор
  scrollWatcherUpdate() {
    this.scrollWatcherRun();
  }
  // Запускаємо конструктор
  scrollWatcherRun() {
    document.documentElement.setAttribute("data-fls-watch", "");
    this.scrollWatcherConstructor(document.querySelectorAll("[data-fls-watcher]"));
  }
  // Конструктор спостерігачів
  scrollWatcherConstructor(items) {
    if (items.length) {
      let uniqParams = uniqArray(Array.from(items).map(function(item) {
        if (item.dataset.flsWatcher === "navigator" && !item.dataset.flsWatcherThreshold) {
          let valueOfThreshold;
          if (item.clientHeight > 2) {
            valueOfThreshold = window.innerHeight / 2 / (item.clientHeight - 1);
            if (valueOfThreshold > 1) {
              valueOfThreshold = 1;
            }
          } else {
            valueOfThreshold = 1;
          }
          item.setAttribute(
            "data-fls-watcher-threshold",
            valueOfThreshold.toFixed(2)
          );
        }
        return `${item.dataset.flsWatcherRoot ? item.dataset.flsWatcherRoot : null}|${item.dataset.flsWatcherMargin ? item.dataset.flsWatcherMargin : "0px"}|${item.dataset.flsWatcherThreshold ? item.dataset.flsWatcherThreshold : 0}`;
      }));
      uniqParams.forEach((uniqParam) => {
        let uniqParamArray = uniqParam.split("|");
        let paramsWatch = {
          root: uniqParamArray[0],
          margin: uniqParamArray[1],
          threshold: uniqParamArray[2]
        };
        let groupItems = Array.from(items).filter(function(item) {
          let watchRoot = item.dataset.flsWatcherRoot ? item.dataset.flsWatcherRoot : null;
          let watchMargin = item.dataset.flsWatcherMargin ? item.dataset.flsWatcherMargin : "0px";
          let watchThreshold = item.dataset.flsWatcherThreshold ? item.dataset.flsWatcherThreshold : 0;
          if (String(watchRoot) === paramsWatch.root && String(watchMargin) === paramsWatch.margin && String(watchThreshold) === paramsWatch.threshold) {
            return item;
          }
        });
        let configWatcher = this.getScrollWatcherConfig(paramsWatch);
        this.scrollWatcherInit(groupItems, configWatcher);
      });
    }
  }
  // Функція створення налаштувань
  getScrollWatcherConfig(paramsWatch) {
    let configWatcher = {};
    if (document.querySelector(paramsWatch.root)) {
      configWatcher.root = document.querySelector(paramsWatch.root);
    } else if (paramsWatch.root !== "null") ;
    configWatcher.rootMargin = paramsWatch.margin;
    if (paramsWatch.margin.indexOf("px") < 0 && paramsWatch.margin.indexOf("%") < 0) {
      return;
    }
    if (paramsWatch.threshold === "prx") {
      paramsWatch.threshold = [];
      for (let i = 0; i <= 1; i += 5e-3) {
        paramsWatch.threshold.push(i);
      }
    } else {
      paramsWatch.threshold = paramsWatch.threshold.split(",");
    }
    configWatcher.threshold = paramsWatch.threshold;
    return configWatcher;
  }
  // Функція створення нового спостерігача зі своїми налаштуваннями
  scrollWatcherCreate(configWatcher) {
    this.observer = new IntersectionObserver((entries, observer) => {
      entries.forEach((entry) => {
        this.scrollWatcherCallback(entry, observer);
      });
    }, configWatcher);
  }
  // Функція ініціалізації спостерігача зі своїми налаштуваннями
  scrollWatcherInit(items, configWatcher) {
    this.scrollWatcherCreate(configWatcher);
    items.forEach((item) => this.observer.observe(item));
  }
  // Функція обробки базових дій точок спрацьовування
  scrollWatcherIntersecting(entry, targetElement) {
    if (entry.isIntersecting) {
      !targetElement.classList.contains("--watcher-view") ? targetElement.classList.add("--watcher-view") : null;
    } else {
      targetElement.classList.contains("--watcher-view") ? targetElement.classList.remove("--watcher-view") : null;
    }
  }
  // Функція відключення стеження за об'єктом
  scrollWatcherOff(targetElement, observer) {
    observer.unobserve(targetElement);
  }
  // Функція обробки спостереження
  scrollWatcherCallback(entry, observer) {
    const targetElement = entry.target;
    this.scrollWatcherIntersecting(entry, targetElement);
    targetElement.hasAttribute("data-fls-watcher-once") && entry.isIntersecting ? this.scrollWatcherOff(targetElement, observer) : null;
    document.dispatchEvent(new CustomEvent("watcherCallback", {
      detail: {
        entry
      }
    }));
  }
}
document.querySelector("[data-fls-watcher]") ? window.addEventListener("load", () => new ScrollWatcher({})) : null;
class Parallax {
  constructor(elements) {
    if (elements.length) {
      this.elements = Array.from(elements).map((el) => new Parallax.Each(el, this.options));
    }
  }
  destroyEvents() {
    this.elements.forEach((el) => {
      el.destroyEvents();
    });
  }
  setEvents() {
    this.elements.forEach((el) => {
      el.setEvents();
    });
  }
}
Parallax.Each = class {
  constructor(parent) {
    this.parent = parent;
    this.elements = this.parent.querySelectorAll("[data-fls-parallax]");
    this.animation = this.animationFrame.bind(this);
    this.offset = 0;
    this.value = 0;
    this.smooth = parent.dataset.flsParallaxSmooth ? Number(parent.dataset.flsParallaxSmooth) : 15;
    this.setEvents();
  }
  setEvents() {
    this.animationID = window.requestAnimationFrame(this.animation);
  }
  destroyEvents() {
    window.cancelAnimationFrame(this.animationID);
  }
  animationFrame() {
    const topToWindow = this.parent.getBoundingClientRect().top;
    const heightParent = this.parent.offsetHeight;
    const heightWindow = window.innerHeight;
    const positionParent = {
      top: topToWindow - heightWindow,
      bottom: topToWindow + heightParent
    };
    const centerPoint = this.parent.dataset.flsParallaxCenter ? this.parent.dataset.flsParallaxCenter : "center";
    if (positionParent.top < 30 && positionParent.bottom > -30) {
      switch (centerPoint) {
        // верхній точці (початок батька стикається верхнього краю екрану)
        case "top":
          this.offset = -1 * topToWindow;
          break;
        // центрі екрана (середина батька у середині екрана)
        case "center":
          this.offset = heightWindow / 2 - (topToWindow + heightParent / 2);
          break;
        // Початок: нижня частина екрана = верхня частина батька
        case "bottom":
          this.offset = heightWindow - (topToWindow + heightParent);
          break;
      }
    }
    this.value += (this.offset - this.value) / this.smooth;
    this.animationID = window.requestAnimationFrame(this.animation);
    this.elements.forEach((el) => {
      const parameters = {
        axis: el.dataset.axis ? el.dataset.axis : "v",
        direction: el.dataset.flsParallaxDirection ? el.dataset.flsParallaxDirection + "1" : "-1",
        coefficient: el.dataset.flsParallaxCoefficient ? Number(el.dataset.flsParallaxCoefficient) : 5,
        additionalProperties: el.dataset.flsParallaxProperties ? el.dataset.flsParallaxProperties : ""
      };
      this.parameters(el, parameters);
    });
  }
  parameters(el, parameters) {
    if (parameters.axis == "v") {
      el.style.transform = `translate3D(0, ${(parameters.direction * (this.value / parameters.coefficient)).toFixed(2)}px,0) ${parameters.additionalProperties}`;
    } else if (parameters.axis == "h") {
      el.style.transform = `translate3D(${(parameters.direction * (this.value / parameters.coefficient)).toFixed(2)}px,0,0) ${parameters.additionalProperties}`;
    }
  }
};
if (document.querySelector("[data-fls-parallax-parent]")) {
  new Parallax(document.querySelectorAll("[data-fls-parallax-parent]"));
}
const os = {};
const __viteBrowserExternal = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: os
}, Symbol.toStringTag, { value: "Module" }));
const visitSkip = Symbol();
const visit = (node2, visitor, parentNode) => {
  const callbacks = visitor[node2.type];
  if (callbacks?.enter) {
    const symbol = callbacks.enter(node2, parentNode);
    if (symbol === visitSkip) {
      return;
    }
  }
  if (node2.type === "root") {
    for (const child of node2.children) {
      visit(child, visitor, node2);
    }
  }
  if (node2.type === "element") {
    if (parentNode.children.includes(node2)) {
      for (const child of node2.children) {
        visit(child, visitor, node2);
      }
    }
  }
  if (callbacks?.exit) {
    callbacks.exit(node2, parentNode);
  }
};
const invokePlugins = (ast, info, plugins, overrides, globalOverrides) => {
  for (const plugin of plugins) {
    const override = overrides?.[plugin.name];
    if (override === false) {
      continue;
    }
    const params = { ...plugin.params, ...globalOverrides, ...override };
    const visitor = plugin.fn(ast, params, info);
    if (visitor != null) {
      visit(ast, visitor);
    }
  }
};
const createPreset = ({ name: name2, plugins }) => {
  return {
    name: name2,
    isPreset: true,
    plugins: Object.freeze(plugins),
    fn: (ast, params, info) => {
      const { floatPrecision, overrides } = params;
      const globalOverrides = {};
      if (floatPrecision != null) {
        globalOverrides.floatPrecision = floatPrecision;
      }
      if (overrides) {
        const pluginNames = plugins.map(({ name: name3 }) => name3);
        for (const pluginName of Object.keys(overrides)) {
          if (!pluginNames.includes(pluginName)) {
            console.warn(
              `You are trying to configure ${pluginName} which is not part of ${name2}.
Try to put it before or after, for example

plugins: [
  {
    name: '${name2}',
  },
  '${pluginName}'
]
`
            );
          }
        }
      }
      invokePlugins(ast, info, plugins, overrides, globalOverrides);
    }
  };
};
var ElementType;
(function(ElementType2) {
  ElementType2["Root"] = "root";
  ElementType2["Text"] = "text";
  ElementType2["Directive"] = "directive";
  ElementType2["Comment"] = "comment";
  ElementType2["Script"] = "script";
  ElementType2["Style"] = "style";
  ElementType2["Tag"] = "tag";
  ElementType2["CDATA"] = "cdata";
  ElementType2["Doctype"] = "doctype";
})(ElementType || (ElementType = {}));
function isTag$2(elem) {
  return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
}
const Root = ElementType.Root;
const Text = ElementType.Text;
const Directive = ElementType.Directive;
const Comment$4 = ElementType.Comment;
const Script = ElementType.Script;
const Style = ElementType.Style;
const Tag = ElementType.Tag;
const CDATA = ElementType.CDATA;
const Doctype = ElementType.Doctype;
function isTag$1(node2) {
  return isTag$2(node2);
}
function isCDATA(node2) {
  return node2.type === ElementType.CDATA;
}
function isText(node2) {
  return node2.type === ElementType.Text;
}
function isComment(node2) {
  return node2.type === ElementType.Comment;
}
function isDocument(node2) {
  return node2.type === ElementType.Root;
}
function hasChildren(node2) {
  return Object.prototype.hasOwnProperty.call(node2, "children");
}
const xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
const xmlCodeMap = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
const getCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (str, index) => str.codePointAt(index) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    (c, index) => (c.charCodeAt(index) & 64512) === 55296 ? (c.charCodeAt(index) - 55296) * 1024 + c.charCodeAt(index + 1) - 56320 + 65536 : c.charCodeAt(index)
  )
);
function encodeXML(str) {
  let ret = "";
  let lastIdx = 0;
  let match;
  while ((match = xmlReplacer.exec(str)) !== null) {
    const i = match.index;
    const char = str.charCodeAt(i);
    const next = xmlCodeMap.get(char);
    if (next !== void 0) {
      ret += str.substring(lastIdx, i) + next;
      lastIdx = i + 1;
    } else {
      ret += `${str.substring(lastIdx, i)}&#x${getCodePoint(str, i).toString(16)};`;
      lastIdx = xmlReplacer.lastIndex += Number((char & 64512) === 55296);
    }
  }
  return ret + str.substr(lastIdx);
}
function getEscaper(regex, map) {
  return function escape(data) {
    let match;
    let lastIdx = 0;
    let result = "";
    while (match = regex.exec(data)) {
      if (lastIdx !== match.index) {
        result += data.substring(lastIdx, match.index);
      }
      result += map.get(match[0].charCodeAt(0));
      lastIdx = match.index + 1;
    }
    return result + data.substring(lastIdx);
  };
}
const escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
const escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));
const elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((val) => [val.toLowerCase(), val]));
const attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((val) => [val.toLowerCase(), val]));
const unencodedElements = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function replaceQuotes(value2) {
  return value2.replace(/"/g, "&quot;");
}
function formatAttributes(attributes2, opts) {
  var _a;
  if (!attributes2)
    return;
  const encode2 = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML : escapeAttribute;
  return Object.keys(attributes2).map((key) => {
    var _a2, _b;
    const value2 = (_a2 = attributes2[key]) !== null && _a2 !== void 0 ? _a2 : "";
    if (opts.xmlMode === "foreign") {
      key = (_b = attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value2 === "") {
      return key;
    }
    return `${key}="${encode2(value2)}"`;
  }).join(" ");
}
const singleTag = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render(node2, options = {}) {
  const nodes = "length" in node2 ? node2 : [node2];
  let output = "";
  for (let i = 0; i < nodes.length; i++) {
    output += renderNode(nodes[i], options);
  }
  return output;
}
function renderNode(node2, options) {
  switch (node2.type) {
    case Root:
      return render(node2.children, options);
    // @ts-expect-error We don't use `Doctype` yet
    case Doctype:
    case Directive:
      return renderDirective(node2);
    case Comment$4:
      return renderComment(node2);
    case CDATA:
      return renderCdata(node2);
    case Script:
    case Style:
    case Tag:
      return renderTag(node2, options);
    case Text:
      return renderText(node2, options);
  }
}
const foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
const foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
function renderTag(elem, opts) {
  var _a;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a = elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = { ...opts, xmlMode: false };
    }
  }
  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = { ...opts, xmlMode: "foreign" };
  }
  let tag = `<${elem.name}`;
  const attribs = formatAttributes(elem.attribs, opts);
  if (attribs) {
    tag += ` ${attribs}`;
  }
  if (elem.children.length === 0 && (opts.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    opts.selfClosingTags !== false
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    opts.selfClosingTags && singleTag.has(elem.name)
  ))) {
    if (!opts.xmlMode)
      tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag.has(elem.name)) {
      tag += `</${elem.name}>`;
    }
  }
  return tag;
}
function renderDirective(elem) {
  return `<${elem.data}>`;
}
function renderText(elem, opts) {
  var _a;
  let data = elem.data || "";
  if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
    data = opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML(data) : escapeText(data);
  }
  return data;
}
function renderCdata(elem) {
  return `<![CDATA[${elem.children[0].data}]]>`;
}
function renderComment(elem) {
  return `<!--${elem.data}-->`;
}
function getOuterHTML(node2, options) {
  return render(node2, options);
}
function getInnerHTML(node2, options) {
  return hasChildren(node2) ? node2.children.map((node3) => getOuterHTML(node3, options)).join("") : "";
}
function getText$1(node2) {
  if (Array.isArray(node2))
    return node2.map(getText$1).join("");
  if (isTag$1(node2))
    return node2.name === "br" ? "\n" : getText$1(node2.children);
  if (isCDATA(node2))
    return getText$1(node2.children);
  if (isText(node2))
    return node2.data;
  return "";
}
function textContent(node2) {
  if (Array.isArray(node2))
    return node2.map(textContent).join("");
  if (hasChildren(node2) && !isComment(node2)) {
    return textContent(node2.children);
  }
  if (isText(node2))
    return node2.data;
  return "";
}
function innerText(node2) {
  if (Array.isArray(node2))
    return node2.map(innerText).join("");
  if (hasChildren(node2) && (node2.type === ElementType.Tag || isCDATA(node2))) {
    return innerText(node2.children);
  }
  if (isText(node2))
    return node2.data;
  return "";
}
function getChildren$1(elem) {
  return hasChildren(elem) ? elem.children : [];
}
function getParent(elem) {
  return elem.parent || null;
}
function getSiblings(elem) {
  const parent = getParent(elem);
  if (parent != null)
    return getChildren$1(parent);
  const siblings = [elem];
  let { prev, next } = elem;
  while (prev != null) {
    siblings.unshift(prev);
    ({ prev } = prev);
  }
  while (next != null) {
    siblings.push(next);
    ({ next } = next);
  }
  return siblings;
}
function getAttributeValue$1(elem, name2) {
  var _a;
  return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name2];
}
function hasAttrib$1(elem, name2) {
  return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name2) && elem.attribs[name2] != null;
}
function getName$1(elem) {
  return elem.name;
}
function nextElementSibling(elem) {
  let { next } = elem;
  while (next !== null && !isTag$1(next))
    ({ next } = next);
  return next;
}
function prevElementSibling(elem) {
  let { prev } = elem;
  while (prev !== null && !isTag$1(prev))
    ({ prev } = prev);
  return prev;
}
function removeElement(elem) {
  if (elem.prev)
    elem.prev.next = elem.next;
  if (elem.next)
    elem.next.prev = elem.prev;
  if (elem.parent) {
    const childs = elem.parent.children;
    const childsIndex = childs.lastIndexOf(elem);
    if (childsIndex >= 0) {
      childs.splice(childsIndex, 1);
    }
  }
  elem.next = null;
  elem.prev = null;
  elem.parent = null;
}
function replaceElement(elem, replacement) {
  const prev = replacement.prev = elem.prev;
  if (prev) {
    prev.next = replacement;
  }
  const next = replacement.next = elem.next;
  if (next) {
    next.prev = replacement;
  }
  const parent = replacement.parent = elem.parent;
  if (parent) {
    const childs = parent.children;
    childs[childs.lastIndexOf(elem)] = replacement;
    elem.parent = null;
  }
}
function appendChild(parent, child) {
  removeElement(child);
  child.next = null;
  child.parent = parent;
  if (parent.children.push(child) > 1) {
    const sibling = parent.children[parent.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
  } else {
    child.prev = null;
  }
}
function append$1(elem, next) {
  removeElement(next);
  const { parent } = elem;
  const currNext = elem.next;
  next.next = currNext;
  next.prev = elem;
  elem.next = next;
  next.parent = parent;
  if (currNext) {
    currNext.prev = next;
    if (parent) {
      const childs = parent.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next);
    }
  } else if (parent) {
    parent.children.push(next);
  }
}
function prependChild(parent, child) {
  removeElement(child);
  child.parent = parent;
  child.prev = null;
  if (parent.children.unshift(child) !== 1) {
    const sibling = parent.children[1];
    sibling.prev = child;
    child.next = sibling;
  } else {
    child.next = null;
  }
}
function prepend(elem, prev) {
  removeElement(prev);
  const { parent } = elem;
  if (parent) {
    const childs = parent.children;
    childs.splice(childs.indexOf(elem), 0, prev);
  }
  if (elem.prev) {
    elem.prev.next = prev;
  }
  prev.parent = parent;
  prev.prev = elem.prev;
  prev.next = elem;
  elem.prev = prev;
}
function filter(test, node2, recurse = true, limit = Infinity) {
  return find$3(test, Array.isArray(node2) ? node2 : [node2], recurse, limit);
}
function find$3(test, nodes, recurse, limit) {
  const result = [];
  const nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
  const indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (indexStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (test(elem)) {
      result.push(elem);
      if (--limit <= 0)
        return result;
    }
    if (recurse && hasChildren(elem) && elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
function findOneChild(test, nodes) {
  return nodes.find(test);
}
function findOne$1(test, nodes, recurse = true) {
  const searchedNodes = Array.isArray(nodes) ? nodes : [nodes];
  for (let i = 0; i < searchedNodes.length; i++) {
    const node2 = searchedNodes[i];
    if (isTag$1(node2) && test(node2)) {
      return node2;
    }
    if (recurse && hasChildren(node2) && node2.children.length > 0) {
      const found = findOne$1(test, node2.children, true);
      if (found)
        return found;
    }
  }
  return null;
}
function existsOne$1(test, nodes) {
  return (Array.isArray(nodes) ? nodes : [nodes]).some((node2) => isTag$1(node2) && test(node2) || hasChildren(node2) && existsOne$1(test, node2.children));
}
function findAll$4(test, nodes) {
  const result = [];
  const nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
  const indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (nodeStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (isTag$1(elem) && test(elem))
      result.push(elem);
    if (hasChildren(elem) && elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
const Checks = {
  tag_name(name2) {
    if (typeof name2 === "function") {
      return (elem) => isTag$1(elem) && name2(elem.name);
    } else if (name2 === "*") {
      return isTag$1;
    }
    return (elem) => isTag$1(elem) && elem.name === name2;
  },
  tag_type(type) {
    if (typeof type === "function") {
      return (elem) => type(elem.type);
    }
    return (elem) => elem.type === type;
  },
  tag_contains(data) {
    if (typeof data === "function") {
      return (elem) => isText(elem) && data(elem.data);
    }
    return (elem) => isText(elem) && elem.data === data;
  }
};
function getAttribCheck(attrib, value2) {
  if (typeof value2 === "function") {
    return (elem) => isTag$1(elem) && value2(elem.attribs[attrib]);
  }
  return (elem) => isTag$1(elem) && elem.attribs[attrib] === value2;
}
function combineFuncs(a, b) {
  return (elem) => a(elem) || b(elem);
}
function compileTest(options) {
  const funcs = Object.keys(options).map((key) => {
    const value2 = options[key];
    return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value2) : getAttribCheck(key, value2);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
function testElement(options, node2) {
  const test = compileTest(options);
  return test ? test(node2) : true;
}
function getElements(options, nodes, recurse, limit = Infinity) {
  const test = compileTest(options);
  return test ? filter(test, nodes, recurse, limit) : [];
}
function getElementById(id, nodes, recurse = true) {
  if (!Array.isArray(nodes))
    nodes = [nodes];
  return findOne$1(getAttribCheck("id", id), nodes, recurse);
}
function getElementsByTagName(tagName, nodes, recurse = true, limit = Infinity) {
  return filter(Checks["tag_name"](tagName), nodes, recurse, limit);
}
function getElementsByClassName(className, nodes, recurse = true, limit = Infinity) {
  return filter(getAttribCheck("class", className), nodes, recurse, limit);
}
function getElementsByTagType(type, nodes, recurse = true, limit = Infinity) {
  return filter(Checks["tag_type"](type), nodes, recurse, limit);
}
function removeSubsets(nodes) {
  let idx = nodes.length;
  while (--idx >= 0) {
    const node2 = nodes[idx];
    if (idx > 0 && nodes.lastIndexOf(node2, idx - 1) >= 0) {
      nodes.splice(idx, 1);
      continue;
    }
    for (let ancestor = node2.parent; ancestor; ancestor = ancestor.parent) {
      if (nodes.includes(ancestor)) {
        nodes.splice(idx, 1);
        break;
      }
    }
  }
  return nodes;
}
var DocumentPosition;
(function(DocumentPosition2) {
  DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
  DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
  DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
  DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
  DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
})(DocumentPosition || (DocumentPosition = {}));
function compareDocumentPosition(nodeA, nodeB) {
  const aParents = [];
  const bParents = [];
  if (nodeA === nodeB) {
    return 0;
  }
  let current = hasChildren(nodeA) ? nodeA : nodeA.parent;
  while (current) {
    aParents.unshift(current);
    current = current.parent;
  }
  current = hasChildren(nodeB) ? nodeB : nodeB.parent;
  while (current) {
    bParents.unshift(current);
    current = current.parent;
  }
  const maxIdx = Math.min(aParents.length, bParents.length);
  let idx = 0;
  while (idx < maxIdx && aParents[idx] === bParents[idx]) {
    idx++;
  }
  if (idx === 0) {
    return DocumentPosition.DISCONNECTED;
  }
  const sharedParent = aParents[idx - 1];
  const siblings = sharedParent.children;
  const aSibling = aParents[idx];
  const bSibling = bParents[idx];
  if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
    if (sharedParent === nodeB) {
      return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
    }
    return DocumentPosition.FOLLOWING;
  }
  if (sharedParent === nodeA) {
    return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
  }
  return DocumentPosition.PRECEDING;
}
function uniqueSort(nodes) {
  nodes = nodes.filter((node2, i, arr) => !arr.includes(node2, i + 1));
  nodes.sort((a, b) => {
    const relative = compareDocumentPosition(a, b);
    if (relative & DocumentPosition.PRECEDING) {
      return -1;
    } else if (relative & DocumentPosition.FOLLOWING) {
      return 1;
    }
    return 0;
  });
  return nodes;
}
function getFeed(doc) {
  const feedRoot = getOneElement(isValidFeed, doc);
  return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
}
function getAtomFeed(feedRoot) {
  var _a;
  const childs = feedRoot.children;
  const feed = {
    type: "atom",
    items: getElementsByTagName("entry", childs).map((item) => {
      var _a2;
      const { children } = item;
      const entry = { media: getMediaElements(children) };
      addConditionally(entry, "id", "id", children);
      addConditionally(entry, "title", "title", children);
      const href2 = (_a2 = getOneElement("link", children)) === null || _a2 === void 0 ? void 0 : _a2.attribs["href"];
      if (href2) {
        entry.link = href2;
      }
      const description2 = fetch$1("summary", children) || fetch$1("content", children);
      if (description2) {
        entry.description = description2;
      }
      const pubDate = fetch$1("updated", children);
      if (pubDate) {
        entry.pubDate = new Date(pubDate);
      }
      return entry;
    })
  };
  addConditionally(feed, "id", "id", childs);
  addConditionally(feed, "title", "title", childs);
  const href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
  if (href) {
    feed.link = href;
  }
  addConditionally(feed, "description", "subtitle", childs);
  const updated = fetch$1("updated", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "email", childs, true);
  return feed;
}
function getRssFeed(feedRoot) {
  var _a, _b;
  const childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
  const feed = {
    type: feedRoot.name.substr(0, 3),
    id: "",
    items: getElementsByTagName("item", feedRoot.children).map((item) => {
      const { children } = item;
      const entry = { media: getMediaElements(children) };
      addConditionally(entry, "id", "guid", children);
      addConditionally(entry, "title", "title", children);
      addConditionally(entry, "link", "link", children);
      addConditionally(entry, "description", "description", children);
      const pubDate = fetch$1("pubDate", children) || fetch$1("dc:date", children);
      if (pubDate)
        entry.pubDate = new Date(pubDate);
      return entry;
    })
  };
  addConditionally(feed, "title", "title", childs);
  addConditionally(feed, "link", "link", childs);
  addConditionally(feed, "description", "description", childs);
  const updated = fetch$1("lastBuildDate", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "managingEditor", childs, true);
  return feed;
}
const MEDIA_KEYS_STRING = ["url", "type", "lang"];
const MEDIA_KEYS_INT = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
function getMediaElements(where) {
  return getElementsByTagName("media:content", where).map((elem) => {
    const { attribs } = elem;
    const media2 = {
      medium: attribs["medium"],
      isDefault: !!attribs["isDefault"]
    };
    for (const attrib of MEDIA_KEYS_STRING) {
      if (attribs[attrib]) {
        media2[attrib] = attribs[attrib];
      }
    }
    for (const attrib of MEDIA_KEYS_INT) {
      if (attribs[attrib]) {
        media2[attrib] = parseInt(attribs[attrib], 10);
      }
    }
    if (attribs["expression"]) {
      media2.expression = attribs["expression"];
    }
    return media2;
  });
}
function getOneElement(tagName, node2) {
  return getElementsByTagName(tagName, node2, true, 1)[0];
}
function fetch$1(tagName, where, recurse = false) {
  return textContent(getElementsByTagName(tagName, where, recurse, 1)).trim();
}
function addConditionally(obj, prop, tagName, where, recurse = false) {
  const val = fetch$1(tagName, where, recurse);
  if (val)
    obj[prop] = val;
}
function isValidFeed(value2) {
  return value2 === "rss" || value2 === "feed" || value2 === "rdf:RDF";
}
const DomUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get DocumentPosition() {
    return DocumentPosition;
  },
  append: append$1,
  appendChild,
  compareDocumentPosition,
  existsOne: existsOne$1,
  filter,
  find: find$3,
  findAll: findAll$4,
  findOne: findOne$1,
  findOneChild,
  getAttributeValue: getAttributeValue$1,
  getChildren: getChildren$1,
  getElementById,
  getElements,
  getElementsByClassName,
  getElementsByTagName,
  getElementsByTagType,
  getFeed,
  getInnerHTML,
  getName: getName$1,
  getOuterHTML,
  getParent,
  getSiblings,
  getText: getText$1,
  hasAttrib: hasAttrib$1,
  hasChildren,
  innerText,
  isCDATA,
  isComment,
  isDocument,
  isTag: isTag$1,
  isText,
  nextElementSibling,
  prepend,
  prependChild,
  prevElementSibling,
  removeElement,
  removeSubsets,
  replaceElement,
  testElement,
  textContent,
  uniqueSort
}, Symbol.toStringTag, { value: "Module" }));
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      var isInstance = false;
      try {
        isInstance = this instanceof a2;
      } catch {
      }
      if (isInstance) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var boolbase$1;
var hasRequiredBoolbase;
function requireBoolbase() {
  if (hasRequiredBoolbase) return boolbase$1;
  hasRequiredBoolbase = 1;
  boolbase$1 = {
    trueFunc: function trueFunc() {
      return true;
    },
    falseFunc: function falseFunc() {
      return false;
    }
  };
  return boolbase$1;
}
var boolbaseExports = requireBoolbase();
const boolbase = /* @__PURE__ */ getDefaultExportFromCjs(boolbaseExports);
var SelectorType;
(function(SelectorType2) {
  SelectorType2["Attribute"] = "attribute";
  SelectorType2["Pseudo"] = "pseudo";
  SelectorType2["PseudoElement"] = "pseudo-element";
  SelectorType2["Tag"] = "tag";
  SelectorType2["Universal"] = "universal";
  SelectorType2["Adjacent"] = "adjacent";
  SelectorType2["Child"] = "child";
  SelectorType2["Descendant"] = "descendant";
  SelectorType2["Parent"] = "parent";
  SelectorType2["Sibling"] = "sibling";
  SelectorType2["ColumnCombinator"] = "column-combinator";
})(SelectorType || (SelectorType = {}));
var AttributeAction;
(function(AttributeAction2) {
  AttributeAction2["Any"] = "any";
  AttributeAction2["Element"] = "element";
  AttributeAction2["End"] = "end";
  AttributeAction2["Equals"] = "equals";
  AttributeAction2["Exists"] = "exists";
  AttributeAction2["Hyphen"] = "hyphen";
  AttributeAction2["Not"] = "not";
  AttributeAction2["Start"] = "start";
})(AttributeAction || (AttributeAction = {}));
const reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
const reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
const actionTypes = /* @__PURE__ */ new Map([
  [126, AttributeAction.Element],
  [94, AttributeAction.Start],
  [36, AttributeAction.End],
  [42, AttributeAction.Any],
  [33, AttributeAction.Not],
  [124, AttributeAction.Hyphen]
]);
const unpackPseudos = /* @__PURE__ */ new Set([
  "has",
  "not",
  "matches",
  "is",
  "where",
  "host",
  "host-context"
]);
function isTraversal$1(selector2) {
  switch (selector2.type) {
    case SelectorType.Adjacent:
    case SelectorType.Child:
    case SelectorType.Descendant:
    case SelectorType.Parent:
    case SelectorType.Sibling:
    case SelectorType.ColumnCombinator:
      return true;
    default:
      return false;
  }
}
const stripQuotesFromPseudos = /* @__PURE__ */ new Set(["contains", "icontains"]);
function funescape(_, escaped, escapedWhitespace) {
  const high = parseInt(escaped, 16) - 65536;
  return high !== high || escapedWhitespace ? escaped : high < 0 ? (
    // BMP codepoint
    String.fromCharCode(high + 65536)
  ) : (
    // Supplemental Plane codepoint (surrogate pair)
    String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
  );
}
function unescapeCSS(str) {
  return str.replace(reEscape, funescape);
}
function isQuote(c) {
  return c === 39 || c === 34;
}
function isWhitespace(c) {
  return c === 32 || c === 9 || c === 10 || c === 12 || c === 13;
}
function parse$1w(selector2) {
  const subselects2 = [];
  const endIndex = parseSelector(subselects2, `${selector2}`, 0);
  if (endIndex < selector2.length) {
    throw new Error(`Unmatched selector: ${selector2.slice(endIndex)}`);
  }
  return subselects2;
}
function parseSelector(subselects2, selector2, selectorIndex) {
  let tokens = [];
  function getName2(offset) {
    const match = selector2.slice(selectorIndex + offset).match(reName);
    if (!match) {
      throw new Error(`Expected name, found ${selector2.slice(selectorIndex)}`);
    }
    const [name2] = match;
    selectorIndex += offset + name2.length;
    return unescapeCSS(name2);
  }
  function stripWhitespace(offset) {
    selectorIndex += offset;
    while (selectorIndex < selector2.length && isWhitespace(selector2.charCodeAt(selectorIndex))) {
      selectorIndex++;
    }
  }
  function readValueWithParenthesis() {
    selectorIndex += 1;
    const start = selectorIndex;
    let counter = 1;
    for (; counter > 0 && selectorIndex < selector2.length; selectorIndex++) {
      if (selector2.charCodeAt(selectorIndex) === 40 && !isEscaped(selectorIndex)) {
        counter++;
      } else if (selector2.charCodeAt(selectorIndex) === 41 && !isEscaped(selectorIndex)) {
        counter--;
      }
    }
    if (counter) {
      throw new Error("Parenthesis not matched");
    }
    return unescapeCSS(selector2.slice(start, selectorIndex - 1));
  }
  function isEscaped(pos) {
    let slashCount = 0;
    while (selector2.charCodeAt(--pos) === 92)
      slashCount++;
    return (slashCount & 1) === 1;
  }
  function ensureNotTraversal() {
    if (tokens.length > 0 && isTraversal$1(tokens[tokens.length - 1])) {
      throw new Error("Did not expect successive traversals.");
    }
  }
  function addTraversal(type) {
    if (tokens.length > 0 && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens[tokens.length - 1].type = type;
      return;
    }
    ensureNotTraversal();
    tokens.push({ type });
  }
  function addSpecialAttribute(name2, action) {
    tokens.push({
      type: SelectorType.Attribute,
      name: name2,
      action,
      value: getName2(1),
      namespace: null,
      ignoreCase: "quirks"
    });
  }
  function finalizeSubselector() {
    if (tokens.length && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens.pop();
    }
    if (tokens.length === 0) {
      throw new Error("Empty sub-selector");
    }
    subselects2.push(tokens);
  }
  stripWhitespace(0);
  if (selector2.length === selectorIndex) {
    return selectorIndex;
  }
  loop: while (selectorIndex < selector2.length) {
    const firstChar = selector2.charCodeAt(selectorIndex);
    switch (firstChar) {
      // Whitespace
      case 32:
      case 9:
      case 10:
      case 12:
      case 13: {
        if (tokens.length === 0 || tokens[0].type !== SelectorType.Descendant) {
          ensureNotTraversal();
          tokens.push({ type: SelectorType.Descendant });
        }
        stripWhitespace(1);
        break;
      }
      // Traversals
      case 62: {
        addTraversal(SelectorType.Child);
        stripWhitespace(1);
        break;
      }
      case 60: {
        addTraversal(SelectorType.Parent);
        stripWhitespace(1);
        break;
      }
      case 126: {
        addTraversal(SelectorType.Sibling);
        stripWhitespace(1);
        break;
      }
      case 43: {
        addTraversal(SelectorType.Adjacent);
        stripWhitespace(1);
        break;
      }
      // Special attribute selectors: .class, #id
      case 46: {
        addSpecialAttribute("class", AttributeAction.Element);
        break;
      }
      case 35: {
        addSpecialAttribute("id", AttributeAction.Equals);
        break;
      }
      case 91: {
        stripWhitespace(1);
        let name2;
        let namespace = null;
        if (selector2.charCodeAt(selectorIndex) === 124) {
          name2 = getName2(1);
        } else if (selector2.startsWith("*|", selectorIndex)) {
          namespace = "*";
          name2 = getName2(2);
        } else {
          name2 = getName2(0);
          if (selector2.charCodeAt(selectorIndex) === 124 && selector2.charCodeAt(selectorIndex + 1) !== 61) {
            namespace = name2;
            name2 = getName2(1);
          }
        }
        stripWhitespace(0);
        let action = AttributeAction.Exists;
        const possibleAction = actionTypes.get(selector2.charCodeAt(selectorIndex));
        if (possibleAction) {
          action = possibleAction;
          if (selector2.charCodeAt(selectorIndex + 1) !== 61) {
            throw new Error("Expected `=`");
          }
          stripWhitespace(2);
        } else if (selector2.charCodeAt(selectorIndex) === 61) {
          action = AttributeAction.Equals;
          stripWhitespace(1);
        }
        let value2 = "";
        let ignoreCase = null;
        if (action !== "exists") {
          if (isQuote(selector2.charCodeAt(selectorIndex))) {
            const quote = selector2.charCodeAt(selectorIndex);
            let sectionEnd = selectorIndex + 1;
            while (sectionEnd < selector2.length && (selector2.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) {
              sectionEnd += 1;
            }
            if (selector2.charCodeAt(sectionEnd) !== quote) {
              throw new Error("Attribute value didn't end");
            }
            value2 = unescapeCSS(selector2.slice(selectorIndex + 1, sectionEnd));
            selectorIndex = sectionEnd + 1;
          } else {
            const valueStart = selectorIndex;
            while (selectorIndex < selector2.length && (!isWhitespace(selector2.charCodeAt(selectorIndex)) && selector2.charCodeAt(selectorIndex) !== 93 || isEscaped(selectorIndex))) {
              selectorIndex += 1;
            }
            value2 = unescapeCSS(selector2.slice(valueStart, selectorIndex));
          }
          stripWhitespace(0);
          const forceIgnore = selector2.charCodeAt(selectorIndex) | 32;
          if (forceIgnore === 115) {
            ignoreCase = false;
            stripWhitespace(1);
          } else if (forceIgnore === 105) {
            ignoreCase = true;
            stripWhitespace(1);
          }
        }
        if (selector2.charCodeAt(selectorIndex) !== 93) {
          throw new Error("Attribute selector didn't terminate");
        }
        selectorIndex += 1;
        const attributeSelector = {
          type: SelectorType.Attribute,
          name: name2,
          action,
          value: value2,
          namespace,
          ignoreCase
        };
        tokens.push(attributeSelector);
        break;
      }
      case 58: {
        if (selector2.charCodeAt(selectorIndex + 1) === 58) {
          tokens.push({
            type: SelectorType.PseudoElement,
            name: getName2(2).toLowerCase(),
            data: selector2.charCodeAt(selectorIndex) === 40 ? readValueWithParenthesis() : null
          });
          continue;
        }
        const name2 = getName2(1).toLowerCase();
        let data = null;
        if (selector2.charCodeAt(selectorIndex) === 40) {
          if (unpackPseudos.has(name2)) {
            if (isQuote(selector2.charCodeAt(selectorIndex + 1))) {
              throw new Error(`Pseudo-selector ${name2} cannot be quoted`);
            }
            data = [];
            selectorIndex = parseSelector(data, selector2, selectorIndex + 1);
            if (selector2.charCodeAt(selectorIndex) !== 41) {
              throw new Error(`Missing closing parenthesis in :${name2} (${selector2})`);
            }
            selectorIndex += 1;
          } else {
            data = readValueWithParenthesis();
            if (stripQuotesFromPseudos.has(name2)) {
              const quot = data.charCodeAt(0);
              if (quot === data.charCodeAt(data.length - 1) && isQuote(quot)) {
                data = data.slice(1, -1);
              }
            }
            data = unescapeCSS(data);
          }
        }
        tokens.push({ type: SelectorType.Pseudo, name: name2, data });
        break;
      }
      case 44: {
        finalizeSubselector();
        tokens = [];
        stripWhitespace(1);
        break;
      }
      default: {
        if (selector2.startsWith("/*", selectorIndex)) {
          const endIndex = selector2.indexOf("*/", selectorIndex + 2);
          if (endIndex < 0) {
            throw new Error("Comment was not terminated");
          }
          selectorIndex = endIndex + 2;
          if (tokens.length === 0) {
            stripWhitespace(0);
          }
          break;
        }
        let namespace = null;
        let name2;
        if (firstChar === 42) {
          selectorIndex += 1;
          name2 = "*";
        } else if (firstChar === 124) {
          name2 = "";
          if (selector2.charCodeAt(selectorIndex + 1) === 124) {
            addTraversal(SelectorType.ColumnCombinator);
            stripWhitespace(2);
            break;
          }
        } else if (reName.test(selector2.slice(selectorIndex))) {
          name2 = getName2(0);
        } else {
          break loop;
        }
        if (selector2.charCodeAt(selectorIndex) === 124 && selector2.charCodeAt(selectorIndex + 1) !== 124) {
          namespace = name2;
          if (selector2.charCodeAt(selectorIndex + 1) === 42) {
            name2 = "*";
            selectorIndex += 2;
          } else {
            name2 = getName2(1);
          }
        }
        tokens.push(name2 === "*" ? { type: SelectorType.Universal, namespace } : { type: SelectorType.Tag, name: name2, namespace });
      }
    }
  }
  finalizeSubselector();
  return selectorIndex;
}
const procedure = /* @__PURE__ */ new Map([
  [SelectorType.Universal, 50],
  [SelectorType.Tag, 30],
  [SelectorType.Attribute, 1],
  [SelectorType.Pseudo, 0]
]);
function isTraversal(token) {
  return !procedure.has(token.type);
}
const attributes = /* @__PURE__ */ new Map([
  [AttributeAction.Exists, 10],
  [AttributeAction.Equals, 8],
  [AttributeAction.Not, 7],
  [AttributeAction.Start, 6],
  [AttributeAction.End, 6],
  [AttributeAction.Any, 5]
]);
function sortByProcedure(arr) {
  const procs = arr.map(getProcedure);
  for (let i = 1; i < arr.length; i++) {
    const procNew = procs[i];
    if (procNew < 0)
      continue;
    for (let j = i - 1; j >= 0 && procNew < procs[j]; j--) {
      const token = arr[j + 1];
      arr[j + 1] = arr[j];
      arr[j] = token;
      procs[j + 1] = procs[j];
      procs[j] = procNew;
    }
  }
}
function getProcedure(token) {
  var _a, _b;
  let proc = (_a = procedure.get(token.type)) !== null && _a !== void 0 ? _a : -1;
  if (token.type === SelectorType.Attribute) {
    proc = (_b = attributes.get(token.action)) !== null && _b !== void 0 ? _b : 4;
    if (token.action === AttributeAction.Equals && token.name === "id") {
      proc = 9;
    }
    if (token.ignoreCase) {
      proc >>= 1;
    }
  } else if (token.type === SelectorType.Pseudo) {
    if (!token.data) {
      proc = 3;
    } else if (token.name === "has" || token.name === "contains") {
      proc = 0;
    } else if (Array.isArray(token.data)) {
      proc = Math.min(...token.data.map((d) => Math.min(...d.map(getProcedure))));
      if (proc < 0) {
        proc = 0;
      }
    } else {
      proc = 2;
    }
  }
  return proc;
}
const reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
function escapeRegex(value2) {
  return value2.replace(reChars, "\\$&");
}
const caseInsensitiveAttributes = /* @__PURE__ */ new Set([
  "accept",
  "accept-charset",
  "align",
  "alink",
  "axis",
  "bgcolor",
  "charset",
  "checked",
  "clear",
  "codetype",
  "color",
  "compact",
  "declare",
  "defer",
  "dir",
  "direction",
  "disabled",
  "enctype",
  "face",
  "frame",
  "hreflang",
  "http-equiv",
  "lang",
  "language",
  "link",
  "media",
  "method",
  "multiple",
  "nohref",
  "noresize",
  "noshade",
  "nowrap",
  "readonly",
  "rel",
  "rev",
  "rules",
  "scope",
  "scrolling",
  "selected",
  "shape",
  "target",
  "text",
  "type",
  "valign",
  "valuetype",
  "vlink"
]);
function shouldIgnoreCase(selector2, options) {
  return typeof selector2.ignoreCase === "boolean" ? selector2.ignoreCase : selector2.ignoreCase === "quirks" ? !!options.quirksMode : !options.xmlMode && caseInsensitiveAttributes.has(selector2.name);
}
const attributeRules = {
  equals(next, data, options) {
    const { adapter } = options;
    const { name: name2 } = data;
    let { value: value2 } = data;
    if (shouldIgnoreCase(data, options)) {
      value2 = value2.toLowerCase();
      return (elem) => {
        const attr = adapter.getAttributeValue(elem, name2);
        return attr != null && attr.length === value2.length && attr.toLowerCase() === value2 && next(elem);
      };
    }
    return (elem) => adapter.getAttributeValue(elem, name2) === value2 && next(elem);
  },
  hyphen(next, data, options) {
    const { adapter } = options;
    const { name: name2 } = data;
    let { value: value2 } = data;
    const len = value2.length;
    if (shouldIgnoreCase(data, options)) {
      value2 = value2.toLowerCase();
      return function hyphenIC(elem) {
        const attr = adapter.getAttributeValue(elem, name2);
        return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len).toLowerCase() === value2 && next(elem);
      };
    }
    return function hyphen(elem) {
      const attr = adapter.getAttributeValue(elem, name2);
      return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len) === value2 && next(elem);
    };
  },
  element(next, data, options) {
    const { adapter } = options;
    const { name: name2, value: value2 } = data;
    if (/\s/.test(value2)) {
      return boolbase.falseFunc;
    }
    const regex = new RegExp(`(?:^|\\s)${escapeRegex(value2)}(?:$|\\s)`, shouldIgnoreCase(data, options) ? "i" : "");
    return function element(elem) {
      const attr = adapter.getAttributeValue(elem, name2);
      return attr != null && attr.length >= value2.length && regex.test(attr) && next(elem);
    };
  },
  exists(next, { name: name2 }, { adapter }) {
    return (elem) => adapter.hasAttrib(elem, name2) && next(elem);
  },
  start(next, data, options) {
    const { adapter } = options;
    const { name: name2 } = data;
    let { value: value2 } = data;
    const len = value2.length;
    if (len === 0) {
      return boolbase.falseFunc;
    }
    if (shouldIgnoreCase(data, options)) {
      value2 = value2.toLowerCase();
      return (elem) => {
        const attr = adapter.getAttributeValue(elem, name2);
        return attr != null && attr.length >= len && attr.substr(0, len).toLowerCase() === value2 && next(elem);
      };
    }
    return (elem) => {
      var _a;
      return !!((_a = adapter.getAttributeValue(elem, name2)) === null || _a === void 0 ? void 0 : _a.startsWith(value2)) && next(elem);
    };
  },
  end(next, data, options) {
    const { adapter } = options;
    const { name: name2 } = data;
    let { value: value2 } = data;
    const len = -value2.length;
    if (len === 0) {
      return boolbase.falseFunc;
    }
    if (shouldIgnoreCase(data, options)) {
      value2 = value2.toLowerCase();
      return (elem) => {
        var _a;
        return ((_a = adapter.getAttributeValue(elem, name2)) === null || _a === void 0 ? void 0 : _a.substr(len).toLowerCase()) === value2 && next(elem);
      };
    }
    return (elem) => {
      var _a;
      return !!((_a = adapter.getAttributeValue(elem, name2)) === null || _a === void 0 ? void 0 : _a.endsWith(value2)) && next(elem);
    };
  },
  any(next, data, options) {
    const { adapter } = options;
    const { name: name2, value: value2 } = data;
    if (value2 === "") {
      return boolbase.falseFunc;
    }
    if (shouldIgnoreCase(data, options)) {
      const regex = new RegExp(escapeRegex(value2), "i");
      return function anyIC(elem) {
        const attr = adapter.getAttributeValue(elem, name2);
        return attr != null && attr.length >= value2.length && regex.test(attr) && next(elem);
      };
    }
    return (elem) => {
      var _a;
      return !!((_a = adapter.getAttributeValue(elem, name2)) === null || _a === void 0 ? void 0 : _a.includes(value2)) && next(elem);
    };
  },
  not(next, data, options) {
    const { adapter } = options;
    const { name: name2 } = data;
    let { value: value2 } = data;
    if (value2 === "") {
      return (elem) => !!adapter.getAttributeValue(elem, name2) && next(elem);
    } else if (shouldIgnoreCase(data, options)) {
      value2 = value2.toLowerCase();
      return (elem) => {
        const attr = adapter.getAttributeValue(elem, name2);
        return (attr == null || attr.length !== value2.length || attr.toLowerCase() !== value2) && next(elem);
      };
    }
    return (elem) => adapter.getAttributeValue(elem, name2) !== value2 && next(elem);
  }
};
const whitespace = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]);
const ZERO = "0".charCodeAt(0);
const NINE = "9".charCodeAt(0);
function parse$1v(formula) {
  formula = formula.trim().toLowerCase();
  if (formula === "even") {
    return [2, 0];
  } else if (formula === "odd") {
    return [2, 1];
  }
  let idx = 0;
  let a = 0;
  let sign = readSign();
  let number2 = readNumber2();
  if (idx < formula.length && formula.charAt(idx) === "n") {
    idx++;
    a = sign * (number2 !== null && number2 !== void 0 ? number2 : 1);
    skipWhitespace();
    if (idx < formula.length) {
      sign = readSign();
      skipWhitespace();
      number2 = readNumber2();
    } else {
      sign = number2 = 0;
    }
  }
  if (number2 === null || idx < formula.length) {
    throw new Error(`n-th rule couldn't be parsed ('${formula}')`);
  }
  return [a, sign * number2];
  function readSign() {
    if (formula.charAt(idx) === "-") {
      idx++;
      return -1;
    }
    if (formula.charAt(idx) === "+") {
      idx++;
    }
    return 1;
  }
  function readNumber2() {
    const start = idx;
    let value2 = 0;
    while (idx < formula.length && formula.charCodeAt(idx) >= ZERO && formula.charCodeAt(idx) <= NINE) {
      value2 = value2 * 10 + (formula.charCodeAt(idx) - ZERO);
      idx++;
    }
    return idx === start ? null : value2;
  }
  function skipWhitespace() {
    while (idx < formula.length && whitespace.has(formula.charCodeAt(idx))) {
      idx++;
    }
  }
}
function compile$1(parsed) {
  const a = parsed[0];
  const b = parsed[1] - 1;
  if (b < 0 && a <= 0)
    return boolbase.falseFunc;
  if (a === -1)
    return (index) => index <= b;
  if (a === 0)
    return (index) => index === b;
  if (a === 1)
    return b < 0 ? boolbase.trueFunc : (index) => index >= b;
  const absA = Math.abs(a);
  const bMod = (b % absA + absA) % absA;
  return a > 1 ? (index) => index >= b && index % absA === bMod : (index) => index <= b && index % absA === bMod;
}
function nthCheck(formula) {
  return compile$1(parse$1v(formula));
}
function getChildFunc(next, adapter) {
  return (elem) => {
    const parent = adapter.getParent(elem);
    return parent != null && adapter.isTag(parent) && next(elem);
  };
}
const filters$1 = {
  contains(next, text, { adapter }) {
    return function contains(elem) {
      return next(elem) && adapter.getText(elem).includes(text);
    };
  },
  icontains(next, text, { adapter }) {
    const itext = text.toLowerCase();
    return function icontains(elem) {
      return next(elem) && adapter.getText(elem).toLowerCase().includes(itext);
    };
  },
  // Location specific methods
  "nth-child"(next, rule, { adapter, equals }) {
    const func = nthCheck(rule);
    if (func === boolbase.falseFunc)
      return boolbase.falseFunc;
    if (func === boolbase.trueFunc)
      return getChildFunc(next, adapter);
    return function nthChild(elem) {
      const siblings = adapter.getSiblings(elem);
      let pos = 0;
      for (let i = 0; i < siblings.length; i++) {
        if (equals(elem, siblings[i]))
          break;
        if (adapter.isTag(siblings[i])) {
          pos++;
        }
      }
      return func(pos) && next(elem);
    };
  },
  "nth-last-child"(next, rule, { adapter, equals }) {
    const func = nthCheck(rule);
    if (func === boolbase.falseFunc)
      return boolbase.falseFunc;
    if (func === boolbase.trueFunc)
      return getChildFunc(next, adapter);
    return function nthLastChild(elem) {
      const siblings = adapter.getSiblings(elem);
      let pos = 0;
      for (let i = siblings.length - 1; i >= 0; i--) {
        if (equals(elem, siblings[i]))
          break;
        if (adapter.isTag(siblings[i])) {
          pos++;
        }
      }
      return func(pos) && next(elem);
    };
  },
  "nth-of-type"(next, rule, { adapter, equals }) {
    const func = nthCheck(rule);
    if (func === boolbase.falseFunc)
      return boolbase.falseFunc;
    if (func === boolbase.trueFunc)
      return getChildFunc(next, adapter);
    return function nthOfType(elem) {
      const siblings = adapter.getSiblings(elem);
      let pos = 0;
      for (let i = 0; i < siblings.length; i++) {
        const currentSibling = siblings[i];
        if (equals(elem, currentSibling))
          break;
        if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
          pos++;
        }
      }
      return func(pos) && next(elem);
    };
  },
  "nth-last-of-type"(next, rule, { adapter, equals }) {
    const func = nthCheck(rule);
    if (func === boolbase.falseFunc)
      return boolbase.falseFunc;
    if (func === boolbase.trueFunc)
      return getChildFunc(next, adapter);
    return function nthLastOfType(elem) {
      const siblings = adapter.getSiblings(elem);
      let pos = 0;
      for (let i = siblings.length - 1; i >= 0; i--) {
        const currentSibling = siblings[i];
        if (equals(elem, currentSibling))
          break;
        if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
          pos++;
        }
      }
      return func(pos) && next(elem);
    };
  },
  // TODO determine the actual root element
  root(next, _rule, { adapter }) {
    return (elem) => {
      const parent = adapter.getParent(elem);
      return (parent == null || !adapter.isTag(parent)) && next(elem);
    };
  },
  scope(next, rule, options, context) {
    const { equals } = options;
    if (!context || context.length === 0) {
      return filters$1["root"](next, rule, options);
    }
    if (context.length === 1) {
      return (elem) => equals(context[0], elem) && next(elem);
    }
    return (elem) => context.includes(elem) && next(elem);
  },
  hover: dynamicStatePseudo("isHovered"),
  visited: dynamicStatePseudo("isVisited"),
  active: dynamicStatePseudo("isActive")
};
function dynamicStatePseudo(name2) {
  return function dynamicPseudo(next, _rule, { adapter }) {
    const func = adapter[name2];
    if (typeof func !== "function") {
      return boolbase.falseFunc;
    }
    return function active(elem) {
      return func(elem) && next(elem);
    };
  };
}
const pseudos = {
  empty(elem, { adapter }) {
    return !adapter.getChildren(elem).some((elem2) => (
      // FIXME: `getText` call is potentially expensive.
      adapter.isTag(elem2) || adapter.getText(elem2) !== ""
    ));
  },
  "first-child"(elem, { adapter, equals }) {
    if (adapter.prevElementSibling) {
      return adapter.prevElementSibling(elem) == null;
    }
    const firstChild = adapter.getSiblings(elem).find((elem2) => adapter.isTag(elem2));
    return firstChild != null && equals(elem, firstChild);
  },
  "last-child"(elem, { adapter, equals }) {
    const siblings = adapter.getSiblings(elem);
    for (let i = siblings.length - 1; i >= 0; i--) {
      if (equals(elem, siblings[i]))
        return true;
      if (adapter.isTag(siblings[i]))
        break;
    }
    return false;
  },
  "first-of-type"(elem, { adapter, equals }) {
    const siblings = adapter.getSiblings(elem);
    const elemName = adapter.getName(elem);
    for (let i = 0; i < siblings.length; i++) {
      const currentSibling = siblings[i];
      if (equals(elem, currentSibling))
        return true;
      if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
        break;
      }
    }
    return false;
  },
  "last-of-type"(elem, { adapter, equals }) {
    const siblings = adapter.getSiblings(elem);
    const elemName = adapter.getName(elem);
    for (let i = siblings.length - 1; i >= 0; i--) {
      const currentSibling = siblings[i];
      if (equals(elem, currentSibling))
        return true;
      if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
        break;
      }
    }
    return false;
  },
  "only-of-type"(elem, { adapter, equals }) {
    const elemName = adapter.getName(elem);
    return adapter.getSiblings(elem).every((sibling) => equals(elem, sibling) || !adapter.isTag(sibling) || adapter.getName(sibling) !== elemName);
  },
  "only-child"(elem, { adapter, equals }) {
    return adapter.getSiblings(elem).every((sibling) => equals(elem, sibling) || !adapter.isTag(sibling));
  }
};
function verifyPseudoArgs(func, name2, subselect, argIndex) {
  if (subselect === null) {
    if (func.length > argIndex) {
      throw new Error(`Pseudo-class :${name2} requires an argument`);
    }
  } else if (func.length === argIndex) {
    throw new Error(`Pseudo-class :${name2} doesn't have any arguments`);
  }
}
const aliases = {
  // Links
  "any-link": ":is(a, area, link)[href]",
  link: ":any-link:not(:visited)",
  // Forms
  // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
  disabled: `:is(
        :is(button, input, select, textarea, optgroup, option)[disabled],
        optgroup[disabled] > option,
        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)
    )`,
  enabled: ":not(:disabled)",
  checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
  required: ":is(input, select, textarea)[required]",
  optional: ":is(input, select, textarea):not([required])",
  // JQuery extensions
  // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
  selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
  checkbox: "[type=checkbox]",
  file: "[type=file]",
  password: "[type=password]",
  radio: "[type=radio]",
  reset: "[type=reset]",
  image: "[type=image]",
  submit: "[type=submit]",
  parent: ":not(:empty)",
  header: ":is(h1, h2, h3, h4, h5, h6)",
  button: ":is(button, input[type=button])",
  input: ":is(input, textarea, select, button)",
  text: "input:is(:not([type!='']), [type=text])"
};
const PLACEHOLDER_ELEMENT = {};
function ensureIsTag(next, adapter) {
  if (next === boolbase.falseFunc)
    return boolbase.falseFunc;
  return (elem) => adapter.isTag(elem) && next(elem);
}
function getNextSiblings(elem, adapter) {
  const siblings = adapter.getSiblings(elem);
  if (siblings.length <= 1)
    return [];
  const elemIndex = siblings.indexOf(elem);
  if (elemIndex < 0 || elemIndex === siblings.length - 1)
    return [];
  return siblings.slice(elemIndex + 1).filter(adapter.isTag);
}
function copyOptions(options) {
  return {
    xmlMode: !!options.xmlMode,
    lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,
    lowerCaseTags: !!options.lowerCaseTags,
    quirksMode: !!options.quirksMode,
    cacheResults: !!options.cacheResults,
    pseudos: options.pseudos,
    adapter: options.adapter,
    equals: options.equals
  };
}
const is$1 = (next, token, options, context, compileToken2) => {
  const func = compileToken2(token, copyOptions(options), context);
  return func === boolbase.trueFunc ? next : func === boolbase.falseFunc ? boolbase.falseFunc : (elem) => func(elem) && next(elem);
};
const subselects = {
  is: is$1,
  /**
   * `:matches` and `:where` are aliases for `:is`.
   */
  matches: is$1,
  where: is$1,
  not(next, token, options, context, compileToken2) {
    const func = compileToken2(token, copyOptions(options), context);
    return func === boolbase.falseFunc ? next : func === boolbase.trueFunc ? boolbase.falseFunc : (elem) => !func(elem) && next(elem);
  },
  has(next, subselect, options, _context, compileToken2) {
    const { adapter } = options;
    const opts = copyOptions(options);
    opts.relativeSelector = true;
    const context = subselect.some((s) => s.some(isTraversal)) ? (
      // Used as a placeholder. Will be replaced with the actual element.
      [PLACEHOLDER_ELEMENT]
    ) : void 0;
    const compiled = compileToken2(subselect, opts, context);
    if (compiled === boolbase.falseFunc)
      return boolbase.falseFunc;
    const hasElement = ensureIsTag(compiled, adapter);
    if (context && compiled !== boolbase.trueFunc) {
      const { shouldTestNextSiblings = false } = compiled;
      return (elem) => {
        if (!next(elem))
          return false;
        context[0] = elem;
        const childs = adapter.getChildren(elem);
        const nextElements = shouldTestNextSiblings ? [...childs, ...getNextSiblings(elem, adapter)] : childs;
        return adapter.existsOne(hasElement, nextElements);
      };
    }
    return (elem) => next(elem) && adapter.existsOne(hasElement, adapter.getChildren(elem));
  }
};
function compilePseudoSelector(next, selector2, options, context, compileToken2) {
  var _a;
  const { name: name2, data } = selector2;
  if (Array.isArray(data)) {
    if (!(name2 in subselects)) {
      throw new Error(`Unknown pseudo-class :${name2}(${data})`);
    }
    return subselects[name2](next, data, options, context, compileToken2);
  }
  const userPseudo = (_a = options.pseudos) === null || _a === void 0 ? void 0 : _a[name2];
  const stringPseudo = typeof userPseudo === "string" ? userPseudo : aliases[name2];
  if (typeof stringPseudo === "string") {
    if (data != null) {
      throw new Error(`Pseudo ${name2} doesn't have any arguments`);
    }
    const alias = parse$1w(stringPseudo);
    return subselects["is"](next, alias, options, context, compileToken2);
  }
  if (typeof userPseudo === "function") {
    verifyPseudoArgs(userPseudo, name2, data, 1);
    return (elem) => userPseudo(elem, data) && next(elem);
  }
  if (name2 in filters$1) {
    return filters$1[name2](next, data, options, context);
  }
  if (name2 in pseudos) {
    const pseudo2 = pseudos[name2];
    verifyPseudoArgs(pseudo2, name2, data, 2);
    return (elem) => pseudo2(elem, options, data) && next(elem);
  }
  throw new Error(`Unknown pseudo-class :${name2}`);
}
function getElementParent(node2, adapter) {
  const parent = adapter.getParent(node2);
  if (parent && adapter.isTag(parent)) {
    return parent;
  }
  return null;
}
function compileGeneralSelector(next, selector2, options, context, compileToken2) {
  const { adapter, equals } = options;
  switch (selector2.type) {
    case SelectorType.PseudoElement: {
      throw new Error("Pseudo-elements are not supported by css-select");
    }
    case SelectorType.ColumnCombinator: {
      throw new Error("Column combinators are not yet supported by css-select");
    }
    case SelectorType.Attribute: {
      if (selector2.namespace != null) {
        throw new Error("Namespaced attributes are not yet supported by css-select");
      }
      if (!options.xmlMode || options.lowerCaseAttributeNames) {
        selector2.name = selector2.name.toLowerCase();
      }
      return attributeRules[selector2.action](next, selector2, options);
    }
    case SelectorType.Pseudo: {
      return compilePseudoSelector(next, selector2, options, context, compileToken2);
    }
    // Tags
    case SelectorType.Tag: {
      if (selector2.namespace != null) {
        throw new Error("Namespaced tag names are not yet supported by css-select");
      }
      let { name: name2 } = selector2;
      if (!options.xmlMode || options.lowerCaseTags) {
        name2 = name2.toLowerCase();
      }
      return function tag(elem) {
        return adapter.getName(elem) === name2 && next(elem);
      };
    }
    // Traversal
    case SelectorType.Descendant: {
      if (options.cacheResults === false || typeof WeakSet === "undefined") {
        return function descendant(elem) {
          let current = elem;
          while (current = getElementParent(current, adapter)) {
            if (next(current)) {
              return true;
            }
          }
          return false;
        };
      }
      const isFalseCache = /* @__PURE__ */ new WeakSet();
      return function cachedDescendant(elem) {
        let current = elem;
        while (current = getElementParent(current, adapter)) {
          if (!isFalseCache.has(current)) {
            if (adapter.isTag(current) && next(current)) {
              return true;
            }
            isFalseCache.add(current);
          }
        }
        return false;
      };
    }
    case "_flexibleDescendant": {
      return function flexibleDescendant(elem) {
        let current = elem;
        do {
          if (next(current))
            return true;
        } while (current = getElementParent(current, adapter));
        return false;
      };
    }
    case SelectorType.Parent: {
      return function parent(elem) {
        return adapter.getChildren(elem).some((elem2) => adapter.isTag(elem2) && next(elem2));
      };
    }
    case SelectorType.Child: {
      return function child(elem) {
        const parent = adapter.getParent(elem);
        return parent != null && adapter.isTag(parent) && next(parent);
      };
    }
    case SelectorType.Sibling: {
      return function sibling(elem) {
        const siblings = adapter.getSiblings(elem);
        for (let i = 0; i < siblings.length; i++) {
          const currentSibling = siblings[i];
          if (equals(elem, currentSibling))
            break;
          if (adapter.isTag(currentSibling) && next(currentSibling)) {
            return true;
          }
        }
        return false;
      };
    }
    case SelectorType.Adjacent: {
      if (adapter.prevElementSibling) {
        return function adjacent(elem) {
          const previous = adapter.prevElementSibling(elem);
          return previous != null && next(previous);
        };
      }
      return function adjacent(elem) {
        const siblings = adapter.getSiblings(elem);
        let lastElement;
        for (let i = 0; i < siblings.length; i++) {
          const currentSibling = siblings[i];
          if (equals(elem, currentSibling))
            break;
          if (adapter.isTag(currentSibling)) {
            lastElement = currentSibling;
          }
        }
        return !!lastElement && next(lastElement);
      };
    }
    case SelectorType.Universal: {
      if (selector2.namespace != null && selector2.namespace !== "*") {
        throw new Error("Namespaced universal selectors are not yet supported by css-select");
      }
      return next;
    }
  }
}
function compile(selector2, options, context) {
  const next = compileUnsafe(selector2, options, context);
  return ensureIsTag(next, options.adapter);
}
function compileUnsafe(selector2, options, context) {
  const token = typeof selector2 === "string" ? parse$1w(selector2) : selector2;
  return compileToken(token, options, context);
}
function includesScopePseudo(t) {
  return t.type === SelectorType.Pseudo && (t.name === "scope" || Array.isArray(t.data) && t.data.some((data) => data.some(includesScopePseudo)));
}
const DESCENDANT_TOKEN = { type: SelectorType.Descendant };
const FLEXIBLE_DESCENDANT_TOKEN = {
  type: "_flexibleDescendant"
};
const SCOPE_TOKEN = {
  type: SelectorType.Pseudo,
  name: "scope",
  data: null
};
function absolutize(token, { adapter }, context) {
  const hasContext = !!(context === null || context === void 0 ? void 0 : context.every((e) => {
    const parent = adapter.isTag(e) && adapter.getParent(e);
    return e === PLACEHOLDER_ELEMENT || parent && adapter.isTag(parent);
  }));
  for (const t of token) {
    if (t.length > 0 && isTraversal(t[0]) && t[0].type !== SelectorType.Descendant) ;
    else if (hasContext && !t.some(includesScopePseudo)) {
      t.unshift(DESCENDANT_TOKEN);
    } else {
      continue;
    }
    t.unshift(SCOPE_TOKEN);
  }
}
function compileToken(token, options, context) {
  var _a;
  token.forEach(sortByProcedure);
  context = (_a = options.context) !== null && _a !== void 0 ? _a : context;
  const isArrayContext = Array.isArray(context);
  const finalContext = context && (Array.isArray(context) ? context : [context]);
  if (options.relativeSelector !== false) {
    absolutize(token, options, finalContext);
  } else if (token.some((t) => t.length > 0 && isTraversal(t[0]))) {
    throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");
  }
  let shouldTestNextSiblings = false;
  const query = token.map((rules) => {
    if (rules.length >= 2) {
      const [first, second] = rules;
      if (first.type !== SelectorType.Pseudo || first.name !== "scope") ;
      else if (isArrayContext && second.type === SelectorType.Descendant) {
        rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
      } else if (second.type === SelectorType.Adjacent || second.type === SelectorType.Sibling) {
        shouldTestNextSiblings = true;
      }
    }
    return compileRules(rules, options, finalContext);
  }).reduce(reduceRules, boolbase.falseFunc);
  query.shouldTestNextSiblings = shouldTestNextSiblings;
  return query;
}
function compileRules(rules, options, context) {
  var _a;
  return rules.reduce((previous, rule) => previous === boolbase.falseFunc ? boolbase.falseFunc : compileGeneralSelector(previous, rule, options, context, compileToken), (_a = options.rootFunc) !== null && _a !== void 0 ? _a : boolbase.trueFunc);
}
function reduceRules(a, b) {
  if (b === boolbase.falseFunc || a === boolbase.trueFunc) {
    return a;
  }
  if (a === boolbase.falseFunc || b === boolbase.trueFunc) {
    return b;
  }
  return function combine(elem) {
    return a(elem) || b(elem);
  };
}
const defaultEquals = (a, b) => a === b;
const defaultOptions = {
  adapter: DomUtils,
  equals: defaultEquals
};
function convertOptionFormats(options) {
  var _a, _b, _c, _d;
  const opts = options !== null && options !== void 0 ? options : defaultOptions;
  (_a = opts.adapter) !== null && _a !== void 0 ? _a : opts.adapter = DomUtils;
  (_b = opts.equals) !== null && _b !== void 0 ? _b : opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals;
  return opts;
}
function getSelectorFunc(searchFunc) {
  return function select(query, elements, options) {
    const opts = convertOptionFormats(options);
    if (typeof query !== "function") {
      query = compileUnsafe(query, opts, elements);
    }
    const filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);
    return searchFunc(query, filteredElements, opts);
  };
}
function prepareContext(elems2, adapter, shouldTestNextSiblings = false) {
  if (shouldTestNextSiblings) {
    elems2 = appendNextSiblings(elems2, adapter);
  }
  return Array.isArray(elems2) ? adapter.removeSubsets(elems2) : adapter.getChildren(elems2);
}
function appendNextSiblings(elem, adapter) {
  const elems2 = Array.isArray(elem) ? elem.slice(0) : [elem];
  const elemsLength = elems2.length;
  for (let i = 0; i < elemsLength; i++) {
    const nextSiblings = getNextSiblings(elems2[i], adapter);
    elems2.push(...nextSiblings);
  }
  return elems2;
}
const selectAll = getSelectorFunc((query, elems2, options) => query === boolbase.falseFunc || !elems2 || elems2.length === 0 ? [] : options.adapter.findAll(query, elems2));
const selectOne = getSelectorFunc((query, elems2, options) => query === boolbase.falseFunc || !elems2 || elems2.length === 0 ? null : options.adapter.findOne(query, elems2));
function is(elem, query, options) {
  const opts = convertOptionFormats(options);
  return (typeof query === "function" ? query : compile(query, opts))(elem);
}
function mapNodesToParents(node2) {
  const parents = /* @__PURE__ */ new Map();
  for (const child of node2.children) {
    parents.set(child, node2);
    visit(
      child,
      {
        element: {
          enter: (child2, parent) => {
            parents.set(child2, parent);
          }
        }
      },
      node2
    );
  }
  return parents;
}
const isTag = (node2) => {
  return node2.type === "element";
};
const existsOne = (test, elems2) => {
  return elems2.some((elem) => {
    return isTag(elem) && (test(elem) || existsOne(test, getChildren(elem)));
  });
};
const getAttributeValue = (elem, name2) => {
  return elem.attributes[name2];
};
const getChildren = (node2) => {
  return node2.children || [];
};
const getName = (elemAst) => {
  return elemAst.name;
};
const getText = (node2) => {
  if (node2.children[0].type === "text" || node2.children[0].type === "cdata") {
    return node2.children[0].value;
  }
  return "";
};
const hasAttrib = (elem, name2) => {
  return elem.attributes[name2] !== void 0;
};
const findAll$3 = (test, elems2) => {
  const result = [];
  for (const elem of elems2) {
    if (isTag(elem)) {
      if (test(elem)) {
        result.push(elem);
      }
      result.push(...findAll$3(test, getChildren(elem)));
    }
  }
  return result;
};
const findOne = (test, elems2) => {
  for (const elem of elems2) {
    if (isTag(elem)) {
      if (test(elem)) {
        return elem;
      }
      const result = findOne(test, getChildren(elem));
      if (result) {
        return result;
      }
    }
  }
  return null;
};
function createAdapter(relativeNode, parents) {
  const getParent2 = (node2) => {
    if (!parents) {
      parents = mapNodesToParents(relativeNode);
    }
    return parents.get(node2) || null;
  };
  const getSiblings2 = (elem) => {
    const parent = getParent2(elem);
    return parent ? getChildren(parent) : [];
  };
  const removeSubsets2 = (nodes) => {
    let idx = nodes.length;
    let node2;
    let ancestor;
    let replace2;
    while (--idx > -1) {
      node2 = ancestor = nodes[idx];
      nodes[idx] = null;
      replace2 = true;
      while (ancestor) {
        if (nodes.includes(ancestor)) {
          replace2 = false;
          nodes.splice(idx, 1);
          break;
        }
        ancestor = getParent2(ancestor);
      }
      if (replace2) {
        nodes[idx] = node2;
      }
    }
    return nodes;
  };
  return {
    isTag,
    existsOne,
    getAttributeValue,
    getChildren,
    getName,
    getParent: getParent2,
    getSiblings: getSiblings2,
    getText,
    hasAttrib,
    removeSubsets: removeSubsets2,
    findAll: findAll$3,
    findOne
  };
}
function createCssSelectOptions(relativeNode, parents) {
  return {
    xmlMode: true,
    adapter: createAdapter(relativeNode, parents)
  };
}
const querySelectorAll = (node2, selector2, parents) => {
  return selectAll(selector2, node2, createCssSelectOptions(node2, parents));
};
const querySelector = (node2, selector2, parents) => {
  return selectOne(selector2, node2, createCssSelectOptions(node2, parents));
};
const matches = (node2, selector2, parents) => {
  return is(node2, selector2, createCssSelectOptions(node2, parents));
};
const detachNodeFromParent = (node2, parentNode) => {
  parentNode.children = parentNode.children.filter((child) => child !== node2);
};
const name$2d = "removeDoctype";
const description$Q = "removes doctype declaration";
const fn$Q = () => {
  return {
    doctype: {
      enter: (node2, parentNode) => {
        detachNodeFromParent(node2, parentNode);
      }
    }
  };
};
const removeDoctype = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$Q,
  fn: fn$Q,
  name: name$2d
}, Symbol.toStringTag, { value: "Module" }));
const name$2c = "removeXMLProcInst";
const description$P = "removes XML processing instructions";
const fn$P = () => {
  return {
    instruction: {
      enter: (node2, parentNode) => {
        if (node2.name === "xml") {
          detachNodeFromParent(node2, parentNode);
        }
      }
    }
  };
};
const removeXMLProcInst = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$P,
  fn: fn$P,
  name: name$2c
}, Symbol.toStringTag, { value: "Module" }));
const name$2b = "removeComments";
const description$O = "removes comments";
const DEFAULT_PRESERVE_PATTERNS = [/^!/];
const fn$O = (_root, params) => {
  const { preservePatterns = DEFAULT_PRESERVE_PATTERNS } = params;
  return {
    comment: {
      enter: (node2, parentNode) => {
        if (preservePatterns) {
          if (!Array.isArray(preservePatterns)) {
            throw Error(
              `Expected array in removeComments preservePatterns parameter but received ${preservePatterns}`
            );
          }
          const matches2 = preservePatterns.some((pattern) => {
            return new RegExp(pattern).test(node2.value);
          });
          if (matches2) {
            return;
          }
        }
        detachNodeFromParent(node2, parentNode);
      }
    }
  };
};
const removeComments = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$O,
  fn: fn$O,
  name: name$2b
}, Symbol.toStringTag, { value: "Module" }));
const elemsGroups = {
  animation: /* @__PURE__ */ new Set([
    "animate",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "set"
  ]),
  descriptive: /* @__PURE__ */ new Set(["desc", "metadata", "title"]),
  shape: /* @__PURE__ */ new Set([
    "circle",
    "ellipse",
    "line",
    "path",
    "polygon",
    "polyline",
    "rect"
  ]),
  structural: /* @__PURE__ */ new Set(["defs", "g", "svg", "symbol", "use"]),
  paintServer: /* @__PURE__ */ new Set([
    "hatch",
    "linearGradient",
    "meshGradient",
    "pattern",
    "radialGradient",
    "solidColor"
  ]),
  nonRendering: /* @__PURE__ */ new Set([
    "clipPath",
    "filter",
    "linearGradient",
    "marker",
    "mask",
    "pattern",
    "radialGradient",
    "solidColor",
    "symbol"
  ]),
  container: /* @__PURE__ */ new Set([
    "a",
    "defs",
    "foreignObject",
    "g",
    "marker",
    "mask",
    "missing-glyph",
    "pattern",
    "svg",
    "switch",
    "symbol"
  ]),
  textContent: /* @__PURE__ */ new Set([
    "a",
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "glyph",
    "glyphRef",
    "text",
    "textPath",
    "tref",
    "tspan"
  ]),
  textContentChild: /* @__PURE__ */ new Set(["altGlyph", "textPath", "tref", "tspan"]),
  lightSource: /* @__PURE__ */ new Set([
    "feDiffuseLighting",
    "feDistantLight",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight"
  ]),
  filterPrimitive: /* @__PURE__ */ new Set([
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "feSpecularLighting",
    "feTile",
    "feTurbulence"
  ])
};
/* @__PURE__ */ new Set([...elemsGroups.textContent, "pre", "title"]);
const pathElems = /* @__PURE__ */ new Set(["glyph", "missing-glyph", "path"]);
const attrsGroups = {
  animationAddition: /* @__PURE__ */ new Set(["additive", "accumulate"]),
  animationAttributeTarget: /* @__PURE__ */ new Set(["attributeType", "attributeName"]),
  animationEvent: /* @__PURE__ */ new Set(["onbegin", "onend", "onrepeat", "onload"]),
  animationTiming: /* @__PURE__ */ new Set([
    "begin",
    "dur",
    "end",
    "fill",
    "max",
    "min",
    "repeatCount",
    "repeatDur",
    "restart"
  ]),
  animationValue: /* @__PURE__ */ new Set([
    "by",
    "calcMode",
    "from",
    "keySplines",
    "keyTimes",
    "to",
    "values"
  ]),
  conditionalProcessing: /* @__PURE__ */ new Set([
    "requiredExtensions",
    "requiredFeatures",
    "systemLanguage"
  ]),
  core: /* @__PURE__ */ new Set(["id", "tabindex", "xml:base", "xml:lang", "xml:space"]),
  graphicalEvent: /* @__PURE__ */ new Set([
    "onactivate",
    "onclick",
    "onfocusin",
    "onfocusout",
    "onload",
    "onmousedown",
    "onmousemove",
    "onmouseout",
    "onmouseover",
    "onmouseup"
  ]),
  presentation: /* @__PURE__ */ new Set([
    "alignment-baseline",
    "baseline-shift",
    "clip-path",
    "clip-rule",
    "clip",
    "color-interpolation-filters",
    "color-interpolation",
    "color-profile",
    "color-rendering",
    "color",
    "cursor",
    "direction",
    "display",
    "dominant-baseline",
    "enable-background",
    "fill-opacity",
    "fill-rule",
    "fill",
    "filter",
    "flood-color",
    "flood-opacity",
    "font-family",
    "font-size-adjust",
    "font-size",
    "font-stretch",
    "font-style",
    "font-variant",
    "font-weight",
    "glyph-orientation-horizontal",
    "glyph-orientation-vertical",
    "image-rendering",
    "letter-spacing",
    "lighting-color",
    "marker-end",
    "marker-mid",
    "marker-start",
    "mask",
    "opacity",
    "overflow",
    "paint-order",
    "pointer-events",
    "shape-rendering",
    "stop-color",
    "stop-opacity",
    "stroke-dasharray",
    "stroke-dashoffset",
    "stroke-linecap",
    "stroke-linejoin",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke-width",
    "stroke",
    "text-anchor",
    "text-decoration",
    "text-overflow",
    "text-rendering",
    "transform-origin",
    "transform",
    "unicode-bidi",
    "vector-effect",
    "visibility",
    "word-spacing",
    "writing-mode"
  ]),
  xlink: /* @__PURE__ */ new Set([
    "xlink:actuate",
    "xlink:arcrole",
    "xlink:href",
    "xlink:role",
    "xlink:show",
    "xlink:title",
    "xlink:type"
  ]),
  documentEvent: /* @__PURE__ */ new Set([
    "onabort",
    "onerror",
    "onresize",
    "onscroll",
    "onunload",
    "onzoom"
  ]),
  documentElementEvent: /* @__PURE__ */ new Set(["oncopy", "oncut", "onpaste"]),
  globalEvent: /* @__PURE__ */ new Set([
    "oncancel",
    "oncanplay",
    "oncanplaythrough",
    "onchange",
    "onclick",
    "onclose",
    "oncuechange",
    "ondblclick",
    "ondrag",
    "ondragend",
    "ondragenter",
    "ondragleave",
    "ondragover",
    "ondragstart",
    "ondrop",
    "ondurationchange",
    "onemptied",
    "onended",
    "onerror",
    "onfocus",
    "oninput",
    "oninvalid",
    "onkeydown",
    "onkeypress",
    "onkeyup",
    "onload",
    "onloadeddata",
    "onloadedmetadata",
    "onloadstart",
    "onmousedown",
    "onmouseenter",
    "onmouseleave",
    "onmousemove",
    "onmouseout",
    "onmouseover",
    "onmouseup",
    "onmousewheel",
    "onpause",
    "onplay",
    "onplaying",
    "onprogress",
    "onratechange",
    "onreset",
    "onresize",
    "onscroll",
    "onseeked",
    "onseeking",
    "onselect",
    "onshow",
    "onstalled",
    "onsubmit",
    "onsuspend",
    "ontimeupdate",
    "ontoggle",
    "onvolumechange",
    "onwaiting"
  ]),
  filterPrimitive: /* @__PURE__ */ new Set(["x", "y", "width", "height", "result"]),
  transferFunction: /* @__PURE__ */ new Set([
    "amplitude",
    "exponent",
    "intercept",
    "offset",
    "slope",
    "tableValues",
    "type"
  ])
};
const attrsGroupsDefaults = {
  core: { "xml:space": "default" },
  presentation: {
    clip: "auto",
    "clip-path": "none",
    "clip-rule": "nonzero",
    mask: "none",
    opacity: "1",
    "stop-color": "#000",
    "stop-opacity": "1",
    "fill-opacity": "1",
    "fill-rule": "nonzero",
    fill: "#000",
    stroke: "none",
    "stroke-width": "1",
    "stroke-linecap": "butt",
    "stroke-linejoin": "miter",
    "stroke-miterlimit": "4",
    "stroke-dasharray": "none",
    "stroke-dashoffset": "0",
    "stroke-opacity": "1",
    "paint-order": "normal",
    "vector-effect": "none",
    display: "inline",
    visibility: "visible",
    "marker-start": "none",
    "marker-mid": "none",
    "marker-end": "none",
    "color-interpolation": "sRGB",
    "color-interpolation-filters": "linearRGB",
    "color-rendering": "auto",
    "shape-rendering": "auto",
    "text-rendering": "auto",
    "image-rendering": "auto",
    "font-style": "normal",
    "font-variant": "normal",
    "font-weight": "normal",
    "font-stretch": "normal",
    "font-size": "medium",
    "font-size-adjust": "none",
    kerning: "auto",
    "letter-spacing": "normal",
    "word-spacing": "normal",
    "text-decoration": "none",
    "text-anchor": "start",
    "text-overflow": "clip",
    "writing-mode": "lr-tb",
    "glyph-orientation-vertical": "auto",
    "glyph-orientation-horizontal": "0deg",
    direction: "ltr",
    "unicode-bidi": "normal",
    "dominant-baseline": "auto",
    "alignment-baseline": "baseline",
    "baseline-shift": "baseline"
  },
  transferFunction: {
    slope: "1",
    intercept: "0",
    amplitude: "1",
    exponent: "1",
    offset: "0"
  }
};
const attrsGroupsDeprecated = {
  animationAttributeTarget: { unsafe: /* @__PURE__ */ new Set(["attributeType"]) },
  conditionalProcessing: { unsafe: /* @__PURE__ */ new Set(["requiredFeatures"]) },
  core: { unsafe: /* @__PURE__ */ new Set(["xml:base", "xml:lang", "xml:space"]) },
  presentation: {
    unsafe: /* @__PURE__ */ new Set([
      "clip",
      "color-profile",
      "enable-background",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "kerning"
    ])
  }
};
const elems = {
  a: {
    attrsGroups: /* @__PURE__ */ new Set([
      "conditionalProcessing",
      "core",
      "graphicalEvent",
      "presentation",
      "xlink"
    ]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "externalResourcesRequired",
      "style",
      "target",
      "transform"
    ]),
    defaults: {
      target: "_self"
    },
    contentGroups: /* @__PURE__ */ new Set([
      "animation",
      "descriptive",
      "paintServer",
      "shape",
      "structural"
    ]),
    content: /* @__PURE__ */ new Set([
      "a",
      "altGlyphDef",
      "clipPath",
      "color-profile",
      "cursor",
      "filter",
      "font-face",
      "font",
      "foreignObject",
      "image",
      "marker",
      "mask",
      "pattern",
      "script",
      "style",
      "switch",
      "text",
      "view",
      // not spec compliant
      "tspan"
    ])
  },
  altGlyph: {
    attrsGroups: /* @__PURE__ */ new Set([
      "conditionalProcessing",
      "core",
      "graphicalEvent",
      "presentation",
      "xlink"
    ]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "dx",
      "dy",
      "externalResourcesRequired",
      "format",
      "glyphRef",
      "rotate",
      "style",
      "x",
      "y"
    ])
  },
  altGlyphDef: {
    attrsGroups: /* @__PURE__ */ new Set(["core"]),
    content: /* @__PURE__ */ new Set(["glyphRef"])
  },
  altGlyphItem: {
    attrsGroups: /* @__PURE__ */ new Set(["core"]),
    content: /* @__PURE__ */ new Set(["glyphRef", "altGlyphItem"])
  },
  animate: {
    attrsGroups: /* @__PURE__ */ new Set([
      "animationAddition",
      "animationAttributeTarget",
      "animationEvent",
      "animationTiming",
      "animationValue",
      "conditionalProcessing",
      "core",
      "presentation",
      "xlink"
    ]),
    attrs: /* @__PURE__ */ new Set(["externalResourcesRequired"]),
    contentGroups: /* @__PURE__ */ new Set(["descriptive"])
  },
  animateColor: {
    attrsGroups: /* @__PURE__ */ new Set([
      "animationAddition",
      "animationAttributeTarget",
      "animationEvent",
      "animationTiming",
      "animationValue",
      "conditionalProcessing",
      "core",
      "presentation",
      "xlink"
    ]),
    attrs: /* @__PURE__ */ new Set(["externalResourcesRequired"]),
    contentGroups: /* @__PURE__ */ new Set(["descriptive"])
  },
  animateMotion: {
    attrsGroups: /* @__PURE__ */ new Set([
      "animationAddition",
      "animationEvent",
      "animationTiming",
      "animationValue",
      "conditionalProcessing",
      "core",
      "xlink"
    ]),
    attrs: /* @__PURE__ */ new Set([
      "externalResourcesRequired",
      "keyPoints",
      "origin",
      "path",
      "rotate"
    ]),
    defaults: {
      rotate: "0"
    },
    contentGroups: /* @__PURE__ */ new Set(["descriptive"]),
    content: /* @__PURE__ */ new Set(["mpath"])
  },
  animateTransform: {
    attrsGroups: /* @__PURE__ */ new Set([
      "animationAddition",
      "animationAttributeTarget",
      "animationEvent",
      "animationTiming",
      "animationValue",
      "conditionalProcessing",
      "core",
      "xlink"
    ]),
    attrs: /* @__PURE__ */ new Set(["externalResourcesRequired", "type"]),
    contentGroups: /* @__PURE__ */ new Set(["descriptive"])
  },
  circle: {
    attrsGroups: /* @__PURE__ */ new Set([
      "conditionalProcessing",
      "core",
      "graphicalEvent",
      "presentation"
    ]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "cx",
      "cy",
      "externalResourcesRequired",
      "r",
      "style",
      "transform"
    ]),
    defaults: {
      cx: "0",
      cy: "0"
    },
    contentGroups: /* @__PURE__ */ new Set(["animation", "descriptive"])
  },
  clipPath: {
    attrsGroups: /* @__PURE__ */ new Set(["conditionalProcessing", "core", "presentation"]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "clipPathUnits",
      "externalResourcesRequired",
      "style",
      "transform"
    ]),
    defaults: {
      clipPathUnits: "userSpaceOnUse"
    },
    contentGroups: /* @__PURE__ */ new Set(["animation", "descriptive", "shape"]),
    content: /* @__PURE__ */ new Set(["text", "use"])
  },
  "color-profile": {
    attrsGroups: /* @__PURE__ */ new Set(["core", "xlink"]),
    attrs: /* @__PURE__ */ new Set(["local", "name", "rendering-intent"]),
    defaults: {
      name: "sRGB",
      "rendering-intent": "auto"
    },
    deprecated: { unsafe: /* @__PURE__ */ new Set(["name"]) },
    contentGroups: /* @__PURE__ */ new Set(["descriptive"])
  },
  cursor: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "conditionalProcessing", "xlink"]),
    attrs: /* @__PURE__ */ new Set(["externalResourcesRequired", "x", "y"]),
    defaults: {
      x: "0",
      y: "0"
    },
    contentGroups: /* @__PURE__ */ new Set(["descriptive"])
  },
  defs: {
    attrsGroups: /* @__PURE__ */ new Set([
      "conditionalProcessing",
      "core",
      "graphicalEvent",
      "presentation"
    ]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "externalResourcesRequired",
      "style",
      "transform"
    ]),
    contentGroups: /* @__PURE__ */ new Set([
      "animation",
      "descriptive",
      "paintServer",
      "shape",
      "structural"
    ]),
    content: /* @__PURE__ */ new Set([
      "a",
      "altGlyphDef",
      "clipPath",
      "color-profile",
      "cursor",
      "filter",
      "font-face",
      "font",
      "foreignObject",
      "image",
      "marker",
      "mask",
      "pattern",
      "script",
      "style",
      "switch",
      "text",
      "view"
    ])
  },
  desc: {
    attrsGroups: /* @__PURE__ */ new Set(["core"]),
    attrs: /* @__PURE__ */ new Set(["class", "style"])
  },
  ellipse: {
    attrsGroups: /* @__PURE__ */ new Set([
      "conditionalProcessing",
      "core",
      "graphicalEvent",
      "presentation"
    ]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "cx",
      "cy",
      "externalResourcesRequired",
      "rx",
      "ry",
      "style",
      "transform"
    ]),
    defaults: {
      cx: "0",
      cy: "0"
    },
    contentGroups: /* @__PURE__ */ new Set(["animation", "descriptive"])
  },
  feBlend: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "style",
      // TODO: in - 'If no value is provided and this is the first filter primitive,
      // then this filter primitive will use SourceGraphic as its input'
      "in",
      "in2",
      "mode"
    ]),
    defaults: {
      mode: "normal"
    },
    content: /* @__PURE__ */ new Set(["animate", "set"])
  },
  feColorMatrix: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
    attrs: /* @__PURE__ */ new Set(["class", "style", "in", "type", "values"]),
    defaults: {
      type: "matrix"
    },
    content: /* @__PURE__ */ new Set(["animate", "set"])
  },
  feComponentTransfer: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
    attrs: /* @__PURE__ */ new Set(["class", "style", "in"]),
    content: /* @__PURE__ */ new Set(["feFuncA", "feFuncB", "feFuncG", "feFuncR"])
  },
  feComposite: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "in",
      "in2",
      "k1",
      "k2",
      "k3",
      "k4",
      "operator",
      "style"
    ]),
    defaults: {
      operator: "over",
      k1: "0",
      k2: "0",
      k3: "0",
      k4: "0"
    },
    content: /* @__PURE__ */ new Set(["animate", "set"])
  },
  feConvolveMatrix: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "in",
      "kernelMatrix",
      "order",
      "style",
      // TODO: divisor - 'The default value is the sum of all values in kernelMatrix,
      // with the exception that if the sum is zero, then the divisor is set to 1'
      "bias",
      "divisor",
      // TODO: targetX - 'By default, the convolution matrix is centered in X over each
      // pixel of the input image (i.e., targetX = floor ( orderX / 2 ))'
      "edgeMode",
      "targetX",
      "targetY",
      // TODO: kernelUnitLength - 'The first number is the <dx> value. The second number
      // is the <dy> value. If the <dy> value is not specified, it defaults to the same value as <dx>'
      "kernelUnitLength",
      "preserveAlpha"
    ]),
    defaults: {
      order: "3",
      bias: "0",
      edgeMode: "duplicate",
      preserveAlpha: "false"
    },
    content: /* @__PURE__ */ new Set(["animate", "set"])
  },
  feDiffuseLighting: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "diffuseConstant",
      "in",
      "kernelUnitLength",
      "style",
      "surfaceScale"
    ]),
    defaults: {
      surfaceScale: "1",
      diffuseConstant: "1"
    },
    contentGroups: /* @__PURE__ */ new Set(["descriptive"]),
    content: /* @__PURE__ */ new Set([
      // TODO: 'exactly one light source element, in any order'
      "feDistantLight",
      "fePointLight",
      "feSpotLight"
    ])
  },
  feDisplacementMap: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "in",
      "in2",
      "scale",
      "style",
      "xChannelSelector",
      "yChannelSelector"
    ]),
    defaults: {
      scale: "0",
      xChannelSelector: "A",
      yChannelSelector: "A"
    },
    content: /* @__PURE__ */ new Set(["animate", "set"])
  },
  feDistantLight: {
    attrsGroups: /* @__PURE__ */ new Set(["core"]),
    attrs: /* @__PURE__ */ new Set(["azimuth", "elevation"]),
    defaults: {
      azimuth: "0",
      elevation: "0"
    },
    content: /* @__PURE__ */ new Set(["animate", "set"])
  },
  feFlood: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
    attrs: /* @__PURE__ */ new Set(["class", "style"]),
    content: /* @__PURE__ */ new Set(["animate", "animateColor", "set"])
  },
  feFuncA: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "transferFunction"]),
    content: /* @__PURE__ */ new Set(["set", "animate"])
  },
  feFuncB: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "transferFunction"]),
    content: /* @__PURE__ */ new Set(["set", "animate"])
  },
  feFuncG: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "transferFunction"]),
    content: /* @__PURE__ */ new Set(["set", "animate"])
  },
  feFuncR: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "transferFunction"]),
    content: /* @__PURE__ */ new Set(["set", "animate"])
  },
  feGaussianBlur: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
    attrs: /* @__PURE__ */ new Set(["class", "style", "in", "stdDeviation"]),
    defaults: {
      stdDeviation: "0"
    },
    content: /* @__PURE__ */ new Set(["set", "animate"])
  },
  feImage: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive", "xlink"]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "externalResourcesRequired",
      "href",
      "preserveAspectRatio",
      "style",
      "xlink:href"
    ]),
    defaults: {
      preserveAspectRatio: "xMidYMid meet"
    },
    content: /* @__PURE__ */ new Set(["animate", "animateTransform", "set"])
  },
  feMerge: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
    attrs: /* @__PURE__ */ new Set(["class", "style"]),
    content: /* @__PURE__ */ new Set(["feMergeNode"])
  },
  feMergeNode: {
    attrsGroups: /* @__PURE__ */ new Set(["core"]),
    attrs: /* @__PURE__ */ new Set(["in"]),
    content: /* @__PURE__ */ new Set(["animate", "set"])
  },
  feMorphology: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
    attrs: /* @__PURE__ */ new Set(["class", "style", "in", "operator", "radius"]),
    defaults: {
      operator: "erode",
      radius: "0"
    },
    content: /* @__PURE__ */ new Set(["animate", "set"])
  },
  feOffset: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
    attrs: /* @__PURE__ */ new Set(["class", "style", "in", "dx", "dy"]),
    defaults: {
      dx: "0",
      dy: "0"
    },
    content: /* @__PURE__ */ new Set(["animate", "set"])
  },
  fePointLight: {
    attrsGroups: /* @__PURE__ */ new Set(["core"]),
    attrs: /* @__PURE__ */ new Set(["x", "y", "z"]),
    defaults: {
      x: "0",
      y: "0",
      z: "0"
    },
    content: /* @__PURE__ */ new Set(["animate", "set"])
  },
  feSpecularLighting: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "in",
      "kernelUnitLength",
      "specularConstant",
      "specularExponent",
      "style",
      "surfaceScale"
    ]),
    defaults: {
      surfaceScale: "1",
      specularConstant: "1",
      specularExponent: "1"
    },
    contentGroups: /* @__PURE__ */ new Set([
      "descriptive",
      // TODO: exactly one 'light source element'
      "lightSource"
    ])
  },
  feSpotLight: {
    attrsGroups: /* @__PURE__ */ new Set(["core"]),
    attrs: /* @__PURE__ */ new Set([
      "limitingConeAngle",
      "pointsAtX",
      "pointsAtY",
      "pointsAtZ",
      "specularExponent",
      "x",
      "y",
      "z"
    ]),
    defaults: {
      x: "0",
      y: "0",
      z: "0",
      pointsAtX: "0",
      pointsAtY: "0",
      pointsAtZ: "0",
      specularExponent: "1"
    },
    content: /* @__PURE__ */ new Set(["animate", "set"])
  },
  feTile: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
    attrs: /* @__PURE__ */ new Set(["class", "style", "in"]),
    content: /* @__PURE__ */ new Set(["animate", "set"])
  },
  feTurbulence: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
    attrs: /* @__PURE__ */ new Set([
      "baseFrequency",
      "class",
      "numOctaves",
      "seed",
      "stitchTiles",
      "style",
      "type"
    ]),
    defaults: {
      baseFrequency: "0",
      numOctaves: "1",
      seed: "0",
      stitchTiles: "noStitch",
      type: "turbulence"
    },
    content: /* @__PURE__ */ new Set(["animate", "set"])
  },
  filter: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "xlink"]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "externalResourcesRequired",
      "filterRes",
      "filterUnits",
      "height",
      "href",
      "primitiveUnits",
      "style",
      "width",
      "x",
      "xlink:href",
      "y"
    ]),
    defaults: {
      primitiveUnits: "userSpaceOnUse",
      x: "-10%",
      y: "-10%",
      width: "120%",
      height: "120%"
    },
    deprecated: { unsafe: /* @__PURE__ */ new Set(["filterRes"]) },
    contentGroups: /* @__PURE__ */ new Set(["descriptive", "filterPrimitive"]),
    content: /* @__PURE__ */ new Set(["animate", "set"])
  },
  font: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation"]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "externalResourcesRequired",
      "horiz-adv-x",
      "horiz-origin-x",
      "horiz-origin-y",
      "style",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y"
    ]),
    defaults: {
      "horiz-origin-x": "0",
      "horiz-origin-y": "0"
    },
    deprecated: {
      unsafe: /* @__PURE__ */ new Set([
        "horiz-origin-x",
        "horiz-origin-y",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y"
      ])
    },
    contentGroups: /* @__PURE__ */ new Set(["descriptive"]),
    content: /* @__PURE__ */ new Set(["font-face", "glyph", "hkern", "missing-glyph", "vkern"])
  },
  "font-face": {
    attrsGroups: /* @__PURE__ */ new Set(["core"]),
    attrs: /* @__PURE__ */ new Set([
      "font-family",
      "font-style",
      "font-variant",
      "font-weight",
      "font-stretch",
      "font-size",
      "unicode-range",
      "units-per-em",
      "panose-1",
      "stemv",
      "stemh",
      "slope",
      "cap-height",
      "x-height",
      "accent-height",
      "ascent",
      "descent",
      "widths",
      "bbox",
      "ideographic",
      "alphabetic",
      "mathematical",
      "hanging",
      "v-ideographic",
      "v-alphabetic",
      "v-mathematical",
      "v-hanging",
      "underline-position",
      "underline-thickness",
      "strikethrough-position",
      "strikethrough-thickness",
      "overline-position",
      "overline-thickness"
    ]),
    defaults: {
      "font-style": "all",
      "font-variant": "normal",
      "font-weight": "all",
      "font-stretch": "normal",
      "unicode-range": "U+0-10FFFF",
      "units-per-em": "1000",
      "panose-1": "0 0 0 0 0 0 0 0 0 0",
      slope: "0"
    },
    deprecated: {
      unsafe: /* @__PURE__ */ new Set([
        "accent-height",
        "alphabetic",
        "ascent",
        "bbox",
        "cap-height",
        "descent",
        "hanging",
        "ideographic",
        "mathematical",
        "panose-1",
        "slope",
        "stemh",
        "stemv",
        "unicode-range",
        "units-per-em",
        "v-alphabetic",
        "v-hanging",
        "v-ideographic",
        "v-mathematical",
        "widths",
        "x-height"
      ])
    },
    contentGroups: /* @__PURE__ */ new Set(["descriptive"]),
    content: /* @__PURE__ */ new Set([
      // TODO: "at most one 'font-face-src' element"
      "font-face-src"
    ])
  },
  // TODO: empty content
  "font-face-format": {
    attrsGroups: /* @__PURE__ */ new Set(["core"]),
    attrs: /* @__PURE__ */ new Set(["string"]),
    deprecated: { unsafe: /* @__PURE__ */ new Set(["string"]) }
  },
  "font-face-name": {
    attrsGroups: /* @__PURE__ */ new Set(["core"]),
    attrs: /* @__PURE__ */ new Set(["name"]),
    deprecated: { unsafe: /* @__PURE__ */ new Set(["name"]) }
  },
  "font-face-src": {
    attrsGroups: /* @__PURE__ */ new Set(["core"]),
    content: /* @__PURE__ */ new Set(["font-face-name", "font-face-uri"])
  },
  "font-face-uri": {
    attrsGroups: /* @__PURE__ */ new Set(["core", "xlink"]),
    attrs: /* @__PURE__ */ new Set(["href", "xlink:href"]),
    content: /* @__PURE__ */ new Set(["font-face-format"])
  },
  foreignObject: {
    attrsGroups: /* @__PURE__ */ new Set([
      "conditionalProcessing",
      "core",
      "graphicalEvent",
      "presentation"
    ]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "externalResourcesRequired",
      "height",
      "style",
      "transform",
      "width",
      "x",
      "y"
    ]),
    defaults: {
      x: "0",
      y: "0"
    }
  },
  g: {
    attrsGroups: /* @__PURE__ */ new Set([
      "conditionalProcessing",
      "core",
      "graphicalEvent",
      "presentation"
    ]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "externalResourcesRequired",
      "style",
      "transform"
    ]),
    contentGroups: /* @__PURE__ */ new Set([
      "animation",
      "descriptive",
      "paintServer",
      "shape",
      "structural"
    ]),
    content: /* @__PURE__ */ new Set([
      "a",
      "altGlyphDef",
      "clipPath",
      "color-profile",
      "cursor",
      "filter",
      "font-face",
      "font",
      "foreignObject",
      "image",
      "marker",
      "mask",
      "pattern",
      "script",
      "style",
      "switch",
      "text",
      "view"
    ])
  },
  glyph: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation"]),
    attrs: /* @__PURE__ */ new Set([
      "arabic-form",
      "class",
      "d",
      "glyph-name",
      "horiz-adv-x",
      "lang",
      "orientation",
      "style",
      "unicode",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y"
    ]),
    defaults: {
      "arabic-form": "initial"
    },
    deprecated: {
      unsafe: /* @__PURE__ */ new Set([
        "arabic-form",
        "glyph-name",
        "horiz-adv-x",
        "orientation",
        "unicode",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y"
      ])
    },
    contentGroups: /* @__PURE__ */ new Set([
      "animation",
      "descriptive",
      "paintServer",
      "shape",
      "structural"
    ]),
    content: /* @__PURE__ */ new Set([
      "a",
      "altGlyphDef",
      "clipPath",
      "color-profile",
      "cursor",
      "filter",
      "font-face",
      "font",
      "foreignObject",
      "image",
      "marker",
      "mask",
      "pattern",
      "script",
      "style",
      "switch",
      "text",
      "view"
    ])
  },
  glyphRef: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation"]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "d",
      "horiz-adv-x",
      "style",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y"
    ]),
    deprecated: {
      unsafe: /* @__PURE__ */ new Set([
        "horiz-adv-x",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y"
      ])
    },
    contentGroups: /* @__PURE__ */ new Set([
      "animation",
      "descriptive",
      "paintServer",
      "shape",
      "structural"
    ]),
    content: /* @__PURE__ */ new Set([
      "a",
      "altGlyphDef",
      "clipPath",
      "color-profile",
      "cursor",
      "filter",
      "font-face",
      "font",
      "foreignObject",
      "image",
      "marker",
      "mask",
      "pattern",
      "script",
      "style",
      "switch",
      "text",
      "view"
    ])
  },
  hatch: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "xlink"]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "hatchContentUnits",
      "hatchUnits",
      "pitch",
      "rotate",
      "style",
      "transform",
      "x",
      "y"
    ]),
    defaults: {
      hatchUnits: "objectBoundingBox",
      hatchContentUnits: "userSpaceOnUse",
      x: "0",
      y: "0",
      pitch: "0",
      rotate: "0"
    },
    contentGroups: /* @__PURE__ */ new Set(["animation", "descriptive"]),
    content: /* @__PURE__ */ new Set(["hatchPath"])
  },
  hatchPath: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "xlink"]),
    attrs: /* @__PURE__ */ new Set(["class", "style", "d", "offset"]),
    defaults: {
      offset: "0"
    },
    contentGroups: /* @__PURE__ */ new Set(["animation", "descriptive"])
  },
  hkern: {
    attrsGroups: /* @__PURE__ */ new Set(["core"]),
    attrs: /* @__PURE__ */ new Set(["u1", "g1", "u2", "g2", "k"]),
    deprecated: { unsafe: /* @__PURE__ */ new Set(["g1", "g2", "k", "u1", "u2"]) }
  },
  image: {
    attrsGroups: /* @__PURE__ */ new Set([
      "conditionalProcessing",
      "core",
      "graphicalEvent",
      "presentation",
      "xlink"
    ]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "externalResourcesRequired",
      "height",
      "href",
      "preserveAspectRatio",
      "style",
      "transform",
      "width",
      "x",
      "xlink:href",
      "y"
    ]),
    defaults: {
      x: "0",
      y: "0",
      preserveAspectRatio: "xMidYMid meet"
    },
    contentGroups: /* @__PURE__ */ new Set(["animation", "descriptive"])
  },
  line: {
    attrsGroups: /* @__PURE__ */ new Set([
      "conditionalProcessing",
      "core",
      "graphicalEvent",
      "presentation"
    ]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "externalResourcesRequired",
      "style",
      "transform",
      "x1",
      "x2",
      "y1",
      "y2"
    ]),
    defaults: {
      x1: "0",
      y1: "0",
      x2: "0",
      y2: "0"
    },
    contentGroups: /* @__PURE__ */ new Set(["animation", "descriptive"])
  },
  linearGradient: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "xlink"]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "externalResourcesRequired",
      "gradientTransform",
      "gradientUnits",
      "href",
      "spreadMethod",
      "style",
      "x1",
      "x2",
      "xlink:href",
      "y1",
      "y2"
    ]),
    defaults: {
      x1: "0",
      y1: "0",
      x2: "100%",
      y2: "0",
      spreadMethod: "pad"
    },
    contentGroups: /* @__PURE__ */ new Set(["descriptive"]),
    content: /* @__PURE__ */ new Set(["animate", "animateTransform", "set", "stop"])
  },
  marker: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation"]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "externalResourcesRequired",
      "markerHeight",
      "markerUnits",
      "markerWidth",
      "orient",
      "preserveAspectRatio",
      "refX",
      "refY",
      "style",
      "viewBox"
    ]),
    defaults: {
      markerUnits: "strokeWidth",
      refX: "0",
      refY: "0",
      markerWidth: "3",
      markerHeight: "3"
    },
    contentGroups: /* @__PURE__ */ new Set([
      "animation",
      "descriptive",
      "paintServer",
      "shape",
      "structural"
    ]),
    content: /* @__PURE__ */ new Set([
      "a",
      "altGlyphDef",
      "clipPath",
      "color-profile",
      "cursor",
      "filter",
      "font-face",
      "font",
      "foreignObject",
      "image",
      "marker",
      "mask",
      "pattern",
      "script",
      "style",
      "switch",
      "text",
      "view"
    ])
  },
  mask: {
    attrsGroups: /* @__PURE__ */ new Set(["conditionalProcessing", "core", "presentation"]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "externalResourcesRequired",
      "height",
      "mask-type",
      "maskContentUnits",
      "maskUnits",
      "style",
      "width",
      "x",
      "y"
    ]),
    defaults: {
      maskUnits: "objectBoundingBox",
      maskContentUnits: "userSpaceOnUse",
      x: "-10%",
      y: "-10%",
      width: "120%",
      height: "120%"
    },
    contentGroups: /* @__PURE__ */ new Set([
      "animation",
      "descriptive",
      "paintServer",
      "shape",
      "structural"
    ]),
    content: /* @__PURE__ */ new Set([
      "a",
      "altGlyphDef",
      "clipPath",
      "color-profile",
      "cursor",
      "filter",
      "font-face",
      "font",
      "foreignObject",
      "image",
      "marker",
      "mask",
      "pattern",
      "script",
      "style",
      "switch",
      "text",
      "view"
    ])
  },
  metadata: {
    attrsGroups: /* @__PURE__ */ new Set(["core"])
  },
  "missing-glyph": {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation"]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "d",
      "horiz-adv-x",
      "style",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y"
    ]),
    deprecated: {
      unsafe: /* @__PURE__ */ new Set([
        "horiz-adv-x",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y"
      ])
    },
    contentGroups: /* @__PURE__ */ new Set([
      "animation",
      "descriptive",
      "paintServer",
      "shape",
      "structural"
    ]),
    content: /* @__PURE__ */ new Set([
      "a",
      "altGlyphDef",
      "clipPath",
      "color-profile",
      "cursor",
      "filter",
      "font-face",
      "font",
      "foreignObject",
      "image",
      "marker",
      "mask",
      "pattern",
      "script",
      "style",
      "switch",
      "text",
      "view"
    ])
  },
  mpath: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "xlink"]),
    attrs: /* @__PURE__ */ new Set(["externalResourcesRequired", "href", "xlink:href"]),
    contentGroups: /* @__PURE__ */ new Set(["descriptive"])
  },
  path: {
    attrsGroups: /* @__PURE__ */ new Set([
      "conditionalProcessing",
      "core",
      "graphicalEvent",
      "presentation"
    ]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "d",
      "externalResourcesRequired",
      "pathLength",
      "style",
      "transform"
    ]),
    contentGroups: /* @__PURE__ */ new Set(["animation", "descriptive"])
  },
  pattern: {
    attrsGroups: /* @__PURE__ */ new Set([
      "conditionalProcessing",
      "core",
      "presentation",
      "xlink"
    ]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "externalResourcesRequired",
      "height",
      "href",
      "patternContentUnits",
      "patternTransform",
      "patternUnits",
      "preserveAspectRatio",
      "style",
      "viewBox",
      "width",
      "x",
      "xlink:href",
      "y"
    ]),
    defaults: {
      patternUnits: "objectBoundingBox",
      patternContentUnits: "userSpaceOnUse",
      x: "0",
      y: "0",
      width: "0",
      height: "0",
      preserveAspectRatio: "xMidYMid meet"
    },
    contentGroups: /* @__PURE__ */ new Set([
      "animation",
      "descriptive",
      "paintServer",
      "shape",
      "structural"
    ]),
    content: /* @__PURE__ */ new Set([
      "a",
      "altGlyphDef",
      "clipPath",
      "color-profile",
      "cursor",
      "filter",
      "font-face",
      "font",
      "foreignObject",
      "image",
      "marker",
      "mask",
      "pattern",
      "script",
      "style",
      "switch",
      "text",
      "view"
    ])
  },
  polygon: {
    attrsGroups: /* @__PURE__ */ new Set([
      "conditionalProcessing",
      "core",
      "graphicalEvent",
      "presentation"
    ]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "externalResourcesRequired",
      "points",
      "style",
      "transform"
    ]),
    contentGroups: /* @__PURE__ */ new Set(["animation", "descriptive"])
  },
  polyline: {
    attrsGroups: /* @__PURE__ */ new Set([
      "conditionalProcessing",
      "core",
      "graphicalEvent",
      "presentation"
    ]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "externalResourcesRequired",
      "points",
      "style",
      "transform"
    ]),
    contentGroups: /* @__PURE__ */ new Set(["animation", "descriptive"])
  },
  radialGradient: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "xlink"]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "cx",
      "cy",
      "externalResourcesRequired",
      "fr",
      "fx",
      "fy",
      "gradientTransform",
      "gradientUnits",
      "href",
      "r",
      "spreadMethod",
      "style",
      "xlink:href"
    ]),
    defaults: {
      gradientUnits: "objectBoundingBox",
      cx: "50%",
      cy: "50%",
      r: "50%"
    },
    contentGroups: /* @__PURE__ */ new Set(["descriptive"]),
    content: /* @__PURE__ */ new Set(["animate", "animateTransform", "set", "stop"])
  },
  meshGradient: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "xlink"]),
    attrs: /* @__PURE__ */ new Set(["class", "style", "x", "y", "gradientUnits", "transform"]),
    contentGroups: /* @__PURE__ */ new Set(["descriptive", "paintServer", "animation"]),
    content: /* @__PURE__ */ new Set(["meshRow"])
  },
  meshRow: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation"]),
    attrs: /* @__PURE__ */ new Set(["class", "style"]),
    contentGroups: /* @__PURE__ */ new Set(["descriptive"]),
    content: /* @__PURE__ */ new Set(["meshPatch"])
  },
  meshPatch: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation"]),
    attrs: /* @__PURE__ */ new Set(["class", "style"]),
    contentGroups: /* @__PURE__ */ new Set(["descriptive"]),
    content: /* @__PURE__ */ new Set(["stop"])
  },
  rect: {
    attrsGroups: /* @__PURE__ */ new Set([
      "conditionalProcessing",
      "core",
      "graphicalEvent",
      "presentation"
    ]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "externalResourcesRequired",
      "height",
      "rx",
      "ry",
      "style",
      "transform",
      "width",
      "x",
      "y"
    ]),
    defaults: {
      x: "0",
      y: "0"
    },
    contentGroups: /* @__PURE__ */ new Set(["animation", "descriptive"])
  },
  script: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "xlink"]),
    attrs: /* @__PURE__ */ new Set(["externalResourcesRequired", "type", "href", "xlink:href"])
  },
  set: {
    attrsGroups: /* @__PURE__ */ new Set([
      "animation",
      "animationAttributeTarget",
      "animationTiming",
      "conditionalProcessing",
      "core",
      "xlink"
    ]),
    attrs: /* @__PURE__ */ new Set(["externalResourcesRequired", "to"]),
    contentGroups: /* @__PURE__ */ new Set(["descriptive"])
  },
  solidColor: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation"]),
    attrs: /* @__PURE__ */ new Set(["class", "style"]),
    contentGroups: /* @__PURE__ */ new Set(["paintServer"])
  },
  stop: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "presentation"]),
    attrs: /* @__PURE__ */ new Set(["class", "style", "offset", "path"]),
    content: /* @__PURE__ */ new Set(["animate", "animateColor", "set"])
  },
  style: {
    attrsGroups: /* @__PURE__ */ new Set(["core"]),
    attrs: /* @__PURE__ */ new Set(["type", "media", "title"]),
    defaults: {
      type: "text/css"
    }
  },
  svg: {
    attrsGroups: /* @__PURE__ */ new Set([
      "conditionalProcessing",
      "core",
      "documentEvent",
      "graphicalEvent",
      "presentation"
    ]),
    attrs: /* @__PURE__ */ new Set([
      "baseProfile",
      "class",
      "contentScriptType",
      "contentStyleType",
      "height",
      "preserveAspectRatio",
      "style",
      "version",
      "viewBox",
      "width",
      "x",
      "y",
      "zoomAndPan"
    ]),
    defaults: {
      x: "0",
      y: "0",
      width: "100%",
      height: "100%",
      preserveAspectRatio: "xMidYMid meet",
      zoomAndPan: "magnify",
      version: "1.1",
      baseProfile: "none",
      contentScriptType: "application/ecmascript",
      contentStyleType: "text/css"
    },
    deprecated: {
      safe: /* @__PURE__ */ new Set(["version"]),
      unsafe: /* @__PURE__ */ new Set([
        "baseProfile",
        "contentScriptType",
        "contentStyleType",
        "zoomAndPan"
      ])
    },
    contentGroups: /* @__PURE__ */ new Set([
      "animation",
      "descriptive",
      "paintServer",
      "shape",
      "structural"
    ]),
    content: /* @__PURE__ */ new Set([
      "a",
      "altGlyphDef",
      "clipPath",
      "color-profile",
      "cursor",
      "filter",
      "font-face",
      "font",
      "foreignObject",
      "image",
      "marker",
      "mask",
      "pattern",
      "script",
      "style",
      "switch",
      "text",
      "view"
    ])
  },
  switch: {
    attrsGroups: /* @__PURE__ */ new Set([
      "conditionalProcessing",
      "core",
      "graphicalEvent",
      "presentation"
    ]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "externalResourcesRequired",
      "style",
      "transform"
    ]),
    contentGroups: /* @__PURE__ */ new Set(["animation", "descriptive", "shape"]),
    content: /* @__PURE__ */ new Set([
      "a",
      "foreignObject",
      "g",
      "image",
      "svg",
      "switch",
      "text",
      "use"
    ])
  },
  symbol: {
    attrsGroups: /* @__PURE__ */ new Set(["core", "graphicalEvent", "presentation"]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "externalResourcesRequired",
      "preserveAspectRatio",
      "refX",
      "refY",
      "style",
      "viewBox"
    ]),
    defaults: {
      refX: "0",
      refY: "0"
    },
    contentGroups: /* @__PURE__ */ new Set([
      "animation",
      "descriptive",
      "paintServer",
      "shape",
      "structural"
    ]),
    content: /* @__PURE__ */ new Set([
      "a",
      "altGlyphDef",
      "clipPath",
      "color-profile",
      "cursor",
      "filter",
      "font-face",
      "font",
      "foreignObject",
      "image",
      "marker",
      "mask",
      "pattern",
      "script",
      "style",
      "switch",
      "text",
      "view"
    ])
  },
  text: {
    attrsGroups: /* @__PURE__ */ new Set([
      "conditionalProcessing",
      "core",
      "graphicalEvent",
      "presentation"
    ]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "dx",
      "dy",
      "externalResourcesRequired",
      "lengthAdjust",
      "rotate",
      "style",
      "textLength",
      "transform",
      "x",
      "y"
    ]),
    defaults: {
      x: "0",
      y: "0",
      lengthAdjust: "spacing"
    },
    contentGroups: /* @__PURE__ */ new Set(["animation", "descriptive", "textContentChild"]),
    content: /* @__PURE__ */ new Set(["a"])
  },
  textPath: {
    attrsGroups: /* @__PURE__ */ new Set([
      "conditionalProcessing",
      "core",
      "graphicalEvent",
      "presentation",
      "xlink"
    ]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "d",
      "externalResourcesRequired",
      "href",
      "method",
      "spacing",
      "startOffset",
      "style",
      "xlink:href"
    ]),
    defaults: {
      startOffset: "0",
      method: "align",
      spacing: "exact"
    },
    contentGroups: /* @__PURE__ */ new Set(["descriptive"]),
    content: /* @__PURE__ */ new Set([
      "a",
      "altGlyph",
      "animate",
      "animateColor",
      "set",
      "tref",
      "tspan"
    ])
  },
  title: {
    attrsGroups: /* @__PURE__ */ new Set(["core"]),
    attrs: /* @__PURE__ */ new Set(["class", "style"])
  },
  tref: {
    attrsGroups: /* @__PURE__ */ new Set([
      "conditionalProcessing",
      "core",
      "graphicalEvent",
      "presentation",
      "xlink"
    ]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "externalResourcesRequired",
      "href",
      "style",
      "xlink:href"
    ]),
    contentGroups: /* @__PURE__ */ new Set(["descriptive"]),
    content: /* @__PURE__ */ new Set(["animate", "animateColor", "set"])
  },
  tspan: {
    attrsGroups: /* @__PURE__ */ new Set([
      "conditionalProcessing",
      "core",
      "graphicalEvent",
      "presentation"
    ]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "dx",
      "dy",
      "externalResourcesRequired",
      "lengthAdjust",
      "rotate",
      "style",
      "textLength",
      "x",
      "y"
    ]),
    contentGroups: /* @__PURE__ */ new Set(["descriptive"]),
    content: /* @__PURE__ */ new Set([
      "a",
      "altGlyph",
      "animate",
      "animateColor",
      "set",
      "tref",
      "tspan"
    ])
  },
  use: {
    attrsGroups: /* @__PURE__ */ new Set([
      "conditionalProcessing",
      "core",
      "graphicalEvent",
      "presentation",
      "xlink"
    ]),
    attrs: /* @__PURE__ */ new Set([
      "class",
      "externalResourcesRequired",
      "height",
      "href",
      "style",
      "transform",
      "width",
      "x",
      "xlink:href",
      "y"
    ]),
    defaults: {
      x: "0",
      y: "0"
    },
    contentGroups: /* @__PURE__ */ new Set(["animation", "descriptive"])
  },
  view: {
    attrsGroups: /* @__PURE__ */ new Set(["core"]),
    attrs: /* @__PURE__ */ new Set([
      "externalResourcesRequired",
      "preserveAspectRatio",
      "viewBox",
      "viewTarget",
      "zoomAndPan"
    ]),
    deprecated: { unsafe: /* @__PURE__ */ new Set(["viewTarget", "zoomAndPan"]) },
    contentGroups: /* @__PURE__ */ new Set(["descriptive"])
  },
  vkern: {
    attrsGroups: /* @__PURE__ */ new Set(["core"]),
    attrs: /* @__PURE__ */ new Set(["u1", "g1", "u2", "g2", "k"]),
    deprecated: { unsafe: /* @__PURE__ */ new Set(["g1", "g2", "k", "u1", "u2"]) }
  }
};
const editorNamespaces = /* @__PURE__ */ new Set([
  "http://creativecommons.org/ns#",
  "http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd",
  "http://krita.org/namespaces/svg/krita",
  "http://ns.adobe.com/AdobeIllustrator/10.0/",
  "http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/",
  "http://ns.adobe.com/Extensibility/1.0/",
  "http://ns.adobe.com/Flows/1.0/",
  "http://ns.adobe.com/GenericCustomNamespace/1.0/",
  "http://ns.adobe.com/Graphs/1.0/",
  "http://ns.adobe.com/ImageReplacement/1.0/",
  "http://ns.adobe.com/SaveForWeb/1.0/",
  "http://ns.adobe.com/Variables/1.0/",
  "http://ns.adobe.com/XPath/1.0/",
  "http://purl.org/dc/elements/1.1/",
  "http://schemas.microsoft.com/visio/2003/SVGExtensions/",
  "http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd",
  "http://taptrix.com/vectorillustrator/svg_extensions",
  "http://www.bohemiancoding.com/sketch/ns",
  "http://www.figma.com/figma/ns",
  "http://www.inkscape.org/namespaces/inkscape",
  "http://www.serif.com/",
  "http://www.vector.evaxdesign.sk",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
  "https://boxy-svg.com"
]);
const referencesProps = /* @__PURE__ */ new Set([
  "clip-path",
  "color-profile",
  "fill",
  "filter",
  "marker-end",
  "marker-mid",
  "marker-start",
  "mask",
  "stroke",
  "style"
]);
const inheritableAttrs = /* @__PURE__ */ new Set([
  "clip-rule",
  "color-interpolation-filters",
  "color-interpolation",
  "color-profile",
  "color-rendering",
  "color",
  "cursor",
  "direction",
  "dominant-baseline",
  "fill-opacity",
  "fill-rule",
  "fill",
  "font-family",
  "font-size-adjust",
  "font-size",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "font",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "image-rendering",
  "letter-spacing",
  "marker-end",
  "marker-mid",
  "marker-start",
  "marker",
  "paint-order",
  "pointer-events",
  "shape-rendering",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "stroke",
  "text-anchor",
  "text-rendering",
  "transform",
  "visibility",
  "word-spacing",
  "writing-mode"
]);
const presentationNonInheritableGroupAttrs = /* @__PURE__ */ new Set([
  "clip-path",
  "display",
  "filter",
  "mask",
  "opacity",
  "text-decoration",
  "transform",
  "unicode-bidi"
]);
const colorsNames = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#0ff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000",
  blanchedalmond: "#ffebcd",
  blue: "#00f",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#0ff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#f0f",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  gold: "#ffd700",
  goldenrod: "#daa520",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavender: "#e6e6fa",
  lavenderblush: "#fff0f5",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#789",
  lightslategrey: "#789",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#0f0",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#f0f",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#639",
  red: "#f00",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#fff",
  whitesmoke: "#f5f5f5",
  yellow: "#ff0",
  yellowgreen: "#9acd32"
};
const colorsShortNames = {
  "#f0ffff": "azure",
  "#f5f5dc": "beige",
  "#ffe4c4": "bisque",
  "#a52a2a": "brown",
  "#ff7f50": "coral",
  "#ffd700": "gold",
  "#808080": "gray",
  "#008000": "green",
  "#4b0082": "indigo",
  "#fffff0": "ivory",
  "#f0e68c": "khaki",
  "#faf0e6": "linen",
  "#800000": "maroon",
  "#000080": "navy",
  "#808000": "olive",
  "#ffa500": "orange",
  "#da70d6": "orchid",
  "#cd853f": "peru",
  "#ffc0cb": "pink",
  "#dda0dd": "plum",
  "#800080": "purple",
  "#f00": "red",
  "#ff0000": "red",
  "#fa8072": "salmon",
  "#a0522d": "sienna",
  "#c0c0c0": "silver",
  "#fffafa": "snow",
  "#d2b48c": "tan",
  "#008080": "teal",
  "#ff6347": "tomato",
  "#ee82ee": "violet",
  "#f5deb3": "wheat"
};
const colorsProps = /* @__PURE__ */ new Set([
  "color",
  "fill",
  "flood-color",
  "lighting-color",
  "stop-color",
  "stroke"
]);
const pseudoClasses = {
  treeStructural: /* @__PURE__ */ new Set([
    "empty",
    "first-child",
    "first-of-type",
    "last-child",
    "last-of-type",
    "nth-child",
    "nth-last-child",
    "nth-last-of-type",
    "nth-of-type",
    "only-child",
    "only-of-type",
    "root"
  ]),
  functional: /* @__PURE__ */ new Set(["is", "not", "where", "has"])
};
const EOF$3 = 0;
const Ident$1 = 1;
const Function$3 = 2;
const AtKeyword$1 = 3;
const Hash$3 = 4;
const String$4 = 5;
const BadString$1 = 6;
const Url$4 = 7;
const BadUrl$1 = 8;
const Delim$1 = 9;
const Number$5 = 10;
const Percentage$3 = 11;
const Dimension$3 = 12;
const WhiteSpace$3 = 13;
const CDO$3 = 14;
const CDC$3 = 15;
const Colon$1 = 16;
const Semicolon$1 = 17;
const Comma$1 = 18;
const LeftSquareBracket$1 = 19;
const RightSquareBracket$1 = 20;
const LeftParenthesis$1 = 21;
const RightParenthesis$1 = 22;
const LeftCurlyBracket$1 = 23;
const RightCurlyBracket$1 = 24;
const Comment$3 = 25;
const EOF$2 = 0;
function isDigit$2(code2) {
  return code2 >= 48 && code2 <= 57;
}
function isHexDigit$1(code2) {
  return isDigit$2(code2) || // 0 .. 9
  code2 >= 65 && code2 <= 70 || // A .. F
  code2 >= 97 && code2 <= 102;
}
function isUppercaseLetter$1(code2) {
  return code2 >= 65 && code2 <= 90;
}
function isLowercaseLetter$1(code2) {
  return code2 >= 97 && code2 <= 122;
}
function isLetter$1(code2) {
  return isUppercaseLetter$1(code2) || isLowercaseLetter$1(code2);
}
function isNonAscii$1(code2) {
  return code2 >= 128;
}
function isNameStart$1(code2) {
  return isLetter$1(code2) || isNonAscii$1(code2) || code2 === 95;
}
function isName$1(code2) {
  return isNameStart$1(code2) || isDigit$2(code2) || code2 === 45;
}
function isNonPrintable$1(code2) {
  return code2 >= 0 && code2 <= 8 || code2 === 11 || code2 >= 14 && code2 <= 31 || code2 === 127;
}
function isNewline$1(code2) {
  return code2 === 10 || code2 === 13 || code2 === 12;
}
function isWhiteSpace$2(code2) {
  return isNewline$1(code2) || code2 === 32 || code2 === 9;
}
function isValidEscape$1(first, second) {
  if (first !== 92) {
    return false;
  }
  if (isNewline$1(second) || second === EOF$2) {
    return false;
  }
  return true;
}
function isIdentifierStart$1(first, second, third) {
  if (first === 45) {
    return isNameStart$1(second) || second === 45 || isValidEscape$1(second, third);
  }
  if (isNameStart$1(first)) {
    return true;
  }
  if (first === 92) {
    return isValidEscape$1(first, second);
  }
  return false;
}
function isNumberStart$1(first, second, third) {
  if (first === 43 || first === 45) {
    if (isDigit$2(second)) {
      return 2;
    }
    return second === 46 && isDigit$2(third) ? 3 : 0;
  }
  if (first === 46) {
    return isDigit$2(second) ? 2 : 0;
  }
  if (isDigit$2(first)) {
    return 1;
  }
  return 0;
}
function isBOM$1(code2) {
  if (code2 === 65279) {
    return 1;
  }
  if (code2 === 65534) {
    return 1;
  }
  return 0;
}
const CATEGORY$1 = new Array(128);
const EofCategory$1 = 128;
const WhiteSpaceCategory$1 = 130;
const DigitCategory$1 = 131;
const NameStartCategory$1 = 132;
const NonPrintableCategory$1 = 133;
for (let i = 0; i < CATEGORY$1.length; i++) {
  CATEGORY$1[i] = isWhiteSpace$2(i) && WhiteSpaceCategory$1 || isDigit$2(i) && DigitCategory$1 || isNameStart$1(i) && NameStartCategory$1 || isNonPrintable$1(i) && NonPrintableCategory$1 || i || EofCategory$1;
}
function charCodeCategory$1(code2) {
  return code2 < 128 ? CATEGORY$1[code2] : NameStartCategory$1;
}
function getCharCode$1(source, offset) {
  return offset < source.length ? source.charCodeAt(offset) : 0;
}
function getNewlineLength$1(source, offset, code2) {
  if (code2 === 13 && getCharCode$1(source, offset + 1) === 10) {
    return 2;
  }
  return 1;
}
function cmpChar$1(testStr, offset, referenceCode) {
  let code2 = testStr.charCodeAt(offset);
  if (isUppercaseLetter$1(code2)) {
    code2 = code2 | 32;
  }
  return code2 === referenceCode;
}
function cmpStr$1(testStr, start, end, referenceStr) {
  if (end - start !== referenceStr.length) {
    return false;
  }
  if (start < 0 || end > testStr.length) {
    return false;
  }
  for (let i = start; i < end; i++) {
    const referenceCode = referenceStr.charCodeAt(i - start);
    let testCode = testStr.charCodeAt(i);
    if (isUppercaseLetter$1(testCode)) {
      testCode = testCode | 32;
    }
    if (testCode !== referenceCode) {
      return false;
    }
  }
  return true;
}
function findWhiteSpaceStart$1(source, offset) {
  for (; offset >= 0; offset--) {
    if (!isWhiteSpace$2(source.charCodeAt(offset))) {
      break;
    }
  }
  return offset + 1;
}
function findWhiteSpaceEnd$1(source, offset) {
  for (; offset < source.length; offset++) {
    if (!isWhiteSpace$2(source.charCodeAt(offset))) {
      break;
    }
  }
  return offset;
}
function findDecimalNumberEnd$1(source, offset) {
  for (; offset < source.length; offset++) {
    if (!isDigit$2(source.charCodeAt(offset))) {
      break;
    }
  }
  return offset;
}
function consumeEscaped$1(source, offset) {
  offset += 2;
  if (isHexDigit$1(getCharCode$1(source, offset - 1))) {
    for (const maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
      if (!isHexDigit$1(getCharCode$1(source, offset))) {
        break;
      }
    }
    const code2 = getCharCode$1(source, offset);
    if (isWhiteSpace$2(code2)) {
      offset += getNewlineLength$1(source, offset, code2);
    }
  }
  return offset;
}
function consumeName$1(source, offset) {
  for (; offset < source.length; offset++) {
    const code2 = source.charCodeAt(offset);
    if (isName$1(code2)) {
      continue;
    }
    if (isValidEscape$1(code2, getCharCode$1(source, offset + 1))) {
      offset = consumeEscaped$1(source, offset) - 1;
      continue;
    }
    break;
  }
  return offset;
}
function consumeNumber$2(source, offset) {
  let code2 = source.charCodeAt(offset);
  if (code2 === 43 || code2 === 45) {
    code2 = source.charCodeAt(offset += 1);
  }
  if (isDigit$2(code2)) {
    offset = findDecimalNumberEnd$1(source, offset + 1);
    code2 = source.charCodeAt(offset);
  }
  if (code2 === 46 && isDigit$2(source.charCodeAt(offset + 1))) {
    offset += 2;
    offset = findDecimalNumberEnd$1(source, offset);
  }
  if (cmpChar$1(
    source,
    offset,
    101
    /* e */
  )) {
    let sign = 0;
    code2 = source.charCodeAt(offset + 1);
    if (code2 === 45 || code2 === 43) {
      sign = 1;
      code2 = source.charCodeAt(offset + 2);
    }
    if (isDigit$2(code2)) {
      offset = findDecimalNumberEnd$1(source, offset + 1 + sign + 1);
    }
  }
  return offset;
}
function consumeBadUrlRemnants$1(source, offset) {
  for (; offset < source.length; offset++) {
    const code2 = source.charCodeAt(offset);
    if (code2 === 41) {
      offset++;
      break;
    }
    if (isValidEscape$1(code2, getCharCode$1(source, offset + 1))) {
      offset = consumeEscaped$1(source, offset);
    }
  }
  return offset;
}
function decodeEscaped$1(escaped) {
  if (escaped.length === 1 && !isHexDigit$1(escaped.charCodeAt(0))) {
    return escaped[0];
  }
  let code2 = parseInt(escaped, 16);
  if (code2 === 0 || // If this number is zero,
  code2 >= 55296 && code2 <= 57343 || // or is for a surrogate,
  code2 > 1114111) {
    code2 = 65533;
  }
  return String.fromCodePoint(code2);
}
const tokenNames$1 = [
  "EOF-token",
  "ident-token",
  "function-token",
  "at-keyword-token",
  "hash-token",
  "string-token",
  "bad-string-token",
  "url-token",
  "bad-url-token",
  "delim-token",
  "number-token",
  "percentage-token",
  "dimension-token",
  "whitespace-token",
  "CDO-token",
  "CDC-token",
  "colon-token",
  "semicolon-token",
  "comma-token",
  "[-token",
  "]-token",
  "(-token",
  ")-token",
  "{-token",
  "}-token",
  "comment-token"
];
const MIN_SIZE$1 = 16 * 1024;
function adoptBuffer$1(buffer2 = null, size) {
  if (buffer2 === null || buffer2.length < size) {
    return new Uint32Array(Math.max(size + 1024, MIN_SIZE$1));
  }
  return buffer2;
}
const N$9 = 10;
const F$5 = 12;
const R$5 = 13;
function computeLinesAndColumns$1(host) {
  const source = host.source;
  const sourceLength = source.length;
  const startOffset = source.length > 0 ? isBOM$1(source.charCodeAt(0)) : 0;
  const lines = adoptBuffer$1(host.lines, sourceLength);
  const columns = adoptBuffer$1(host.columns, sourceLength);
  let line = host.startLine;
  let column = host.startColumn;
  for (let i = startOffset; i < sourceLength; i++) {
    const code2 = source.charCodeAt(i);
    lines[i] = line;
    columns[i] = column++;
    if (code2 === N$9 || code2 === R$5 || code2 === F$5) {
      if (code2 === R$5 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$9) {
        i++;
        lines[i] = line;
        columns[i] = column;
      }
      line++;
      column = 1;
    }
  }
  lines[sourceLength] = line;
  columns[sourceLength] = column;
  host.lines = lines;
  host.columns = columns;
  host.computed = true;
}
let OffsetToLocation$1 = class OffsetToLocation {
  constructor(source, startOffset, startLine, startColumn) {
    this.setSource(source, startOffset, startLine, startColumn);
    this.lines = null;
    this.columns = null;
  }
  setSource(source = "", startOffset = 0, startLine = 1, startColumn = 1) {
    this.source = source;
    this.startOffset = startOffset;
    this.startLine = startLine;
    this.startColumn = startColumn;
    this.computed = false;
  }
  getLocation(offset, filename) {
    if (!this.computed) {
      computeLinesAndColumns$1(this);
    }
    return {
      source: filename,
      offset: this.startOffset + offset,
      line: this.lines[offset],
      column: this.columns[offset]
    };
  }
  getLocationRange(start, end, filename) {
    if (!this.computed) {
      computeLinesAndColumns$1(this);
    }
    return {
      source: filename,
      start: {
        offset: this.startOffset + start,
        line: this.lines[start],
        column: this.columns[start]
      },
      end: {
        offset: this.startOffset + end,
        line: this.lines[end],
        column: this.columns[end]
      }
    };
  }
};
const OFFSET_MASK$1 = 16777215;
const TYPE_SHIFT$1 = 24;
const balancePair$3 = new Uint8Array(32);
balancePair$3[Function$3] = RightParenthesis$1;
balancePair$3[LeftParenthesis$1] = RightParenthesis$1;
balancePair$3[LeftSquareBracket$1] = RightSquareBracket$1;
balancePair$3[LeftCurlyBracket$1] = RightCurlyBracket$1;
function isBlockOpenerToken(tokenType2) {
  return balancePair$3[tokenType2] !== 0;
}
let TokenStream$1 = class TokenStream {
  constructor(source, tokenize2) {
    this.setSource(source, tokenize2);
  }
  reset() {
    this.eof = false;
    this.tokenIndex = -1;
    this.tokenType = 0;
    this.tokenStart = this.firstCharOffset;
    this.tokenEnd = this.firstCharOffset;
  }
  setSource(source = "", tokenize2 = () => {
  }) {
    source = String(source || "");
    const sourceLength = source.length;
    const offsetAndType = adoptBuffer$1(this.offsetAndType, source.length + 1);
    const balance = adoptBuffer$1(this.balance, source.length + 1);
    let tokenCount = 0;
    let firstCharOffset = -1;
    let balanceCloseType = 0;
    let balanceStart = source.length;
    this.offsetAndType = null;
    this.balance = null;
    balance.fill(0);
    tokenize2(source, (type, start, end) => {
      const index = tokenCount++;
      offsetAndType[index] = type << TYPE_SHIFT$1 | end;
      if (firstCharOffset === -1) {
        firstCharOffset = start;
      }
      balance[index] = balanceStart;
      if (type === balanceCloseType) {
        const prevBalanceStart = balance[balanceStart];
        balance[balanceStart] = index;
        balanceStart = prevBalanceStart;
        balanceCloseType = balancePair$3[offsetAndType[prevBalanceStart] >> TYPE_SHIFT$1];
      } else if (isBlockOpenerToken(type)) {
        balanceStart = index;
        balanceCloseType = balancePair$3[type];
      }
    });
    offsetAndType[tokenCount] = EOF$3 << TYPE_SHIFT$1 | sourceLength;
    balance[tokenCount] = tokenCount;
    for (let i = 0; i < tokenCount; i++) {
      const balanceStart2 = balance[i];
      if (balanceStart2 <= i) {
        const balanceEnd = balance[balanceStart2];
        if (balanceEnd !== i) {
          balance[i] = balanceEnd;
        }
      } else if (balanceStart2 > tokenCount) {
        balance[i] = tokenCount;
      }
    }
    this.source = source;
    this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;
    this.tokenCount = tokenCount;
    this.offsetAndType = offsetAndType;
    this.balance = balance;
    this.reset();
    this.next();
  }
  lookupType(offset) {
    offset += this.tokenIndex;
    if (offset < this.tokenCount) {
      return this.offsetAndType[offset] >> TYPE_SHIFT$1;
    }
    return EOF$3;
  }
  lookupTypeNonSC(idx) {
    for (let offset = this.tokenIndex; offset < this.tokenCount; offset++) {
      const tokenType2 = this.offsetAndType[offset] >> TYPE_SHIFT$1;
      if (tokenType2 !== WhiteSpace$3 && tokenType2 !== Comment$3) {
        if (idx-- === 0) {
          return tokenType2;
        }
      }
    }
    return EOF$3;
  }
  lookupOffset(offset) {
    offset += this.tokenIndex;
    if (offset < this.tokenCount) {
      return this.offsetAndType[offset - 1] & OFFSET_MASK$1;
    }
    return this.source.length;
  }
  lookupOffsetNonSC(idx) {
    for (let offset = this.tokenIndex; offset < this.tokenCount; offset++) {
      const tokenType2 = this.offsetAndType[offset] >> TYPE_SHIFT$1;
      if (tokenType2 !== WhiteSpace$3 && tokenType2 !== Comment$3) {
        if (idx-- === 0) {
          return offset - this.tokenIndex;
        }
      }
    }
    return EOF$3;
  }
  lookupValue(offset, referenceStr) {
    offset += this.tokenIndex;
    if (offset < this.tokenCount) {
      return cmpStr$1(
        this.source,
        this.offsetAndType[offset - 1] & OFFSET_MASK$1,
        this.offsetAndType[offset] & OFFSET_MASK$1,
        referenceStr
      );
    }
    return false;
  }
  getTokenStart(tokenIndex) {
    if (tokenIndex === this.tokenIndex) {
      return this.tokenStart;
    }
    if (tokenIndex > 0) {
      return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK$1 : this.offsetAndType[this.tokenCount] & OFFSET_MASK$1;
    }
    return this.firstCharOffset;
  }
  substrToCursor(start) {
    return this.source.substring(start, this.tokenStart);
  }
  isBalanceEdge(pos) {
    return this.balance[this.tokenIndex] < pos;
  }
  isDelim(code2, offset) {
    if (offset) {
      return this.lookupType(offset) === Delim$1 && this.source.charCodeAt(this.lookupOffset(offset)) === code2;
    }
    return this.tokenType === Delim$1 && this.source.charCodeAt(this.tokenStart) === code2;
  }
  skip(tokenCount) {
    let next = this.tokenIndex + tokenCount;
    if (next < this.tokenCount) {
      this.tokenIndex = next;
      this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK$1;
      next = this.offsetAndType[next];
      this.tokenType = next >> TYPE_SHIFT$1;
      this.tokenEnd = next & OFFSET_MASK$1;
    } else {
      this.tokenIndex = this.tokenCount;
      this.next();
    }
  }
  next() {
    let next = this.tokenIndex + 1;
    if (next < this.tokenCount) {
      this.tokenIndex = next;
      this.tokenStart = this.tokenEnd;
      next = this.offsetAndType[next];
      this.tokenType = next >> TYPE_SHIFT$1;
      this.tokenEnd = next & OFFSET_MASK$1;
    } else {
      this.eof = true;
      this.tokenIndex = this.tokenCount;
      this.tokenType = EOF$3;
      this.tokenStart = this.tokenEnd = this.source.length;
    }
  }
  skipSC() {
    while (this.tokenType === WhiteSpace$3 || this.tokenType === Comment$3) {
      this.next();
    }
  }
  skipUntilBalanced(startToken, stopConsume) {
    let cursor = startToken;
    let balanceEnd = 0;
    let offset = 0;
    loop:
      for (; cursor < this.tokenCount; cursor++) {
        balanceEnd = this.balance[cursor];
        if (balanceEnd < startToken) {
          break loop;
        }
        offset = cursor > 0 ? this.offsetAndType[cursor - 1] & OFFSET_MASK$1 : this.firstCharOffset;
        switch (stopConsume(this.source.charCodeAt(offset))) {
          case 1:
            break loop;
          case 2:
            cursor++;
            break loop;
          default:
            if (isBlockOpenerToken(this.offsetAndType[cursor] >> TYPE_SHIFT$1)) {
              cursor = balanceEnd;
            }
        }
      }
    this.skip(cursor - this.tokenIndex);
  }
  forEachToken(fn2) {
    for (let i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {
      const start = offset;
      const item = this.offsetAndType[i];
      const end = item & OFFSET_MASK$1;
      const type = item >> TYPE_SHIFT$1;
      offset = end;
      fn2(type, start, end, i);
    }
  }
  dump() {
    const tokens = new Array(this.tokenCount);
    this.forEachToken((type, start, end, index) => {
      tokens[index] = {
        idx: index,
        type: tokenNames$1[type],
        chunk: this.source.substring(start, end),
        balance: this.balance[index]
      };
    });
    return tokens;
  }
};
function tokenize$4(source, onToken) {
  function getCharCode2(offset2) {
    return offset2 < sourceLength ? source.charCodeAt(offset2) : 0;
  }
  function consumeNumericToken() {
    offset = consumeNumber$2(source, offset);
    if (isIdentifierStart$1(getCharCode2(offset), getCharCode2(offset + 1), getCharCode2(offset + 2))) {
      type = Dimension$3;
      offset = consumeName$1(source, offset);
      return;
    }
    if (getCharCode2(offset) === 37) {
      type = Percentage$3;
      offset++;
      return;
    }
    type = Number$5;
  }
  function consumeIdentLikeToken() {
    const nameStartOffset = offset;
    offset = consumeName$1(source, offset);
    if (cmpStr$1(source, nameStartOffset, offset, "url") && getCharCode2(offset) === 40) {
      offset = findWhiteSpaceEnd$1(source, offset + 1);
      if (getCharCode2(offset) === 34 || getCharCode2(offset) === 39) {
        type = Function$3;
        offset = nameStartOffset + 4;
        return;
      }
      consumeUrlToken();
      return;
    }
    if (getCharCode2(offset) === 40) {
      type = Function$3;
      offset++;
      return;
    }
    type = Ident$1;
  }
  function consumeStringToken(endingCodePoint) {
    if (!endingCodePoint) {
      endingCodePoint = getCharCode2(offset++);
    }
    type = String$4;
    for (; offset < source.length; offset++) {
      const code2 = source.charCodeAt(offset);
      switch (charCodeCategory$1(code2)) {
        // ending code point
        case endingCodePoint:
          offset++;
          return;
        // EOF
        // case EofCategory:
        // This is a parse error. Return the <string-token>.
        // return;
        // newline
        case WhiteSpaceCategory$1:
          if (isNewline$1(code2)) {
            offset += getNewlineLength$1(source, offset, code2);
            type = BadString$1;
            return;
          }
          break;
        // U+005C REVERSE SOLIDUS (\)
        case 92:
          if (offset === source.length - 1) {
            break;
          }
          const nextCode = getCharCode2(offset + 1);
          if (isNewline$1(nextCode)) {
            offset += getNewlineLength$1(source, offset + 1, nextCode);
          } else if (isValidEscape$1(code2, nextCode)) {
            offset = consumeEscaped$1(source, offset) - 1;
          }
          break;
      }
    }
  }
  function consumeUrlToken() {
    type = Url$4;
    offset = findWhiteSpaceEnd$1(source, offset);
    for (; offset < source.length; offset++) {
      const code2 = source.charCodeAt(offset);
      switch (charCodeCategory$1(code2)) {
        // U+0029 RIGHT PARENTHESIS ())
        case 41:
          offset++;
          return;
        // EOF
        // case EofCategory:
        // This is a parse error. Return the <url-token>.
        // return;
        // whitespace
        case WhiteSpaceCategory$1:
          offset = findWhiteSpaceEnd$1(source, offset);
          if (getCharCode2(offset) === 41 || offset >= source.length) {
            if (offset < source.length) {
              offset++;
            }
            return;
          }
          offset = consumeBadUrlRemnants$1(source, offset);
          type = BadUrl$1;
          return;
        // U+0022 QUOTATION MARK (")
        // U+0027 APOSTROPHE (')
        // U+0028 LEFT PARENTHESIS (()
        // non-printable code point
        case 34:
        case 39:
        case 40:
        case NonPrintableCategory$1:
          offset = consumeBadUrlRemnants$1(source, offset);
          type = BadUrl$1;
          return;
        // U+005C REVERSE SOLIDUS (\)
        case 92:
          if (isValidEscape$1(code2, getCharCode2(offset + 1))) {
            offset = consumeEscaped$1(source, offset) - 1;
            break;
          }
          offset = consumeBadUrlRemnants$1(source, offset);
          type = BadUrl$1;
          return;
      }
    }
  }
  source = String(source || "");
  const sourceLength = source.length;
  let start = isBOM$1(getCharCode2(0));
  let offset = start;
  let type;
  while (offset < sourceLength) {
    const code2 = source.charCodeAt(offset);
    switch (charCodeCategory$1(code2)) {
      // whitespace
      case WhiteSpaceCategory$1:
        type = WhiteSpace$3;
        offset = findWhiteSpaceEnd$1(source, offset + 1);
        break;
      // U+0022 QUOTATION MARK (")
      case 34:
        consumeStringToken();
        break;
      // U+0023 NUMBER SIGN (#)
      case 35:
        if (isName$1(getCharCode2(offset + 1)) || isValidEscape$1(getCharCode2(offset + 1), getCharCode2(offset + 2))) {
          type = Hash$3;
          offset = consumeName$1(source, offset + 1);
        } else {
          type = Delim$1;
          offset++;
        }
        break;
      // U+0027 APOSTROPHE (')
      case 39:
        consumeStringToken();
        break;
      // U+0028 LEFT PARENTHESIS (()
      case 40:
        type = LeftParenthesis$1;
        offset++;
        break;
      // U+0029 RIGHT PARENTHESIS ())
      case 41:
        type = RightParenthesis$1;
        offset++;
        break;
      // U+002B PLUS SIGN (+)
      case 43:
        if (isNumberStart$1(code2, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
          consumeNumericToken();
        } else {
          type = Delim$1;
          offset++;
        }
        break;
      // U+002C COMMA (,)
      case 44:
        type = Comma$1;
        offset++;
        break;
      // U+002D HYPHEN-MINUS (-)
      case 45:
        if (isNumberStart$1(code2, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
          consumeNumericToken();
        } else {
          if (getCharCode2(offset + 1) === 45 && getCharCode2(offset + 2) === 62) {
            type = CDC$3;
            offset = offset + 3;
          } else {
            if (isIdentifierStart$1(code2, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
              consumeIdentLikeToken();
            } else {
              type = Delim$1;
              offset++;
            }
          }
        }
        break;
      // U+002E FULL STOP (.)
      case 46:
        if (isNumberStart$1(code2, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
          consumeNumericToken();
        } else {
          type = Delim$1;
          offset++;
        }
        break;
      // U+002F SOLIDUS (/)
      case 47:
        if (getCharCode2(offset + 1) === 42) {
          type = Comment$3;
          offset = source.indexOf("*/", offset + 2);
          offset = offset === -1 ? source.length : offset + 2;
        } else {
          type = Delim$1;
          offset++;
        }
        break;
      // U+003A COLON (:)
      case 58:
        type = Colon$1;
        offset++;
        break;
      // U+003B SEMICOLON (;)
      case 59:
        type = Semicolon$1;
        offset++;
        break;
      // U+003C LESS-THAN SIGN (<)
      case 60:
        if (getCharCode2(offset + 1) === 33 && getCharCode2(offset + 2) === 45 && getCharCode2(offset + 3) === 45) {
          type = CDO$3;
          offset = offset + 4;
        } else {
          type = Delim$1;
          offset++;
        }
        break;
      // U+0040 COMMERCIAL AT (@)
      case 64:
        if (isIdentifierStart$1(getCharCode2(offset + 1), getCharCode2(offset + 2), getCharCode2(offset + 3))) {
          type = AtKeyword$1;
          offset = consumeName$1(source, offset + 1);
        } else {
          type = Delim$1;
          offset++;
        }
        break;
      // U+005B LEFT SQUARE BRACKET ([)
      case 91:
        type = LeftSquareBracket$1;
        offset++;
        break;
      // U+005C REVERSE SOLIDUS (\)
      case 92:
        if (isValidEscape$1(code2, getCharCode2(offset + 1))) {
          consumeIdentLikeToken();
        } else {
          type = Delim$1;
          offset++;
        }
        break;
      // U+005D RIGHT SQUARE BRACKET (])
      case 93:
        type = RightSquareBracket$1;
        offset++;
        break;
      // U+007B LEFT CURLY BRACKET ({)
      case 123:
        type = LeftCurlyBracket$1;
        offset++;
        break;
      // U+007D RIGHT CURLY BRACKET (})
      case 125:
        type = RightCurlyBracket$1;
        offset++;
        break;
      // digit
      case DigitCategory$1:
        consumeNumericToken();
        break;
      // name-start code point
      case NameStartCategory$1:
        consumeIdentLikeToken();
        break;
      // EOF
      // case EofCategory:
      // Return an <EOF-token>.
      // break;
      // anything else
      default:
        type = Delim$1;
        offset++;
    }
    onToken(type, start, start = offset);
  }
}
let releasedCursors$1 = null;
let List$1 = class List {
  static createItem(data) {
    return {
      prev: null,
      next: null,
      data
    };
  }
  constructor() {
    this.head = null;
    this.tail = null;
    this.cursor = null;
  }
  createItem(data) {
    return List.createItem(data);
  }
  // cursor helpers
  allocateCursor(prev, next) {
    let cursor;
    if (releasedCursors$1 !== null) {
      cursor = releasedCursors$1;
      releasedCursors$1 = releasedCursors$1.cursor;
      cursor.prev = prev;
      cursor.next = next;
      cursor.cursor = this.cursor;
    } else {
      cursor = {
        prev,
        next,
        cursor: this.cursor
      };
    }
    this.cursor = cursor;
    return cursor;
  }
  releaseCursor() {
    const { cursor } = this;
    this.cursor = cursor.cursor;
    cursor.prev = null;
    cursor.next = null;
    cursor.cursor = releasedCursors$1;
    releasedCursors$1 = cursor;
  }
  updateCursors(prevOld, prevNew, nextOld, nextNew) {
    let { cursor } = this;
    while (cursor !== null) {
      if (cursor.prev === prevOld) {
        cursor.prev = prevNew;
      }
      if (cursor.next === nextOld) {
        cursor.next = nextNew;
      }
      cursor = cursor.cursor;
    }
  }
  *[Symbol.iterator]() {
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      yield cursor.data;
    }
  }
  // getters
  get size() {
    let size = 0;
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      size++;
    }
    return size;
  }
  get isEmpty() {
    return this.head === null;
  }
  get first() {
    return this.head && this.head.data;
  }
  get last() {
    return this.tail && this.tail.data;
  }
  // convertors
  fromArray(array) {
    let cursor = null;
    this.head = null;
    for (let data of array) {
      const item = List.createItem(data);
      if (cursor !== null) {
        cursor.next = item;
      } else {
        this.head = item;
      }
      item.prev = cursor;
      cursor = item;
    }
    this.tail = cursor;
    return this;
  }
  toArray() {
    return [...this];
  }
  toJSON() {
    return [...this];
  }
  // array-like methods
  forEach(fn2, thisArg = this) {
    const cursor = this.allocateCursor(null, this.head);
    while (cursor.next !== null) {
      const item = cursor.next;
      cursor.next = item.next;
      fn2.call(thisArg, item.data, item, this);
    }
    this.releaseCursor();
  }
  forEachRight(fn2, thisArg = this) {
    const cursor = this.allocateCursor(this.tail, null);
    while (cursor.prev !== null) {
      const item = cursor.prev;
      cursor.prev = item.prev;
      fn2.call(thisArg, item.data, item, this);
    }
    this.releaseCursor();
  }
  reduce(fn2, initialValue, thisArg = this) {
    let cursor = this.allocateCursor(null, this.head);
    let acc = initialValue;
    let item;
    while (cursor.next !== null) {
      item = cursor.next;
      cursor.next = item.next;
      acc = fn2.call(thisArg, acc, item.data, item, this);
    }
    this.releaseCursor();
    return acc;
  }
  reduceRight(fn2, initialValue, thisArg = this) {
    let cursor = this.allocateCursor(this.tail, null);
    let acc = initialValue;
    let item;
    while (cursor.prev !== null) {
      item = cursor.prev;
      cursor.prev = item.prev;
      acc = fn2.call(thisArg, acc, item.data, item, this);
    }
    this.releaseCursor();
    return acc;
  }
  some(fn2, thisArg = this) {
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      if (fn2.call(thisArg, cursor.data, cursor, this)) {
        return true;
      }
    }
    return false;
  }
  map(fn2, thisArg = this) {
    const result = new List();
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      result.appendData(fn2.call(thisArg, cursor.data, cursor, this));
    }
    return result;
  }
  filter(fn2, thisArg = this) {
    const result = new List();
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      if (fn2.call(thisArg, cursor.data, cursor, this)) {
        result.appendData(cursor.data);
      }
    }
    return result;
  }
  nextUntil(start, fn2, thisArg = this) {
    if (start === null) {
      return;
    }
    const cursor = this.allocateCursor(null, start);
    while (cursor.next !== null) {
      const item = cursor.next;
      cursor.next = item.next;
      if (fn2.call(thisArg, item.data, item, this)) {
        break;
      }
    }
    this.releaseCursor();
  }
  prevUntil(start, fn2, thisArg = this) {
    if (start === null) {
      return;
    }
    const cursor = this.allocateCursor(start, null);
    while (cursor.prev !== null) {
      const item = cursor.prev;
      cursor.prev = item.prev;
      if (fn2.call(thisArg, item.data, item, this)) {
        break;
      }
    }
    this.releaseCursor();
  }
  // mutation
  clear() {
    this.head = null;
    this.tail = null;
  }
  copy() {
    const result = new List();
    for (let data of this) {
      result.appendData(data);
    }
    return result;
  }
  prepend(item) {
    this.updateCursors(null, item, this.head, item);
    if (this.head !== null) {
      this.head.prev = item;
      item.next = this.head;
    } else {
      this.tail = item;
    }
    this.head = item;
    return this;
  }
  prependData(data) {
    return this.prepend(List.createItem(data));
  }
  append(item) {
    return this.insert(item);
  }
  appendData(data) {
    return this.insert(List.createItem(data));
  }
  insert(item, before = null) {
    if (before !== null) {
      this.updateCursors(before.prev, item, before, item);
      if (before.prev === null) {
        if (this.head !== before) {
          throw new Error("before doesn't belong to list");
        }
        this.head = item;
        before.prev = item;
        item.next = before;
        this.updateCursors(null, item);
      } else {
        before.prev.next = item;
        item.prev = before.prev;
        before.prev = item;
        item.next = before;
      }
    } else {
      this.updateCursors(this.tail, item, null, item);
      if (this.tail !== null) {
        this.tail.next = item;
        item.prev = this.tail;
      } else {
        this.head = item;
      }
      this.tail = item;
    }
    return this;
  }
  insertData(data, before) {
    return this.insert(List.createItem(data), before);
  }
  remove(item) {
    this.updateCursors(item, item.prev, item, item.next);
    if (item.prev !== null) {
      item.prev.next = item.next;
    } else {
      if (this.head !== item) {
        throw new Error("item doesn't belong to list");
      }
      this.head = item.next;
    }
    if (item.next !== null) {
      item.next.prev = item.prev;
    } else {
      if (this.tail !== item) {
        throw new Error("item doesn't belong to list");
      }
      this.tail = item.prev;
    }
    item.prev = null;
    item.next = null;
    return item;
  }
  push(data) {
    this.insert(List.createItem(data));
  }
  pop() {
    return this.tail !== null ? this.remove(this.tail) : null;
  }
  unshift(data) {
    this.prepend(List.createItem(data));
  }
  shift() {
    return this.head !== null ? this.remove(this.head) : null;
  }
  prependList(list) {
    return this.insertList(list, this.head);
  }
  appendList(list) {
    return this.insertList(list);
  }
  insertList(list, before) {
    if (list.head === null) {
      return this;
    }
    if (before !== void 0 && before !== null) {
      this.updateCursors(before.prev, list.tail, before, list.head);
      if (before.prev !== null) {
        before.prev.next = list.head;
        list.head.prev = before.prev;
      } else {
        this.head = list.head;
      }
      before.prev = list.tail;
      list.tail.next = before;
    } else {
      this.updateCursors(this.tail, list.tail, null, list.head);
      if (this.tail !== null) {
        this.tail.next = list.head;
        list.head.prev = this.tail;
      } else {
        this.head = list.head;
      }
      this.tail = list.tail;
    }
    list.head = null;
    list.tail = null;
    return this;
  }
  replace(oldItem, newItemOrList) {
    if ("head" in newItemOrList) {
      this.insertList(newItemOrList, oldItem);
    } else {
      this.insert(newItemOrList, oldItem);
    }
    this.remove(oldItem);
  }
};
function createCustomError$1(name2, message) {
  const error2 = Object.create(SyntaxError.prototype);
  const errorStack = new Error();
  return Object.assign(error2, {
    name: name2,
    message,
    get stack() {
      return (errorStack.stack || "").replace(/^(.+\n){1,3}/, `${name2}: ${message}
`);
    }
  });
}
const MAX_LINE_LENGTH$1 = 100;
const OFFSET_CORRECTION$1 = 60;
const TAB_REPLACEMENT$1 = "    ";
function sourceFragment$1({ source, line, column, baseLine, baseColumn }, extraLines) {
  function processLines(start, end) {
    return lines.slice(start, end).map(
      (line2, idx) => String(start + idx + 1).padStart(maxNumLength) + " |" + line2
    ).join("\n");
  }
  const prelines = "\n".repeat(Math.max(baseLine - 1, 0));
  const precolumns = " ".repeat(Math.max(baseColumn - 1, 0));
  const lines = (prelines + precolumns + source).split(/\r\n?|\n|\f/);
  const startLine = Math.max(1, line - extraLines) - 1;
  const endLine = Math.min(line + extraLines, lines.length + 1);
  const maxNumLength = Math.max(4, String(endLine).length) + 1;
  let cutLeft = 0;
  column += (TAB_REPLACEMENT$1.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;
  if (column > MAX_LINE_LENGTH$1) {
    cutLeft = column - OFFSET_CORRECTION$1 + 3;
    column = OFFSET_CORRECTION$1 - 2;
  }
  for (let i = startLine; i <= endLine; i++) {
    if (i >= 0 && i < lines.length) {
      lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT$1);
      lines[i] = (cutLeft > 0 && lines[i].length > cutLeft ? "…" : "") + lines[i].substr(cutLeft, MAX_LINE_LENGTH$1 - 2) + (lines[i].length > cutLeft + MAX_LINE_LENGTH$1 - 1 ? "…" : "");
    }
  }
  return [
    processLines(startLine, line),
    new Array(column + maxNumLength + 2).join("-") + "^",
    processLines(line, endLine)
  ].filter(Boolean).join("\n").replace(/^(\s+\d+\s+\|\n)+/, "").replace(/\n(\s+\d+\s+\|)+$/, "");
}
function SyntaxError$4(message, source, offset, line, column, baseLine = 1, baseColumn = 1) {
  const error2 = Object.assign(createCustomError$1("SyntaxError", message), {
    source,
    offset,
    line,
    column,
    sourceFragment(extraLines) {
      return sourceFragment$1({ source, line, column, baseLine, baseColumn }, isNaN(extraLines) ? 0 : extraLines);
    },
    get formattedMessage() {
      return `Parse error: ${message}
` + sourceFragment$1({ source, line, column, baseLine, baseColumn }, 2);
    }
  });
  return error2;
}
function readSequence$2(recognizer) {
  const children = this.createList();
  let space = false;
  const context = {
    recognizer
  };
  while (!this.eof) {
    switch (this.tokenType) {
      case Comment$3:
        this.next();
        continue;
      case WhiteSpace$3:
        space = true;
        this.next();
        continue;
    }
    let child = recognizer.getNode.call(this, context);
    if (child === void 0) {
      break;
    }
    if (space) {
      if (recognizer.onWhiteSpace) {
        recognizer.onWhiteSpace.call(this, child, children, context);
      }
      space = false;
    }
    children.push(child);
  }
  if (space && recognizer.onWhiteSpace) {
    recognizer.onWhiteSpace.call(this, null, children, context);
  }
  return children;
}
const NOOP$1 = () => {
};
const EXCLAMATIONMARK$7 = 33;
const NUMBERSIGN$9 = 35;
const SEMICOLON$1 = 59;
const LEFTCURLYBRACKET$3 = 123;
const NULL$1 = 0;
function createParseContext$1(name2) {
  return function() {
    return this[name2]();
  };
}
function fetchParseValues$1(dict) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const name2 of Object.keys(dict)) {
    const item = dict[name2];
    const fn2 = item.parse || item;
    if (fn2) {
      result[name2] = fn2;
    }
  }
  return result;
}
function processConfig$1(config) {
  const parseConfig = {
    context: /* @__PURE__ */ Object.create(null),
    features: Object.assign(/* @__PURE__ */ Object.create(null), config.features),
    scope: Object.assign(/* @__PURE__ */ Object.create(null), config.scope),
    atrule: fetchParseValues$1(config.atrule),
    pseudo: fetchParseValues$1(config.pseudo),
    node: fetchParseValues$1(config.node)
  };
  for (const [name2, context] of Object.entries(config.parseContext)) {
    switch (typeof context) {
      case "function":
        parseConfig.context[name2] = context;
        break;
      case "string":
        parseConfig.context[name2] = createParseContext$1(context);
        break;
    }
  }
  return {
    config: parseConfig,
    ...parseConfig,
    ...parseConfig.node
  };
}
function createParser$1(config) {
  let source = "";
  let filename = "<unknown>";
  let needPositions = false;
  let onParseError = NOOP$1;
  let onParseErrorThrow = false;
  const locationMap = new OffsetToLocation$1();
  const parser = Object.assign(new TokenStream$1(), processConfig$1(config || {}), {
    parseAtrulePrelude: true,
    parseRulePrelude: true,
    parseValue: true,
    parseCustomProperty: false,
    readSequence: readSequence$2,
    consumeUntilBalanceEnd: () => 0,
    consumeUntilLeftCurlyBracket(code2) {
      return code2 === LEFTCURLYBRACKET$3 ? 1 : 0;
    },
    consumeUntilLeftCurlyBracketOrSemicolon(code2) {
      return code2 === LEFTCURLYBRACKET$3 || code2 === SEMICOLON$1 ? 1 : 0;
    },
    consumeUntilExclamationMarkOrSemicolon(code2) {
      return code2 === EXCLAMATIONMARK$7 || code2 === SEMICOLON$1 ? 1 : 0;
    },
    consumeUntilSemicolonIncluded(code2) {
      return code2 === SEMICOLON$1 ? 2 : 0;
    },
    createList() {
      return new List$1();
    },
    createSingleNodeList(node2) {
      return new List$1().appendData(node2);
    },
    getFirstListNode(list) {
      return list && list.first;
    },
    getLastListNode(list) {
      return list && list.last;
    },
    parseWithFallback(consumer, fallback) {
      const startIndex = this.tokenIndex;
      try {
        return consumer.call(this);
      } catch (e) {
        if (onParseErrorThrow) {
          throw e;
        }
        this.skip(startIndex - this.tokenIndex);
        const fallbackNode = fallback.call(this);
        onParseErrorThrow = true;
        onParseError(e, fallbackNode);
        onParseErrorThrow = false;
        return fallbackNode;
      }
    },
    lookupNonWSType(offset) {
      let type;
      do {
        type = this.lookupType(offset++);
        if (type !== WhiteSpace$3 && type !== Comment$3) {
          return type;
        }
      } while (type !== NULL$1);
      return NULL$1;
    },
    charCodeAt(offset) {
      return offset >= 0 && offset < source.length ? source.charCodeAt(offset) : 0;
    },
    substring(offsetStart, offsetEnd) {
      return source.substring(offsetStart, offsetEnd);
    },
    substrToCursor(start) {
      return this.source.substring(start, this.tokenStart);
    },
    cmpChar(offset, charCode) {
      return cmpChar$1(source, offset, charCode);
    },
    cmpStr(offsetStart, offsetEnd, str) {
      return cmpStr$1(source, offsetStart, offsetEnd, str);
    },
    consume(tokenType2) {
      const start = this.tokenStart;
      this.eat(tokenType2);
      return this.substrToCursor(start);
    },
    consumeFunctionName() {
      const name2 = source.substring(this.tokenStart, this.tokenEnd - 1);
      this.eat(Function$3);
      return name2;
    },
    consumeNumber(type) {
      const number2 = source.substring(this.tokenStart, consumeNumber$2(source, this.tokenStart));
      this.eat(type);
      return number2;
    },
    eat(tokenType2) {
      if (this.tokenType !== tokenType2) {
        const tokenName = tokenNames$1[tokenType2].slice(0, -6).replace(/-/g, " ").replace(/^./, (m) => m.toUpperCase());
        let message = `${/[[\](){}]/.test(tokenName) ? `"${tokenName}"` : tokenName} is expected`;
        let offset = this.tokenStart;
        switch (tokenType2) {
          case Ident$1:
            if (this.tokenType === Function$3 || this.tokenType === Url$4) {
              offset = this.tokenEnd - 1;
              message = "Identifier is expected but function found";
            } else {
              message = "Identifier is expected";
            }
            break;
          case Hash$3:
            if (this.isDelim(NUMBERSIGN$9)) {
              this.next();
              offset++;
              message = "Name is expected";
            }
            break;
          case Percentage$3:
            if (this.tokenType === Number$5) {
              offset = this.tokenEnd;
              message = "Percent sign is expected";
            }
            break;
        }
        this.error(message, offset);
      }
      this.next();
    },
    eatIdent(name2) {
      if (this.tokenType !== Ident$1 || this.lookupValue(0, name2) === false) {
        this.error(`Identifier "${name2}" is expected`);
      }
      this.next();
    },
    eatDelim(code2) {
      if (!this.isDelim(code2)) {
        this.error(`Delim "${String.fromCharCode(code2)}" is expected`);
      }
      this.next();
    },
    getLocation(start, end) {
      if (needPositions) {
        return locationMap.getLocationRange(
          start,
          end,
          filename
        );
      }
      return null;
    },
    getLocationFromList(list) {
      if (needPositions) {
        const head = this.getFirstListNode(list);
        const tail = this.getLastListNode(list);
        return locationMap.getLocationRange(
          head !== null ? head.loc.start.offset - locationMap.startOffset : this.tokenStart,
          tail !== null ? tail.loc.end.offset - locationMap.startOffset : this.tokenStart,
          filename
        );
      }
      return null;
    },
    error(message, offset) {
      const location = typeof offset !== "undefined" && offset < source.length ? locationMap.getLocation(offset) : this.eof ? locationMap.getLocation(findWhiteSpaceStart$1(source, source.length - 1)) : locationMap.getLocation(this.tokenStart);
      throw new SyntaxError$4(
        message || "Unexpected input",
        source,
        location.offset,
        location.line,
        location.column,
        locationMap.startLine,
        locationMap.startColumn
      );
    }
  });
  const parse2 = function(source_, options) {
    source = source_;
    options = options || {};
    parser.setSource(source, tokenize$4);
    locationMap.setSource(
      source,
      options.offset,
      options.line,
      options.column
    );
    filename = options.filename || "<unknown>";
    needPositions = Boolean(options.positions);
    onParseError = typeof options.onParseError === "function" ? options.onParseError : NOOP$1;
    onParseErrorThrow = false;
    parser.parseAtrulePrelude = "parseAtrulePrelude" in options ? Boolean(options.parseAtrulePrelude) : true;
    parser.parseRulePrelude = "parseRulePrelude" in options ? Boolean(options.parseRulePrelude) : true;
    parser.parseValue = "parseValue" in options ? Boolean(options.parseValue) : true;
    parser.parseCustomProperty = "parseCustomProperty" in options ? Boolean(options.parseCustomProperty) : false;
    const { context = "default", onComment } = options;
    if (context in parser.context === false) {
      throw new Error("Unknown context `" + context + "`");
    }
    if (typeof onComment === "function") {
      parser.forEachToken((type, start, end) => {
        if (type === Comment$3) {
          const loc = parser.getLocation(start, end);
          const value2 = cmpStr$1(source, end - 2, end, "*/") ? source.slice(start + 2, end - 2) : source.slice(start + 2, end);
          onComment(value2, loc);
        }
      });
    }
    const ast = parser.context[context].call(parser, options);
    if (!parser.eof) {
      parser.error();
    }
    return ast;
  };
  return Object.assign(parse2, {
    SyntaxError: SyntaxError$4,
    config: parser.config
  });
}
var sourceMapGenerator = {};
var base64Vlq = {};
var base64 = {};
var hasRequiredBase64;
function requireBase64() {
  if (hasRequiredBase64) return base64;
  hasRequiredBase64 = 1;
  var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  base64.encode = function(number2) {
    if (0 <= number2 && number2 < intToCharMap.length) {
      return intToCharMap[number2];
    }
    throw new TypeError("Must be between 0 and 63: " + number2);
  };
  base64.decode = function(charCode) {
    var bigA = 65;
    var bigZ = 90;
    var littleA = 97;
    var littleZ = 122;
    var zero2 = 48;
    var nine = 57;
    var plus = 43;
    var slash = 47;
    var littleOffset = 26;
    var numberOffset = 52;
    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }
    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }
    if (zero2 <= charCode && charCode <= nine) {
      return charCode - zero2 + numberOffset;
    }
    if (charCode == plus) {
      return 62;
    }
    if (charCode == slash) {
      return 63;
    }
    return -1;
  };
  return base64;
}
var hasRequiredBase64Vlq;
function requireBase64Vlq() {
  if (hasRequiredBase64Vlq) return base64Vlq;
  hasRequiredBase64Vlq = 1;
  var base642 = requireBase64();
  var VLQ_BASE_SHIFT = 5;
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
  var VLQ_BASE_MASK = VLQ_BASE - 1;
  var VLQ_CONTINUATION_BIT = VLQ_BASE;
  function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }
  base64Vlq.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base642.encode(digit);
    } while (vlq > 0);
    return encoded;
  };
  base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base642.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };
  return base64Vlq;
}
var util = {};
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  (function(exports) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports.urlGenerate = urlGenerate;
    var MAX_CACHED_INPUTS = 32;
    function lruMemoize(f) {
      var cache = [];
      return function(input) {
        for (var i = 0; i < cache.length; i++) {
          if (cache[i].input === input) {
            var temp = cache[0];
            cache[0] = cache[i];
            cache[i] = temp;
            return cache[0].result;
          }
        }
        var result = f(input);
        cache.unshift({
          input,
          result
        });
        if (cache.length > MAX_CACHED_INPUTS) {
          cache.pop();
        }
        return result;
      };
    }
    var normalize = lruMemoize(function normalize2(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports.isAbsolute(path);
      var parts = [];
      var start = 0;
      var i = 0;
      while (true) {
        start = i;
        i = path.indexOf("/", start);
        if (i === -1) {
          parts.push(path.slice(start));
          break;
        } else {
          parts.push(path.slice(start, i));
          while (i < path.length && path[i] === "/") {
            i++;
          }
        }
      }
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path = parts.join("/");
      if (path === "") {
        path = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    });
    exports.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports.join = join;
    exports.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;
    var supportsNullProto = (function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    })();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length2 = s.length;
      if (length2 < 9) {
        return false;
      }
      if (s.charCodeAt(length2 - 1) !== 95 || s.charCodeAt(length2 - 2) !== 95 || s.charCodeAt(length2 - 3) !== 111 || s.charCodeAt(length2 - 4) !== 116 || s.charCodeAt(length2 - 5) !== 111 || s.charCodeAt(length2 - 6) !== 114 || s.charCodeAt(length2 - 7) !== 112 || s.charCodeAt(length2 - 8) !== 95 || s.charCodeAt(length2 - 9) !== 95) {
        return false;
      }
      for (var i = length2 - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
      var cmp;
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports.computeSourceURL = computeSourceURL;
  })(util);
  return util;
}
var arraySet = {};
var hasRequiredArraySet;
function requireArraySet() {
  if (hasRequiredArraySet) return arraySet;
  hasRequiredArraySet = 1;
  var util2 = requireUtil();
  var has = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";
  function ArraySet() {
    this._array = [];
    this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
  }
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set2 = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set2.add(aArray[i], aAllowDuplicates);
    }
    return set2;
  };
  ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util2.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util2.toSetString(aStr);
      return has.call(this._set, sStr);
    }
  };
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) {
        return idx;
      }
    } else {
      var sStr = util2.toSetString(aStr);
      if (has.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error("No element indexed by " + aIdx);
  };
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };
  arraySet.ArraySet = ArraySet;
  return arraySet;
}
var mappingList = {};
var hasRequiredMappingList;
function requireMappingList() {
  if (hasRequiredMappingList) return mappingList;
  hasRequiredMappingList = 1;
  var util2 = requireUtil();
  function generatedPositionAfter(mappingA, mappingB) {
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util2.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }
  function MappingList() {
    this._array = [];
    this._sorted = true;
    this._last = { generatedLine: -1, generatedColumn: 0 };
  }
  MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };
  MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util2.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };
  mappingList.MappingList = MappingList;
  return mappingList;
}
var hasRequiredSourceMapGenerator;
function requireSourceMapGenerator() {
  if (hasRequiredSourceMapGenerator) return sourceMapGenerator;
  hasRequiredSourceMapGenerator = 1;
  var base64VLQ = requireBase64Vlq();
  var util2 = requireUtil();
  var ArraySet = requireArraySet().ArraySet;
  var MappingList = requireMappingList().MappingList;
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util2.getArg(aArgs, "file", null);
    this._sourceRoot = util2.getArg(aArgs, "sourceRoot", null);
    this._skipValidation = util2.getArg(aArgs, "skipValidation", false);
    this._ignoreInvalidMapping = util2.getArg(aArgs, "ignoreInvalidMapping", false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }
  SourceMapGenerator.prototype._version = 3;
  SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator(Object.assign(generatorOps || {}, {
      file: aSourceMapConsumer.file,
      sourceRoot
    }));
    aSourceMapConsumer.eachMapping(function(mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };
      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util2.relative(sourceRoot, newMapping.source);
        }
        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };
        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }
      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util2.relative(sourceRoot, sourceFile);
      }
      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };
  SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util2.getArg(aArgs, "generated");
    var original = util2.getArg(aArgs, "original", null);
    var source = util2.getArg(aArgs, "source", null);
    var name2 = util2.getArg(aArgs, "name", null);
    if (!this._skipValidation) {
      if (this._validateMapping(generated, original, source, name2) === false) {
        return;
      }
    }
    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }
    if (name2 != null) {
      name2 = String(name2);
      if (!this._names.has(name2)) {
        this._names.add(name2);
      }
    }
    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source,
      name: name2
    });
  };
  SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util2.relative(this._sourceRoot, source);
    }
    if (aSourceContent != null) {
      if (!this._sourcesContents) {
        this._sourcesContents = /* @__PURE__ */ Object.create(null);
      }
      this._sourcesContents[util2.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      delete this._sourcesContents[util2.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };
  SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    if (sourceRoot != null) {
      sourceFile = util2.relative(sourceRoot, sourceFile);
    }
    var newSources = new ArraySet();
    var newNames = new ArraySet();
    this._mappings.unsortedForEach(function(mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util2.join(aSourceMapPath, mapping.source);
          }
          if (sourceRoot != null) {
            mapping.source = util2.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }
      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }
      var name2 = mapping.name;
      if (name2 != null && !newNames.has(name2)) {
        newNames.add(name2);
      }
    }, this);
    this._sources = newSources;
    this._names = newNames;
    aSourceMapConsumer.sources.forEach(function(sourceFile2) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile2 = util2.join(aSourceMapPath, sourceFile2);
        }
        if (sourceRoot != null) {
          sourceFile2 = util2.relative(sourceRoot, sourceFile2);
        }
        this.setSourceContent(sourceFile2, content);
      }
    }, this);
  };
  SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
      var message = "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.";
      if (this._ignoreInvalidMapping) {
        if (typeof console !== "undefined" && console.warn) {
          console.warn(message);
        }
        return false;
      } else {
        throw new Error(message);
      }
    }
    if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
      return;
    } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
      return;
    } else {
      var message = "Invalid mapping: " + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      });
      if (this._ignoreInvalidMapping) {
        if (typeof console !== "undefined" && console.warn) {
          console.warn(message);
        }
        return false;
      } else {
        throw new Error(message);
      }
    }
  };
  SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = "";
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;
    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = "";
      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ";";
          previousGeneratedLine++;
        }
      } else {
        if (i > 0) {
          if (!util2.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ",";
        }
      }
      next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;
      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;
        next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;
        next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;
        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }
      result += next;
    }
    return result;
  };
  SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function(source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util2.relative(aSourceRoot, source);
      }
      var key = util2.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  };
  SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }
    return map;
  };
  SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };
  sourceMapGenerator.SourceMapGenerator = SourceMapGenerator;
  return sourceMapGenerator;
}
var sourceMapGeneratorExports = requireSourceMapGenerator();
const trackNodes$1 = /* @__PURE__ */ new Set(["Atrule", "Selector", "Declaration"]);
function generateSourceMap$1(handlers2) {
  const map = new sourceMapGeneratorExports.SourceMapGenerator();
  const generated = {
    line: 1,
    column: 0
  };
  const original = {
    line: 0,
    // should be zero to add first mapping
    column: 0
  };
  const activatedGenerated = {
    line: 1,
    column: 0
  };
  const activatedMapping = {
    generated: activatedGenerated
  };
  let line = 1;
  let column = 0;
  let sourceMappingActive = false;
  const origHandlersNode = handlers2.node;
  handlers2.node = function(node2) {
    if (node2.loc && node2.loc.start && trackNodes$1.has(node2.type)) {
      const nodeLine = node2.loc.start.line;
      const nodeColumn = node2.loc.start.column - 1;
      if (original.line !== nodeLine || original.column !== nodeColumn) {
        original.line = nodeLine;
        original.column = nodeColumn;
        generated.line = line;
        generated.column = column;
        if (sourceMappingActive) {
          sourceMappingActive = false;
          if (generated.line !== activatedGenerated.line || generated.column !== activatedGenerated.column) {
            map.addMapping(activatedMapping);
          }
        }
        sourceMappingActive = true;
        map.addMapping({
          source: node2.loc.source,
          original,
          generated
        });
      }
    }
    origHandlersNode.call(this, node2);
    if (sourceMappingActive && trackNodes$1.has(node2.type)) {
      activatedGenerated.line = line;
      activatedGenerated.column = column;
    }
  };
  const origHandlersEmit = handlers2.emit;
  handlers2.emit = function(value2, type, auto) {
    for (let i = 0; i < value2.length; i++) {
      if (value2.charCodeAt(i) === 10) {
        line++;
        column = 0;
      } else {
        column++;
      }
    }
    origHandlersEmit(value2, type, auto);
  };
  const origHandlersResult = handlers2.result;
  handlers2.result = function() {
    if (sourceMappingActive) {
      map.addMapping(activatedMapping);
    }
    return {
      css: origHandlersResult(),
      map
    };
  };
  return handlers2;
}
const PLUSSIGN$j = 43;
const HYPHENMINUS$d = 45;
const code$1 = (type, value2) => {
  if (type === Delim$1) {
    type = value2;
  }
  if (typeof type === "string") {
    const charCode = type.charCodeAt(0);
    return charCode > 127 ? 32768 : charCode << 8;
  }
  return type;
};
const specPairs$1 = [
  [Ident$1, Ident$1],
  [Ident$1, Function$3],
  [Ident$1, Url$4],
  [Ident$1, BadUrl$1],
  [Ident$1, "-"],
  [Ident$1, Number$5],
  [Ident$1, Percentage$3],
  [Ident$1, Dimension$3],
  [Ident$1, CDC$3],
  [Ident$1, LeftParenthesis$1],
  [AtKeyword$1, Ident$1],
  [AtKeyword$1, Function$3],
  [AtKeyword$1, Url$4],
  [AtKeyword$1, BadUrl$1],
  [AtKeyword$1, "-"],
  [AtKeyword$1, Number$5],
  [AtKeyword$1, Percentage$3],
  [AtKeyword$1, Dimension$3],
  [AtKeyword$1, CDC$3],
  [Hash$3, Ident$1],
  [Hash$3, Function$3],
  [Hash$3, Url$4],
  [Hash$3, BadUrl$1],
  [Hash$3, "-"],
  [Hash$3, Number$5],
  [Hash$3, Percentage$3],
  [Hash$3, Dimension$3],
  [Hash$3, CDC$3],
  [Dimension$3, Ident$1],
  [Dimension$3, Function$3],
  [Dimension$3, Url$4],
  [Dimension$3, BadUrl$1],
  [Dimension$3, "-"],
  [Dimension$3, Number$5],
  [Dimension$3, Percentage$3],
  [Dimension$3, Dimension$3],
  [Dimension$3, CDC$3],
  ["#", Ident$1],
  ["#", Function$3],
  ["#", Url$4],
  ["#", BadUrl$1],
  ["#", "-"],
  ["#", Number$5],
  ["#", Percentage$3],
  ["#", Dimension$3],
  ["#", CDC$3],
  // https://github.com/w3c/csswg-drafts/pull/6874
  ["-", Ident$1],
  ["-", Function$3],
  ["-", Url$4],
  ["-", BadUrl$1],
  ["-", "-"],
  ["-", Number$5],
  ["-", Percentage$3],
  ["-", Dimension$3],
  ["-", CDC$3],
  // https://github.com/w3c/csswg-drafts/pull/6874
  [Number$5, Ident$1],
  [Number$5, Function$3],
  [Number$5, Url$4],
  [Number$5, BadUrl$1],
  [Number$5, Number$5],
  [Number$5, Percentage$3],
  [Number$5, Dimension$3],
  [Number$5, "%"],
  [Number$5, CDC$3],
  // https://github.com/w3c/csswg-drafts/pull/6874
  ["@", Ident$1],
  ["@", Function$3],
  ["@", Url$4],
  ["@", BadUrl$1],
  ["@", "-"],
  ["@", CDC$3],
  // https://github.com/w3c/csswg-drafts/pull/6874
  [".", Number$5],
  [".", Percentage$3],
  [".", Dimension$3],
  ["+", Number$5],
  ["+", Percentage$3],
  ["+", Dimension$3],
  ["/", "*"]
];
const safePairs$1 = specPairs$1.concat([
  [Ident$1, Hash$3],
  [Dimension$3, Hash$3],
  [Hash$3, Hash$3],
  [AtKeyword$1, LeftParenthesis$1],
  [AtKeyword$1, String$4],
  [AtKeyword$1, Colon$1],
  [Percentage$3, Percentage$3],
  [Percentage$3, Dimension$3],
  [Percentage$3, Function$3],
  [Percentage$3, "-"],
  [RightParenthesis$1, Ident$1],
  [RightParenthesis$1, Function$3],
  [RightParenthesis$1, Percentage$3],
  [RightParenthesis$1, Dimension$3],
  [RightParenthesis$1, Hash$3],
  [RightParenthesis$1, "-"]
]);
function createMap$1(pairs) {
  const isWhiteSpaceRequired = new Set(
    pairs.map(([prev, next]) => code$1(prev) << 16 | code$1(next))
  );
  return function(prevCode, type, value2) {
    const nextCode = code$1(type, value2);
    const nextCharCode = value2.charCodeAt(0);
    const emitWs = nextCharCode === HYPHENMINUS$d && type !== Ident$1 && type !== Function$3 && type !== CDC$3 || nextCharCode === PLUSSIGN$j ? isWhiteSpaceRequired.has(prevCode << 16 | nextCharCode << 8) : isWhiteSpaceRequired.has(prevCode << 16 | nextCode);
    if (emitWs) {
      this.emit(" ", WhiteSpace$3, true);
    }
    return nextCode;
  };
}
const spec$1 = createMap$1(specPairs$1);
const safe$1 = createMap$1(safePairs$1);
const tokenBefore$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  safe: safe$1,
  spec: spec$1
}, Symbol.toStringTag, { value: "Module" }));
const REVERSESOLIDUS$1 = 92;
function processChildren$1(node2, delimeter) {
  if (typeof delimeter === "function") {
    let prev = null;
    node2.children.forEach((node3) => {
      if (prev !== null) {
        delimeter.call(this, prev);
      }
      this.node(node3);
      prev = node3;
    });
    return;
  }
  node2.children.forEach(this.node, this);
}
function processChunk$1(chunk) {
  tokenize$4(chunk, (type, start, end) => {
    this.token(type, chunk.slice(start, end));
  });
}
function createGenerator$1(config) {
  const types = /* @__PURE__ */ new Map();
  for (let [name2, item] of Object.entries(config.node)) {
    const fn2 = item.generate || item;
    if (typeof fn2 === "function") {
      types.set(name2, item.generate || item);
    }
  }
  return function(node2, options) {
    let buffer2 = "";
    let prevCode = 0;
    let handlers2 = {
      node(node3) {
        if (types.has(node3.type)) {
          types.get(node3.type).call(publicApi, node3);
        } else {
          throw new Error("Unknown node type: " + node3.type);
        }
      },
      tokenBefore: safe$1,
      token(type, value2) {
        prevCode = this.tokenBefore(prevCode, type, value2);
        this.emit(value2, type, false);
        if (type === Delim$1 && value2.charCodeAt(0) === REVERSESOLIDUS$1) {
          this.emit("\n", WhiteSpace$3, true);
        }
      },
      emit(value2) {
        buffer2 += value2;
      },
      result() {
        return buffer2;
      }
    };
    if (options) {
      if (typeof options.decorator === "function") {
        handlers2 = options.decorator(handlers2);
      }
      if (options.sourceMap) {
        handlers2 = generateSourceMap$1(handlers2);
      }
      if (options.mode in tokenBefore$1) {
        handlers2.tokenBefore = tokenBefore$1[options.mode];
      }
    }
    const publicApi = {
      node: (node3) => handlers2.node(node3),
      children: processChildren$1,
      token: (type, value2) => handlers2.token(type, value2),
      tokenize: processChunk$1
    };
    handlers2.node(node2);
    return handlers2.result();
  };
}
function createConvertor$1(walk2) {
  return {
    fromPlainObject(ast) {
      walk2(ast, {
        enter(node2) {
          if (node2.children && node2.children instanceof List$1 === false) {
            node2.children = new List$1().fromArray(node2.children);
          }
        }
      });
      return ast;
    },
    toPlainObject(ast) {
      walk2(ast, {
        leave(node2) {
          if (node2.children && node2.children instanceof List$1) {
            node2.children = node2.children.toArray();
          }
        }
      });
      return ast;
    }
  };
}
const { hasOwnProperty: hasOwnProperty$b } = Object.prototype;
const noop$5 = function() {
};
function ensureFunction$3(value2) {
  return typeof value2 === "function" ? value2 : noop$5;
}
function invokeForType$1(fn2, type) {
  return function(node2, item, list) {
    if (node2.type === type) {
      fn2.call(this, node2, item, list);
    }
  };
}
function getWalkersFromStructure$1(name2, nodeType) {
  const structure2 = nodeType.structure;
  const walkers = [];
  for (const key in structure2) {
    if (hasOwnProperty$b.call(structure2, key) === false) {
      continue;
    }
    let fieldTypes = structure2[key];
    const walker = {
      name: key,
      type: false,
      nullable: false
    };
    if (!Array.isArray(fieldTypes)) {
      fieldTypes = [fieldTypes];
    }
    for (const fieldType of fieldTypes) {
      if (fieldType === null) {
        walker.nullable = true;
      } else if (typeof fieldType === "string") {
        walker.type = "node";
      } else if (Array.isArray(fieldType)) {
        walker.type = "list";
      }
    }
    if (walker.type) {
      walkers.push(walker);
    }
  }
  if (walkers.length) {
    return {
      context: nodeType.walkContext,
      fields: walkers
    };
  }
  return null;
}
function getTypesFromConfig$1(config) {
  const types = {};
  for (const name2 in config.node) {
    if (hasOwnProperty$b.call(config.node, name2)) {
      const nodeType = config.node[name2];
      if (!nodeType.structure) {
        throw new Error("Missed `structure` field in `" + name2 + "` node type definition");
      }
      types[name2] = getWalkersFromStructure$1(name2, nodeType);
    }
  }
  return types;
}
function createTypeIterator$1(config, reverse) {
  const fields = config.fields.slice();
  const contextName = config.context;
  const useContext = typeof contextName === "string";
  if (reverse) {
    fields.reverse();
  }
  return function(node2, context, walk2, walkReducer) {
    let prevContextValue;
    if (useContext) {
      prevContextValue = context[contextName];
      context[contextName] = node2;
    }
    for (const field of fields) {
      const ref = node2[field.name];
      if (!field.nullable || ref) {
        if (field.type === "list") {
          const breakWalk = reverse ? ref.reduceRight(walkReducer, false) : ref.reduce(walkReducer, false);
          if (breakWalk) {
            return true;
          }
        } else if (walk2(ref)) {
          return true;
        }
      }
    }
    if (useContext) {
      context[contextName] = prevContextValue;
    }
  };
}
function createFastTraveralMap$1({
  StyleSheet: StyleSheet2,
  Atrule: Atrule2,
  Rule: Rule2,
  Block: Block2,
  DeclarationList: DeclarationList2
}) {
  return {
    Atrule: {
      StyleSheet: StyleSheet2,
      Atrule: Atrule2,
      Rule: Rule2,
      Block: Block2
    },
    Rule: {
      StyleSheet: StyleSheet2,
      Atrule: Atrule2,
      Rule: Rule2,
      Block: Block2
    },
    Declaration: {
      StyleSheet: StyleSheet2,
      Atrule: Atrule2,
      Rule: Rule2,
      Block: Block2,
      DeclarationList: DeclarationList2
    }
  };
}
function createWalker$1(config) {
  const types = getTypesFromConfig$1(config);
  const iteratorsNatural = {};
  const iteratorsReverse = {};
  const breakWalk = Symbol("break-walk");
  const skipNode = Symbol("skip-node");
  for (const name2 in types) {
    if (hasOwnProperty$b.call(types, name2) && types[name2] !== null) {
      iteratorsNatural[name2] = createTypeIterator$1(types[name2], false);
      iteratorsReverse[name2] = createTypeIterator$1(types[name2], true);
    }
  }
  const fastTraversalIteratorsNatural = createFastTraveralMap$1(iteratorsNatural);
  const fastTraversalIteratorsReverse = createFastTraveralMap$1(iteratorsReverse);
  const walk2 = function(root, options) {
    function walkNode(node2, item, list) {
      const enterRet = enter.call(context, node2, item, list);
      if (enterRet === breakWalk) {
        return true;
      }
      if (enterRet === skipNode) {
        return false;
      }
      if (iterators.hasOwnProperty(node2.type)) {
        if (iterators[node2.type](node2, context, walkNode, walkReducer)) {
          return true;
        }
      }
      if (leave.call(context, node2, item, list) === breakWalk) {
        return true;
      }
      return false;
    }
    let enter = noop$5;
    let leave = noop$5;
    let iterators = iteratorsNatural;
    let walkReducer = (ret, data, item, list) => ret || walkNode(data, item, list);
    const context = {
      break: breakWalk,
      skip: skipNode,
      root,
      stylesheet: null,
      atrule: null,
      atrulePrelude: null,
      rule: null,
      selector: null,
      block: null,
      declaration: null,
      function: null
    };
    if (typeof options === "function") {
      enter = options;
    } else if (options) {
      enter = ensureFunction$3(options.enter);
      leave = ensureFunction$3(options.leave);
      if (options.reverse) {
        iterators = iteratorsReverse;
      }
      if (options.visit) {
        if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
          iterators = options.reverse ? fastTraversalIteratorsReverse[options.visit] : fastTraversalIteratorsNatural[options.visit];
        } else if (!types.hasOwnProperty(options.visit)) {
          throw new Error("Bad value `" + options.visit + "` for `visit` option (should be: " + Object.keys(types).sort().join(", ") + ")");
        }
        enter = invokeForType$1(enter, options.visit);
        leave = invokeForType$1(leave, options.visit);
      }
    }
    if (enter === noop$5 && leave === noop$5) {
      throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
    }
    walkNode(root);
  };
  walk2.break = breakWalk;
  walk2.skip = skipNode;
  walk2.find = function(ast, fn2) {
    let found = null;
    walk2(ast, function(node2, item, list) {
      if (fn2.call(this, node2, item, list)) {
        found = node2;
        return breakWalk;
      }
    });
    return found;
  };
  walk2.findLast = function(ast, fn2) {
    let found = null;
    walk2(ast, {
      reverse: true,
      enter(node2, item, list) {
        if (fn2.call(this, node2, item, list)) {
          found = node2;
          return breakWalk;
        }
      }
    });
    return found;
  };
  walk2.findAll = function(ast, fn2) {
    const found = [];
    walk2(ast, function(node2, item, list) {
      if (fn2.call(this, node2, item, list)) {
        found.push(node2);
      }
    });
    return found;
  };
  return walk2;
}
function noop$4(value2) {
  return value2;
}
function generateMultiplier$1(multiplier) {
  const { min, max, comma } = multiplier;
  if (min === 0 && max === 0) {
    return comma ? "#?" : "*";
  }
  if (min === 0 && max === 1) {
    return "?";
  }
  if (min === 1 && max === 0) {
    return comma ? "#" : "+";
  }
  if (min === 1 && max === 1) {
    return "";
  }
  return (comma ? "#" : "") + (min === max ? "{" + min + "}" : "{" + min + "," + (max !== 0 ? max : "") + "}");
}
function generateTypeOpts$1(node2) {
  switch (node2.type) {
    case "Range":
      return " [" + (node2.min === null ? "-∞" : node2.min) + "," + (node2.max === null ? "∞" : node2.max) + "]";
    default:
      throw new Error("Unknown node type `" + node2.type + "`");
  }
}
function generateSequence$1(node2, decorate, forceBraces, compact) {
  const combinator = node2.combinator === " " || compact ? node2.combinator : " " + node2.combinator + " ";
  const result = node2.terms.map((term) => internalGenerate$1(term, decorate, forceBraces, compact)).join(combinator);
  if (node2.explicit || forceBraces) {
    return (compact || result[0] === "," ? "[" : "[ ") + result + (compact ? "]" : " ]");
  }
  return result;
}
function internalGenerate$1(node2, decorate, forceBraces, compact) {
  let result;
  switch (node2.type) {
    case "Group":
      result = generateSequence$1(node2, decorate, forceBraces, compact) + (node2.disallowEmpty ? "!" : "");
      break;
    case "Multiplier":
      return internalGenerate$1(node2.term, decorate, forceBraces, compact) + decorate(generateMultiplier$1(node2), node2);
    case "Boolean":
      result = "<boolean-expr[" + internalGenerate$1(node2.term, decorate, forceBraces, compact) + "]>";
      break;
    case "Type":
      result = "<" + node2.name + (node2.opts ? decorate(generateTypeOpts$1(node2.opts), node2.opts) : "") + ">";
      break;
    case "Property":
      result = "<'" + node2.name + "'>";
      break;
    case "Keyword":
      result = node2.name;
      break;
    case "AtKeyword":
      result = "@" + node2.name;
      break;
    case "Function":
      result = node2.name + "(";
      break;
    case "String":
    case "Token":
      result = node2.value;
      break;
    case "Comma":
      result = ",";
      break;
    default:
      throw new Error("Unknown node type `" + node2.type + "`");
  }
  return decorate(result, node2);
}
function generate$1u(node2, options) {
  let decorate = noop$4;
  let forceBraces = false;
  let compact = false;
  if (typeof options === "function") {
    decorate = options;
  } else if (options) {
    forceBraces = Boolean(options.forceBraces);
    compact = Boolean(options.compact);
    if (typeof options.decorate === "function") {
      decorate = options.decorate;
    }
  }
  return internalGenerate$1(node2, decorate, forceBraces, compact);
}
const defaultLoc$1 = { offset: 0, line: 1, column: 1 };
function locateMismatch$1(matchResult, node2) {
  const tokens = matchResult.tokens;
  const longestMatch = matchResult.longestMatch;
  const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
  const badNode = mismatchNode !== node2 ? mismatchNode : null;
  let mismatchOffset = 0;
  let mismatchLength = 0;
  let entries = 0;
  let css = "";
  let start;
  let end;
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i].value;
    if (i === longestMatch) {
      mismatchLength = token.length;
      mismatchOffset = css.length;
    }
    if (badNode !== null && tokens[i].node === badNode) {
      if (i <= longestMatch) {
        entries++;
      } else {
        entries = 0;
      }
    }
    css += token;
  }
  if (longestMatch === tokens.length || entries > 1) {
    start = fromLoc$1(badNode || node2, "end") || buildLoc$1(defaultLoc$1, css);
    end = buildLoc$1(start);
  } else {
    start = fromLoc$1(badNode, "start") || buildLoc$1(fromLoc$1(node2, "start") || defaultLoc$1, css.slice(0, mismatchOffset));
    end = fromLoc$1(badNode, "end") || buildLoc$1(start, css.substr(mismatchOffset, mismatchLength));
  }
  return {
    css,
    mismatchOffset,
    mismatchLength,
    start,
    end
  };
}
function fromLoc$1(node2, point) {
  const value2 = node2 && node2.loc && node2.loc[point];
  if (value2) {
    return "line" in value2 ? buildLoc$1(value2) : value2;
  }
  return null;
}
function buildLoc$1({ offset, line, column }, extra) {
  const loc = {
    offset,
    line,
    column
  };
  if (extra) {
    const lines = extra.split(/\n|\r\n?|\f/);
    loc.offset += extra.length;
    loc.line += lines.length - 1;
    loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
  }
  return loc;
}
const SyntaxReferenceError$1 = function(type, referenceName) {
  const error2 = createCustomError$1(
    "SyntaxReferenceError",
    type + (referenceName ? " `" + referenceName + "`" : "")
  );
  error2.reference = referenceName;
  return error2;
};
const SyntaxMatchError$1 = function(message, syntax2, node2, matchResult) {
  const error2 = createCustomError$1("SyntaxMatchError", message);
  const {
    css,
    mismatchOffset,
    mismatchLength,
    start,
    end
  } = locateMismatch$1(matchResult, node2);
  error2.rawMessage = message;
  error2.syntax = syntax2 ? generate$1u(syntax2) : "<generic>";
  error2.css = css;
  error2.mismatchOffset = mismatchOffset;
  error2.mismatchLength = mismatchLength;
  error2.message = message + "\n  syntax: " + error2.syntax + "\n   value: " + (css || "<empty string>") + "\n  --------" + new Array(error2.mismatchOffset + 1).join("-") + "^";
  Object.assign(error2, start);
  error2.loc = {
    source: node2 && node2.loc && node2.loc.source || "<unknown>",
    start,
    end
  };
  return error2;
};
const keywords$1 = /* @__PURE__ */ new Map();
const properties$1 = /* @__PURE__ */ new Map();
const HYPHENMINUS$c = 45;
const keyword$1 = getKeywordDescriptor$1;
const property$1 = getPropertyDescriptor$1;
function isCustomProperty$1(str, offset) {
  offset = offset || 0;
  return str.length - offset >= 2 && str.charCodeAt(offset) === HYPHENMINUS$c && str.charCodeAt(offset + 1) === HYPHENMINUS$c;
}
function getVendorPrefix$1(str, offset) {
  offset = offset || 0;
  if (str.length - offset >= 3) {
    if (str.charCodeAt(offset) === HYPHENMINUS$c && str.charCodeAt(offset + 1) !== HYPHENMINUS$c) {
      const secondDashIndex = str.indexOf("-", offset + 2);
      if (secondDashIndex !== -1) {
        return str.substring(offset, secondDashIndex + 1);
      }
    }
  }
  return "";
}
function getKeywordDescriptor$1(keyword2) {
  if (keywords$1.has(keyword2)) {
    return keywords$1.get(keyword2);
  }
  const name2 = keyword2.toLowerCase();
  let descriptor = keywords$1.get(name2);
  if (descriptor === void 0) {
    const custom = isCustomProperty$1(name2, 0);
    const vendor = !custom ? getVendorPrefix$1(name2, 0) : "";
    descriptor = Object.freeze({
      basename: name2.substr(vendor.length),
      name: name2,
      prefix: vendor,
      vendor,
      custom
    });
  }
  keywords$1.set(keyword2, descriptor);
  return descriptor;
}
function getPropertyDescriptor$1(property2) {
  if (properties$1.has(property2)) {
    return properties$1.get(property2);
  }
  let name2 = property2;
  let hack = property2[0];
  if (hack === "/") {
    hack = property2[1] === "/" ? "//" : "/";
  } else if (hack !== "_" && hack !== "*" && hack !== "$" && hack !== "#" && hack !== "+" && hack !== "&") {
    hack = "";
  }
  const custom = isCustomProperty$1(name2, hack.length);
  if (!custom) {
    name2 = name2.toLowerCase();
    if (properties$1.has(name2)) {
      const descriptor2 = properties$1.get(name2);
      properties$1.set(property2, descriptor2);
      return descriptor2;
    }
  }
  const vendor = !custom ? getVendorPrefix$1(name2, hack.length) : "";
  const prefix = name2.substr(0, hack.length + vendor.length);
  const descriptor = Object.freeze({
    basename: name2.substr(prefix.length),
    name: name2.substr(hack.length),
    hack,
    vendor,
    prefix,
    custom
  });
  properties$1.set(property2, descriptor);
  return descriptor;
}
const cssWideKeywords$1 = [
  "initial",
  "inherit",
  "unset",
  "revert",
  "revert-layer"
];
const PLUSSIGN$i = 43;
const HYPHENMINUS$b = 45;
const N$8 = 110;
const DISALLOW_SIGN$3 = true;
const ALLOW_SIGN$3 = false;
function isDelim$3(token, code2) {
  return token !== null && token.type === Delim$1 && token.value.charCodeAt(0) === code2;
}
function skipSC$1(token, offset, getNextToken) {
  while (token !== null && (token.type === WhiteSpace$3 || token.type === Comment$3)) {
    token = getNextToken(++offset);
  }
  return offset;
}
function checkInteger$3(token, valueOffset, disallowSign, offset) {
  if (!token) {
    return 0;
  }
  const code2 = token.value.charCodeAt(valueOffset);
  if (code2 === PLUSSIGN$i || code2 === HYPHENMINUS$b) {
    if (disallowSign) {
      return 0;
    }
    valueOffset++;
  }
  for (; valueOffset < token.value.length; valueOffset++) {
    if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
      return 0;
    }
  }
  return offset + 1;
}
function consumeB$3(token, offset_, getNextToken) {
  let sign = false;
  let offset = skipSC$1(token, offset_, getNextToken);
  token = getNextToken(offset);
  if (token === null) {
    return offset_;
  }
  if (token.type !== Number$5) {
    if (isDelim$3(token, PLUSSIGN$i) || isDelim$3(token, HYPHENMINUS$b)) {
      sign = true;
      offset = skipSC$1(getNextToken(++offset), offset, getNextToken);
      token = getNextToken(offset);
      if (token === null || token.type !== Number$5) {
        return 0;
      }
    } else {
      return offset_;
    }
  }
  if (!sign) {
    const code2 = token.value.charCodeAt(0);
    if (code2 !== PLUSSIGN$i && code2 !== HYPHENMINUS$b) {
      return 0;
    }
  }
  return checkInteger$3(token, sign ? 0 : 1, sign, offset);
}
function anPlusB$1(token, getNextToken) {
  let offset = 0;
  if (!token) {
    return 0;
  }
  if (token.type === Number$5) {
    return checkInteger$3(token, 0, ALLOW_SIGN$3, offset);
  } else if (token.type === Ident$1 && token.value.charCodeAt(0) === HYPHENMINUS$b) {
    if (!cmpChar$1(token.value, 1, N$8)) {
      return 0;
    }
    switch (token.value.length) {
      // -n
      // -n <signed-integer>
      // -n ['+' | '-'] <signless-integer>
      case 2:
        return consumeB$3(getNextToken(++offset), offset, getNextToken);
      // -n- <signless-integer>
      case 3:
        if (token.value.charCodeAt(2) !== HYPHENMINUS$b) {
          return 0;
        }
        offset = skipSC$1(getNextToken(++offset), offset, getNextToken);
        token = getNextToken(offset);
        return checkInteger$3(token, 0, DISALLOW_SIGN$3, offset);
      // <dashndashdigit-ident>
      default:
        if (token.value.charCodeAt(2) !== HYPHENMINUS$b) {
          return 0;
        }
        return checkInteger$3(token, 3, DISALLOW_SIGN$3, offset);
    }
  } else if (token.type === Ident$1 || isDelim$3(token, PLUSSIGN$i) && getNextToken(offset + 1).type === Ident$1) {
    if (token.type !== Ident$1) {
      token = getNextToken(++offset);
    }
    if (token === null || !cmpChar$1(token.value, 0, N$8)) {
      return 0;
    }
    switch (token.value.length) {
      // '+'? n
      // '+'? n <signed-integer>
      // '+'? n ['+' | '-'] <signless-integer>
      case 1:
        return consumeB$3(getNextToken(++offset), offset, getNextToken);
      // '+'? n- <signless-integer>
      case 2:
        if (token.value.charCodeAt(1) !== HYPHENMINUS$b) {
          return 0;
        }
        offset = skipSC$1(getNextToken(++offset), offset, getNextToken);
        token = getNextToken(offset);
        return checkInteger$3(token, 0, DISALLOW_SIGN$3, offset);
      // '+'? <ndashdigit-ident>
      default:
        if (token.value.charCodeAt(1) !== HYPHENMINUS$b) {
          return 0;
        }
        return checkInteger$3(token, 2, DISALLOW_SIGN$3, offset);
    }
  } else if (token.type === Dimension$3) {
    let code2 = token.value.charCodeAt(0);
    let sign = code2 === PLUSSIGN$i || code2 === HYPHENMINUS$b ? 1 : 0;
    let i = sign;
    for (; i < token.value.length; i++) {
      if (!isDigit$2(token.value.charCodeAt(i))) {
        break;
      }
    }
    if (i === sign) {
      return 0;
    }
    if (!cmpChar$1(token.value, i, N$8)) {
      return 0;
    }
    if (i + 1 === token.value.length) {
      return consumeB$3(getNextToken(++offset), offset, getNextToken);
    } else {
      if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$b) {
        return 0;
      }
      if (i + 2 === token.value.length) {
        offset = skipSC$1(getNextToken(++offset), offset, getNextToken);
        token = getNextToken(offset);
        return checkInteger$3(token, 0, DISALLOW_SIGN$3, offset);
      } else {
        return checkInteger$3(token, i + 2, DISALLOW_SIGN$3, offset);
      }
    }
  }
  return 0;
}
const PLUSSIGN$h = 43;
const HYPHENMINUS$a = 45;
const QUESTIONMARK$5 = 63;
const U$3 = 117;
function isDelim$2(token, code2) {
  return token !== null && token.type === Delim$1 && token.value.charCodeAt(0) === code2;
}
function startsWith$3(token, code2) {
  return token.value.charCodeAt(0) === code2;
}
function hexSequence$1(token, offset, allowDash) {
  let hexlen = 0;
  for (let pos = offset; pos < token.value.length; pos++) {
    const code2 = token.value.charCodeAt(pos);
    if (code2 === HYPHENMINUS$a && allowDash && hexlen !== 0) {
      hexSequence$1(token, offset + hexlen + 1, false);
      return 6;
    }
    if (!isHexDigit$1(code2)) {
      return 0;
    }
    if (++hexlen > 6) {
      return 0;
    }
  }
  return hexlen;
}
function withQuestionMarkSequence$1(consumed, length2, getNextToken) {
  if (!consumed) {
    return 0;
  }
  while (isDelim$2(getNextToken(length2), QUESTIONMARK$5)) {
    if (++consumed > 6) {
      return 0;
    }
    length2++;
  }
  return length2;
}
function urange$1(token, getNextToken) {
  let length2 = 0;
  if (token === null || token.type !== Ident$1 || !cmpChar$1(token.value, 0, U$3)) {
    return 0;
  }
  token = getNextToken(++length2);
  if (token === null) {
    return 0;
  }
  if (isDelim$2(token, PLUSSIGN$h)) {
    token = getNextToken(++length2);
    if (token === null) {
      return 0;
    }
    if (token.type === Ident$1) {
      return withQuestionMarkSequence$1(hexSequence$1(token, 0, true), ++length2, getNextToken);
    }
    if (isDelim$2(token, QUESTIONMARK$5)) {
      return withQuestionMarkSequence$1(1, ++length2, getNextToken);
    }
    return 0;
  }
  if (token.type === Number$5) {
    const consumedHexLength = hexSequence$1(token, 1, true);
    if (consumedHexLength === 0) {
      return 0;
    }
    token = getNextToken(++length2);
    if (token === null) {
      return length2;
    }
    if (token.type === Dimension$3 || token.type === Number$5) {
      if (!startsWith$3(token, HYPHENMINUS$a) || !hexSequence$1(token, 1, false)) {
        return 0;
      }
      return length2 + 1;
    }
    return withQuestionMarkSequence$1(consumedHexLength, length2, getNextToken);
  }
  if (token.type === Dimension$3) {
    return withQuestionMarkSequence$1(hexSequence$1(token, 1, true), ++length2, getNextToken);
  }
  return 0;
}
const calcFunctionNames$1 = ["calc(", "-moz-calc(", "-webkit-calc("];
const balancePair$2 = /* @__PURE__ */ new Map([
  [Function$3, RightParenthesis$1],
  [LeftParenthesis$1, RightParenthesis$1],
  [LeftSquareBracket$1, RightSquareBracket$1],
  [LeftCurlyBracket$1, RightCurlyBracket$1]
]);
function charCodeAt$1(str, index) {
  return index < str.length ? str.charCodeAt(index) : 0;
}
function eqStr$1(actual, expected) {
  return cmpStr$1(actual, 0, actual.length, expected);
}
function eqStrAny$1(actual, expected) {
  for (let i = 0; i < expected.length; i++) {
    if (eqStr$1(actual, expected[i])) {
      return true;
    }
  }
  return false;
}
function isPostfixIeHack$1(str, offset) {
  if (offset !== str.length - 2) {
    return false;
  }
  return charCodeAt$1(str, offset) === 92 && // U+005C REVERSE SOLIDUS (\)
  isDigit$2(charCodeAt$1(str, offset + 1));
}
function outOfRange$1(opts, value2, numEnd) {
  if (opts && opts.type === "Range") {
    const num = Number(
      numEnd !== void 0 && numEnd !== value2.length ? value2.substr(0, numEnd) : value2
    );
    if (isNaN(num)) {
      return true;
    }
    if (opts.min !== null && num < opts.min && typeof opts.min !== "string") {
      return true;
    }
    if (opts.max !== null && num > opts.max && typeof opts.max !== "string") {
      return true;
    }
  }
  return false;
}
function consumeFunction$1(token, getNextToken) {
  let balanceCloseType = 0;
  let balanceStash = [];
  let length2 = 0;
  scan:
    do {
      switch (token.type) {
        case RightCurlyBracket$1:
        case RightParenthesis$1:
        case RightSquareBracket$1:
          if (token.type !== balanceCloseType) {
            break scan;
          }
          balanceCloseType = balanceStash.pop();
          if (balanceStash.length === 0) {
            length2++;
            break scan;
          }
          break;
        case Function$3:
        case LeftParenthesis$1:
        case LeftSquareBracket$1:
        case LeftCurlyBracket$1:
          balanceStash.push(balanceCloseType);
          balanceCloseType = balancePair$2.get(token.type);
          break;
      }
      length2++;
    } while (token = getNextToken(length2));
  return length2;
}
function calc$1(next) {
  return function(token, getNextToken, opts) {
    if (token === null) {
      return 0;
    }
    if (token.type === Function$3 && eqStrAny$1(token.value, calcFunctionNames$1)) {
      return consumeFunction$1(token, getNextToken);
    }
    return next(token, getNextToken, opts);
  };
}
function tokenType$1(expectedTokenType) {
  return function(token) {
    if (token === null || token.type !== expectedTokenType) {
      return 0;
    }
    return 1;
  };
}
function customIdent$1(token) {
  if (token === null || token.type !== Ident$1) {
    return 0;
  }
  const name2 = token.value.toLowerCase();
  if (eqStrAny$1(name2, cssWideKeywords$1)) {
    return 0;
  }
  if (eqStr$1(name2, "default")) {
    return 0;
  }
  return 1;
}
function dashedIdent(token) {
  if (token === null || token.type !== Ident$1) {
    return 0;
  }
  if (charCodeAt$1(token.value, 0) !== 45 || charCodeAt$1(token.value, 1) !== 45) {
    return 0;
  }
  return 1;
}
function customPropertyName$1(token) {
  if (!dashedIdent(token)) {
    return 0;
  }
  if (token.value === "--") {
    return 0;
  }
  return 1;
}
function hexColor$1(token) {
  if (token === null || token.type !== Hash$3) {
    return 0;
  }
  const length2 = token.value.length;
  if (length2 !== 4 && length2 !== 5 && length2 !== 7 && length2 !== 9) {
    return 0;
  }
  for (let i = 1; i < length2; i++) {
    if (!isHexDigit$1(charCodeAt$1(token.value, i))) {
      return 0;
    }
  }
  return 1;
}
function idSelector$1(token) {
  if (token === null || token.type !== Hash$3) {
    return 0;
  }
  if (!isIdentifierStart$1(charCodeAt$1(token.value, 1), charCodeAt$1(token.value, 2), charCodeAt$1(token.value, 3))) {
    return 0;
  }
  return 1;
}
function declarationValue$1(token, getNextToken) {
  if (!token) {
    return 0;
  }
  let balanceCloseType = 0;
  let balanceStash = [];
  let length2 = 0;
  scan:
    do {
      switch (token.type) {
        // ... <bad-string-token>, <bad-url-token>,
        case BadString$1:
        case BadUrl$1:
          break scan;
        // ... unmatched <)-token>, <]-token>, or <}-token>,
        case RightCurlyBracket$1:
        case RightParenthesis$1:
        case RightSquareBracket$1:
          if (token.type !== balanceCloseType) {
            break scan;
          }
          balanceCloseType = balanceStash.pop();
          break;
        // ... or top-level <semicolon-token> tokens
        case Semicolon$1:
          if (balanceCloseType === 0) {
            break scan;
          }
          break;
        // ... or <delim-token> tokens with a value of "!"
        case Delim$1:
          if (balanceCloseType === 0 && token.value === "!") {
            break scan;
          }
          break;
        case Function$3:
        case LeftParenthesis$1:
        case LeftSquareBracket$1:
        case LeftCurlyBracket$1:
          balanceStash.push(balanceCloseType);
          balanceCloseType = balancePair$2.get(token.type);
          break;
      }
      length2++;
    } while (token = getNextToken(length2));
  return length2;
}
function anyValue$1(token, getNextToken) {
  if (!token) {
    return 0;
  }
  let balanceCloseType = 0;
  let balanceStash = [];
  let length2 = 0;
  scan:
    do {
      switch (token.type) {
        // ... does not contain <bad-string-token>, <bad-url-token>,
        case BadString$1:
        case BadUrl$1:
          break scan;
        // ... unmatched <)-token>, <]-token>, or <}-token>,
        case RightCurlyBracket$1:
        case RightParenthesis$1:
        case RightSquareBracket$1:
          if (token.type !== balanceCloseType) {
            break scan;
          }
          balanceCloseType = balanceStash.pop();
          break;
        case Function$3:
        case LeftParenthesis$1:
        case LeftSquareBracket$1:
        case LeftCurlyBracket$1:
          balanceStash.push(balanceCloseType);
          balanceCloseType = balancePair$2.get(token.type);
          break;
      }
      length2++;
    } while (token = getNextToken(length2));
  return length2;
}
function dimension$1(type) {
  if (type) {
    type = new Set(type);
  }
  return function(token, getNextToken, opts) {
    if (token === null || token.type !== Dimension$3) {
      return 0;
    }
    const numberEnd = consumeNumber$2(token.value, 0);
    if (type !== null) {
      const reverseSolidusOffset = token.value.indexOf("\\", numberEnd);
      const unit = reverseSolidusOffset === -1 || !isPostfixIeHack$1(token.value, reverseSolidusOffset) ? token.value.substr(numberEnd) : token.value.substring(numberEnd, reverseSolidusOffset);
      if (type.has(unit.toLowerCase()) === false) {
        return 0;
      }
    }
    if (outOfRange$1(opts, token.value, numberEnd)) {
      return 0;
    }
    return 1;
  };
}
function percentage$1(token, getNextToken, opts) {
  if (token === null || token.type !== Percentage$3) {
    return 0;
  }
  if (outOfRange$1(opts, token.value, token.value.length - 1)) {
    return 0;
  }
  return 1;
}
function zero$1(next) {
  if (typeof next !== "function") {
    next = function() {
      return 0;
    };
  }
  return function(token, getNextToken, opts) {
    if (token !== null && token.type === Number$5) {
      if (Number(token.value) === 0) {
        return 1;
      }
    }
    return next(token, getNextToken, opts);
  };
}
function number$1(token, getNextToken, opts) {
  if (token === null) {
    return 0;
  }
  const numberEnd = consumeNumber$2(token.value, 0);
  const isNumber = numberEnd === token.value.length;
  if (!isNumber && !isPostfixIeHack$1(token.value, numberEnd)) {
    return 0;
  }
  if (outOfRange$1(opts, token.value, numberEnd)) {
    return 0;
  }
  return 1;
}
function integer$1(token, getNextToken, opts) {
  if (token === null || token.type !== Number$5) {
    return 0;
  }
  let i = charCodeAt$1(token.value, 0) === 43 || // U+002B PLUS SIGN (+)
  charCodeAt$1(token.value, 0) === 45 ? 1 : 0;
  for (; i < token.value.length; i++) {
    if (!isDigit$2(charCodeAt$1(token.value, i))) {
      return 0;
    }
  }
  if (outOfRange$1(opts, token.value, i)) {
    return 0;
  }
  return 1;
}
const tokenTypes = {
  "ident-token": tokenType$1(Ident$1),
  "function-token": tokenType$1(Function$3),
  "at-keyword-token": tokenType$1(AtKeyword$1),
  "hash-token": tokenType$1(Hash$3),
  "string-token": tokenType$1(String$4),
  "bad-string-token": tokenType$1(BadString$1),
  "url-token": tokenType$1(Url$4),
  "bad-url-token": tokenType$1(BadUrl$1),
  "delim-token": tokenType$1(Delim$1),
  "number-token": tokenType$1(Number$5),
  "percentage-token": tokenType$1(Percentage$3),
  "dimension-token": tokenType$1(Dimension$3),
  "whitespace-token": tokenType$1(WhiteSpace$3),
  "CDO-token": tokenType$1(CDO$3),
  "CDC-token": tokenType$1(CDC$3),
  "colon-token": tokenType$1(Colon$1),
  "semicolon-token": tokenType$1(Semicolon$1),
  "comma-token": tokenType$1(Comma$1),
  "[-token": tokenType$1(LeftSquareBracket$1),
  "]-token": tokenType$1(RightSquareBracket$1),
  "(-token": tokenType$1(LeftParenthesis$1),
  ")-token": tokenType$1(RightParenthesis$1),
  "{-token": tokenType$1(LeftCurlyBracket$1),
  "}-token": tokenType$1(RightCurlyBracket$1)
};
const productionTypes = {
  // token type aliases
  "string": tokenType$1(String$4),
  "ident": tokenType$1(Ident$1),
  // percentage
  "percentage": calc$1(percentage$1),
  // numeric
  "zero": zero$1(),
  "number": calc$1(number$1),
  "integer": calc$1(integer$1),
  // complex types
  "custom-ident": customIdent$1,
  "dashed-ident": dashedIdent,
  "custom-property-name": customPropertyName$1,
  "hex-color": hexColor$1,
  "id-selector": idSelector$1,
  // element( <id-selector> )
  "an-plus-b": anPlusB$1,
  "urange": urange$1,
  "declaration-value": declarationValue$1,
  "any-value": anyValue$1
};
function createDemensionTypes(units2) {
  const {
    angle: angle2,
    decibel: decibel2,
    frequency: frequency2,
    flex: flex2,
    length: length2,
    resolution: resolution2,
    semitones: semitones2,
    time: time2
  } = units2 || {};
  return {
    "dimension": calc$1(dimension$1(null)),
    "angle": calc$1(dimension$1(angle2)),
    "decibel": calc$1(dimension$1(decibel2)),
    "frequency": calc$1(dimension$1(frequency2)),
    "flex": calc$1(dimension$1(flex2)),
    "length": calc$1(zero$1(dimension$1(length2))),
    "resolution": calc$1(dimension$1(resolution2)),
    "semitones": calc$1(dimension$1(semitones2)),
    "time": calc$1(dimension$1(time2))
  };
}
function createGenericTypes(units2) {
  return {
    ...tokenTypes,
    ...productionTypes,
    ...createDemensionTypes(units2)
  };
}
const length = [
  // absolute length units https://www.w3.org/TR/css-values-3/#lengths
  "cm",
  "mm",
  "q",
  "in",
  "pt",
  "pc",
  "px",
  // font-relative length units https://drafts.csswg.org/css-values-4/#font-relative-lengths
  "em",
  "rem",
  "ex",
  "rex",
  "cap",
  "rcap",
  "ch",
  "rch",
  "ic",
  "ric",
  "lh",
  "rlh",
  // viewport-percentage lengths https://drafts.csswg.org/css-values-4/#viewport-relative-lengths
  "vw",
  "svw",
  "lvw",
  "dvw",
  "vh",
  "svh",
  "lvh",
  "dvh",
  "vi",
  "svi",
  "lvi",
  "dvi",
  "vb",
  "svb",
  "lvb",
  "dvb",
  "vmin",
  "svmin",
  "lvmin",
  "dvmin",
  "vmax",
  "svmax",
  "lvmax",
  "dvmax",
  // container relative lengths https://drafts.csswg.org/css-contain-3/#container-lengths
  "cqw",
  "cqh",
  "cqi",
  "cqb",
  "cqmin",
  "cqmax"
];
const angle = ["deg", "grad", "rad", "turn"];
const time = ["s", "ms"];
const frequency = ["hz", "khz"];
const resolution = ["dpi", "dpcm", "dppx", "x"];
const flex = ["fr"];
const decibel = ["db"];
const semitones = ["st"];
const units = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  angle,
  decibel,
  flex,
  frequency,
  length,
  resolution,
  semitones,
  time
}, Symbol.toStringTag, { value: "Module" }));
function SyntaxError$3(message, input, offset) {
  return Object.assign(createCustomError$1("SyntaxError", message), {
    input,
    offset,
    rawMessage: message,
    message: message + "\n  " + input + "\n--" + new Array((offset || input.length) + 1).join("-") + "^"
  });
}
const TAB$3 = 9;
const N$7 = 10;
const F$4 = 12;
const R$4 = 13;
const SPACE$7 = 32;
const NAME_CHAR$1 = new Uint8Array(128).map(
  (_, idx) => /[a-zA-Z0-9\-]/.test(String.fromCharCode(idx)) ? 1 : 0
);
class Scanner {
  constructor(str) {
    this.str = str;
    this.pos = 0;
  }
  charCodeAt(pos) {
    return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
  }
  charCode() {
    return this.charCodeAt(this.pos);
  }
  isNameCharCode(code2 = this.charCode()) {
    return code2 < 128 && NAME_CHAR$1[code2] === 1;
  }
  nextCharCode() {
    return this.charCodeAt(this.pos + 1);
  }
  nextNonWsCode(pos) {
    return this.charCodeAt(this.findWsEnd(pos));
  }
  skipWs() {
    this.pos = this.findWsEnd(this.pos);
  }
  findWsEnd(pos) {
    for (; pos < this.str.length; pos++) {
      const code2 = this.str.charCodeAt(pos);
      if (code2 !== R$4 && code2 !== N$7 && code2 !== F$4 && code2 !== SPACE$7 && code2 !== TAB$3) {
        break;
      }
    }
    return pos;
  }
  substringToPos(end) {
    return this.str.substring(this.pos, this.pos = end);
  }
  eat(code2) {
    if (this.charCode() !== code2) {
      this.error("Expect `" + String.fromCharCode(code2) + "`");
    }
    this.pos++;
  }
  peek() {
    return this.pos < this.str.length ? this.str.charAt(this.pos++) : "";
  }
  error(message) {
    throw new SyntaxError$3(message, this.str, this.pos);
  }
  scanSpaces() {
    return this.substringToPos(this.findWsEnd(this.pos));
  }
  scanWord() {
    let end = this.pos;
    for (; end < this.str.length; end++) {
      const code2 = this.str.charCodeAt(end);
      if (code2 >= 128 || NAME_CHAR$1[code2] === 0) {
        break;
      }
    }
    if (this.pos === end) {
      this.error("Expect a keyword");
    }
    return this.substringToPos(end);
  }
  scanNumber() {
    let end = this.pos;
    for (; end < this.str.length; end++) {
      const code2 = this.str.charCodeAt(end);
      if (code2 < 48 || code2 > 57) {
        break;
      }
    }
    if (this.pos === end) {
      this.error("Expect a number");
    }
    return this.substringToPos(end);
  }
  scanString() {
    const end = this.str.indexOf("'", this.pos + 1);
    if (end === -1) {
      this.pos = this.str.length;
      this.error("Expect an apostrophe");
    }
    return this.substringToPos(end + 1);
  }
}
const TAB$2 = 9;
const N$6 = 10;
const F$3 = 12;
const R$3 = 13;
const SPACE$6 = 32;
const EXCLAMATIONMARK$6 = 33;
const NUMBERSIGN$8 = 35;
const AMPERSAND$7 = 38;
const APOSTROPHE$5 = 39;
const LEFTPARENTHESIS$5 = 40;
const RIGHTPARENTHESIS$5 = 41;
const ASTERISK$d = 42;
const PLUSSIGN$g = 43;
const COMMA$1 = 44;
const HYPERMINUS$1 = 45;
const LESSTHANSIGN$2 = 60;
const GREATERTHANSIGN$6 = 62;
const QUESTIONMARK$4 = 63;
const COMMERCIALAT$1 = 64;
const LEFTSQUAREBRACKET$1 = 91;
const RIGHTSQUAREBRACKET$1 = 93;
const LEFTCURLYBRACKET$2 = 123;
const VERTICALLINE$7 = 124;
const RIGHTCURLYBRACKET$1 = 125;
const INFINITY$1 = 8734;
const COMBINATOR_PRECEDENCE$1 = {
  " ": 1,
  "&&": 2,
  "||": 3,
  "|": 4
};
function readMultiplierRange$1(scanner) {
  let min = null;
  let max = null;
  scanner.eat(LEFTCURLYBRACKET$2);
  scanner.skipWs();
  min = scanner.scanNumber(scanner);
  scanner.skipWs();
  if (scanner.charCode() === COMMA$1) {
    scanner.pos++;
    scanner.skipWs();
    if (scanner.charCode() !== RIGHTCURLYBRACKET$1) {
      max = scanner.scanNumber(scanner);
      scanner.skipWs();
    }
  } else {
    max = min;
  }
  scanner.eat(RIGHTCURLYBRACKET$1);
  return {
    min: Number(min),
    max: max ? Number(max) : 0
  };
}
function readMultiplier$1(scanner) {
  let range = null;
  let comma = false;
  switch (scanner.charCode()) {
    case ASTERISK$d:
      scanner.pos++;
      range = {
        min: 0,
        max: 0
      };
      break;
    case PLUSSIGN$g:
      scanner.pos++;
      range = {
        min: 1,
        max: 0
      };
      break;
    case QUESTIONMARK$4:
      scanner.pos++;
      range = {
        min: 0,
        max: 1
      };
      break;
    case NUMBERSIGN$8:
      scanner.pos++;
      comma = true;
      if (scanner.charCode() === LEFTCURLYBRACKET$2) {
        range = readMultiplierRange$1(scanner);
      } else if (scanner.charCode() === QUESTIONMARK$4) {
        scanner.pos++;
        range = {
          min: 0,
          max: 0
        };
      } else {
        range = {
          min: 1,
          max: 0
        };
      }
      break;
    case LEFTCURLYBRACKET$2:
      range = readMultiplierRange$1(scanner);
      break;
    default:
      return null;
  }
  return {
    type: "Multiplier",
    comma,
    min: range.min,
    max: range.max,
    term: null
  };
}
function maybeMultiplied$1(scanner, node2) {
  const multiplier = readMultiplier$1(scanner);
  if (multiplier !== null) {
    multiplier.term = node2;
    if (scanner.charCode() === NUMBERSIGN$8 && scanner.charCodeAt(scanner.pos - 1) === PLUSSIGN$g) {
      return maybeMultiplied$1(scanner, multiplier);
    }
    return multiplier;
  }
  return node2;
}
function maybeToken$1(scanner) {
  const ch = scanner.peek();
  if (ch === "") {
    return null;
  }
  return maybeMultiplied$1(scanner, {
    type: "Token",
    value: ch
  });
}
function readProperty$3(scanner) {
  let name2;
  scanner.eat(LESSTHANSIGN$2);
  scanner.eat(APOSTROPHE$5);
  name2 = scanner.scanWord();
  scanner.eat(APOSTROPHE$5);
  scanner.eat(GREATERTHANSIGN$6);
  return maybeMultiplied$1(scanner, {
    type: "Property",
    name: name2
  });
}
function readTypeRange$1(scanner) {
  let min = null;
  let max = null;
  let sign = 1;
  scanner.eat(LEFTSQUAREBRACKET$1);
  if (scanner.charCode() === HYPERMINUS$1) {
    scanner.peek();
    sign = -1;
  }
  if (sign == -1 && scanner.charCode() === INFINITY$1) {
    scanner.peek();
  } else {
    min = sign * Number(scanner.scanNumber(scanner));
    if (scanner.isNameCharCode()) {
      min += scanner.scanWord();
    }
  }
  scanner.skipWs();
  scanner.eat(COMMA$1);
  scanner.skipWs();
  if (scanner.charCode() === INFINITY$1) {
    scanner.peek();
  } else {
    sign = 1;
    if (scanner.charCode() === HYPERMINUS$1) {
      scanner.peek();
      sign = -1;
    }
    max = sign * Number(scanner.scanNumber(scanner));
    if (scanner.isNameCharCode()) {
      max += scanner.scanWord();
    }
  }
  scanner.eat(RIGHTSQUAREBRACKET$1);
  return {
    type: "Range",
    min,
    max
  };
}
function readType$1(scanner) {
  let name2;
  let opts = null;
  scanner.eat(LESSTHANSIGN$2);
  name2 = scanner.scanWord();
  if (name2 === "boolean-expr") {
    scanner.eat(LEFTSQUAREBRACKET$1);
    const implicitGroup = readImplicitGroup$1(scanner, RIGHTSQUAREBRACKET$1);
    scanner.eat(RIGHTSQUAREBRACKET$1);
    scanner.eat(GREATERTHANSIGN$6);
    return maybeMultiplied$1(scanner, {
      type: "Boolean",
      term: implicitGroup.terms.length === 1 ? implicitGroup.terms[0] : implicitGroup
    });
  }
  if (scanner.charCode() === LEFTPARENTHESIS$5 && scanner.nextCharCode() === RIGHTPARENTHESIS$5) {
    scanner.pos += 2;
    name2 += "()";
  }
  if (scanner.charCodeAt(scanner.findWsEnd(scanner.pos)) === LEFTSQUAREBRACKET$1) {
    scanner.skipWs();
    opts = readTypeRange$1(scanner);
  }
  scanner.eat(GREATERTHANSIGN$6);
  return maybeMultiplied$1(scanner, {
    type: "Type",
    name: name2,
    opts
  });
}
function readKeywordOrFunction$1(scanner) {
  const name2 = scanner.scanWord();
  if (scanner.charCode() === LEFTPARENTHESIS$5) {
    scanner.pos++;
    return {
      type: "Function",
      name: name2
    };
  }
  return maybeMultiplied$1(scanner, {
    type: "Keyword",
    name: name2
  });
}
function regroupTerms$1(terms, combinators) {
  function createGroup(terms2, combinator2) {
    return {
      type: "Group",
      terms: terms2,
      combinator: combinator2,
      disallowEmpty: false,
      explicit: false
    };
  }
  let combinator;
  combinators = Object.keys(combinators).sort((a, b) => COMBINATOR_PRECEDENCE$1[a] - COMBINATOR_PRECEDENCE$1[b]);
  while (combinators.length > 0) {
    combinator = combinators.shift();
    let i = 0;
    let subgroupStart = 0;
    for (; i < terms.length; i++) {
      const term = terms[i];
      if (term.type === "Combinator") {
        if (term.value === combinator) {
          if (subgroupStart === -1) {
            subgroupStart = i - 1;
          }
          terms.splice(i, 1);
          i--;
        } else {
          if (subgroupStart !== -1 && i - subgroupStart > 1) {
            terms.splice(
              subgroupStart,
              i - subgroupStart,
              createGroup(terms.slice(subgroupStart, i), combinator)
            );
            i = subgroupStart + 1;
          }
          subgroupStart = -1;
        }
      }
    }
    if (subgroupStart !== -1 && combinators.length) {
      terms.splice(
        subgroupStart,
        i - subgroupStart,
        createGroup(terms.slice(subgroupStart, i), combinator)
      );
    }
  }
  return combinator;
}
function readImplicitGroup$1(scanner, stopCharCode) {
  const combinators = /* @__PURE__ */ Object.create(null);
  const terms = [];
  let token;
  let prevToken = null;
  let prevTokenPos = scanner.pos;
  while (scanner.charCode() !== stopCharCode && (token = peek$1(scanner, stopCharCode))) {
    if (token.type !== "Spaces") {
      if (token.type === "Combinator") {
        if (prevToken === null || prevToken.type === "Combinator") {
          scanner.pos = prevTokenPos;
          scanner.error("Unexpected combinator");
        }
        combinators[token.value] = true;
      } else if (prevToken !== null && prevToken.type !== "Combinator") {
        combinators[" "] = true;
        terms.push({
          type: "Combinator",
          value: " "
        });
      }
      terms.push(token);
      prevToken = token;
      prevTokenPos = scanner.pos;
    }
  }
  if (prevToken !== null && prevToken.type === "Combinator") {
    scanner.pos -= prevTokenPos;
    scanner.error("Unexpected combinator");
  }
  return {
    type: "Group",
    terms,
    combinator: regroupTerms$1(terms, combinators) || " ",
    disallowEmpty: false,
    explicit: false
  };
}
function readGroup$1(scanner, stopCharCode) {
  let result;
  scanner.eat(LEFTSQUAREBRACKET$1);
  result = readImplicitGroup$1(scanner, stopCharCode);
  scanner.eat(RIGHTSQUAREBRACKET$1);
  result.explicit = true;
  if (scanner.charCode() === EXCLAMATIONMARK$6) {
    scanner.pos++;
    result.disallowEmpty = true;
  }
  return result;
}
function peek$1(scanner, stopCharCode) {
  let code2 = scanner.charCode();
  switch (code2) {
    case RIGHTSQUAREBRACKET$1:
      break;
    case LEFTSQUAREBRACKET$1:
      return maybeMultiplied$1(scanner, readGroup$1(scanner, stopCharCode));
    case LESSTHANSIGN$2:
      return scanner.nextCharCode() === APOSTROPHE$5 ? readProperty$3(scanner) : readType$1(scanner);
    case VERTICALLINE$7:
      return {
        type: "Combinator",
        value: scanner.substringToPos(
          scanner.pos + (scanner.nextCharCode() === VERTICALLINE$7 ? 2 : 1)
        )
      };
    case AMPERSAND$7:
      scanner.pos++;
      scanner.eat(AMPERSAND$7);
      return {
        type: "Combinator",
        value: "&&"
      };
    case COMMA$1:
      scanner.pos++;
      return {
        type: "Comma"
      };
    case APOSTROPHE$5:
      return maybeMultiplied$1(scanner, {
        type: "String",
        value: scanner.scanString()
      });
    case SPACE$6:
    case TAB$2:
    case N$6:
    case R$3:
    case F$3:
      return {
        type: "Spaces",
        value: scanner.scanSpaces()
      };
    case COMMERCIALAT$1:
      code2 = scanner.nextCharCode();
      if (scanner.isNameCharCode(code2)) {
        scanner.pos++;
        return {
          type: "AtKeyword",
          name: scanner.scanWord()
        };
      }
      return maybeToken$1(scanner);
    case ASTERISK$d:
    case PLUSSIGN$g:
    case QUESTIONMARK$4:
    case NUMBERSIGN$8:
    case EXCLAMATIONMARK$6:
      break;
    case LEFTCURLYBRACKET$2:
      code2 = scanner.nextCharCode();
      if (code2 < 48 || code2 > 57) {
        return maybeToken$1(scanner);
      }
      break;
    default:
      if (scanner.isNameCharCode(code2)) {
        return readKeywordOrFunction$1(scanner);
      }
      return maybeToken$1(scanner);
  }
}
function parse$1u(source) {
  const scanner = new Scanner(source);
  const result = readImplicitGroup$1(scanner);
  if (scanner.pos !== source.length) {
    scanner.error("Unexpected input");
  }
  if (result.terms.length === 1 && result.terms[0].type === "Group") {
    return result.terms[0];
  }
  return result;
}
const noop$3 = function() {
};
function ensureFunction$2(value2) {
  return typeof value2 === "function" ? value2 : noop$3;
}
function walk$4(node2, options, context) {
  function walk2(node3) {
    enter.call(context, node3);
    switch (node3.type) {
      case "Group":
        node3.terms.forEach(walk2);
        break;
      case "Multiplier":
      case "Boolean":
        walk2(node3.term);
        break;
      case "Type":
      case "Property":
      case "Keyword":
      case "AtKeyword":
      case "Function":
      case "String":
      case "Token":
      case "Comma":
        break;
      default:
        throw new Error("Unknown type: " + node3.type);
    }
    leave.call(context, node3);
  }
  let enter = noop$3;
  let leave = noop$3;
  if (typeof options === "function") {
    enter = options;
  } else if (options) {
    enter = ensureFunction$2(options.enter);
    leave = ensureFunction$2(options.leave);
  }
  if (enter === noop$3 && leave === noop$3) {
    throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
  }
  walk2(node2);
}
const astToTokens$1 = {
  decorator(handlers2) {
    const tokens = [];
    let curNode = null;
    return {
      ...handlers2,
      node(node2) {
        const tmp = curNode;
        curNode = node2;
        handlers2.node.call(this, node2);
        curNode = tmp;
      },
      emit(value2, type, auto) {
        tokens.push({
          type,
          value: value2,
          node: auto ? null : curNode
        });
      },
      result() {
        return tokens;
      }
    };
  }
};
function stringToTokens$1(str) {
  const tokens = [];
  tokenize$4(
    str,
    (type, start, end) => tokens.push({
      type,
      value: str.slice(start, end),
      node: null
    })
  );
  return tokens;
}
function prepareTokens$1(value2, syntax2) {
  if (typeof value2 === "string") {
    return stringToTokens$1(value2);
  }
  return syntax2.generate(value2, astToTokens$1);
}
const MATCH$1 = { type: "Match" };
const MISMATCH$1 = { type: "Mismatch" };
const DISALLOW_EMPTY$1 = { type: "DisallowEmpty" };
const LEFTPARENTHESIS$4 = 40;
const RIGHTPARENTHESIS$4 = 41;
function createCondition$1(match, thenBranch, elseBranch) {
  if (thenBranch === MATCH$1 && elseBranch === MISMATCH$1) {
    return match;
  }
  if (match === MATCH$1 && thenBranch === MATCH$1 && elseBranch === MATCH$1) {
    return match;
  }
  if (match.type === "If" && match.else === MISMATCH$1 && thenBranch === MATCH$1) {
    thenBranch = match.then;
    match = match.match;
  }
  return {
    type: "If",
    match,
    then: thenBranch,
    else: elseBranch
  };
}
function isFunctionType$1(name2) {
  return name2.length > 2 && name2.charCodeAt(name2.length - 2) === LEFTPARENTHESIS$4 && name2.charCodeAt(name2.length - 1) === RIGHTPARENTHESIS$4;
}
function isEnumCapatible$1(term) {
  return term.type === "Keyword" || term.type === "AtKeyword" || term.type === "Function" || term.type === "Type" && isFunctionType$1(term.name);
}
function groupNode(terms, combinator = " ", explicit = false) {
  return {
    type: "Group",
    terms,
    combinator,
    disallowEmpty: false,
    explicit
  };
}
function replaceTypeInGraph(node2, replacements, visited = /* @__PURE__ */ new Set()) {
  if (!visited.has(node2)) {
    visited.add(node2);
    switch (node2.type) {
      case "If":
        node2.match = replaceTypeInGraph(node2.match, replacements, visited);
        node2.then = replaceTypeInGraph(node2.then, replacements, visited);
        node2.else = replaceTypeInGraph(node2.else, replacements, visited);
        break;
      case "Type":
        return replacements[node2.name] || node2;
    }
  }
  return node2;
}
function buildGroupMatchGraph$1(combinator, terms, atLeastOneTermMatched) {
  switch (combinator) {
    case " ": {
      let result = MATCH$1;
      for (let i = terms.length - 1; i >= 0; i--) {
        const term = terms[i];
        result = createCondition$1(
          term,
          result,
          MISMATCH$1
        );
      }
      return result;
    }
    case "|": {
      let result = MISMATCH$1;
      let map = null;
      for (let i = terms.length - 1; i >= 0; i--) {
        let term = terms[i];
        if (isEnumCapatible$1(term)) {
          if (map === null && i > 0 && isEnumCapatible$1(terms[i - 1])) {
            map = /* @__PURE__ */ Object.create(null);
            result = createCondition$1(
              {
                type: "Enum",
                map
              },
              MATCH$1,
              result
            );
          }
          if (map !== null) {
            const key = (isFunctionType$1(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
            if (key in map === false) {
              map[key] = term;
              continue;
            }
          }
        }
        map = null;
        result = createCondition$1(
          term,
          MATCH$1,
          result
        );
      }
      return result;
    }
    case "&&": {
      if (terms.length > 5) {
        return {
          type: "MatchOnce",
          terms,
          all: true
        };
      }
      let result = MISMATCH$1;
      for (let i = terms.length - 1; i >= 0; i--) {
        const term = terms[i];
        let thenClause;
        if (terms.length > 1) {
          thenClause = buildGroupMatchGraph$1(
            combinator,
            terms.filter(function(newGroupTerm) {
              return newGroupTerm !== term;
            }),
            false
          );
        } else {
          thenClause = MATCH$1;
        }
        result = createCondition$1(
          term,
          thenClause,
          result
        );
      }
      return result;
    }
    case "||": {
      if (terms.length > 5) {
        return {
          type: "MatchOnce",
          terms,
          all: false
        };
      }
      let result = atLeastOneTermMatched ? MATCH$1 : MISMATCH$1;
      for (let i = terms.length - 1; i >= 0; i--) {
        const term = terms[i];
        let thenClause;
        if (terms.length > 1) {
          thenClause = buildGroupMatchGraph$1(
            combinator,
            terms.filter(function(newGroupTerm) {
              return newGroupTerm !== term;
            }),
            true
          );
        } else {
          thenClause = MATCH$1;
        }
        result = createCondition$1(
          term,
          thenClause,
          result
        );
      }
      return result;
    }
  }
}
function buildMultiplierMatchGraph$1(node2) {
  let result = MATCH$1;
  let matchTerm = buildMatchGraphInternal$1(node2.term);
  if (node2.max === 0) {
    matchTerm = createCondition$1(
      matchTerm,
      DISALLOW_EMPTY$1,
      MISMATCH$1
    );
    result = createCondition$1(
      matchTerm,
      null,
      // will be a loop
      MISMATCH$1
    );
    result.then = createCondition$1(
      MATCH$1,
      MATCH$1,
      result
      // make a loop
    );
    if (node2.comma) {
      result.then.else = createCondition$1(
        { type: "Comma", syntax: node2 },
        result,
        MISMATCH$1
      );
    }
  } else {
    for (let i = node2.min || 1; i <= node2.max; i++) {
      if (node2.comma && result !== MATCH$1) {
        result = createCondition$1(
          { type: "Comma", syntax: node2 },
          result,
          MISMATCH$1
        );
      }
      result = createCondition$1(
        matchTerm,
        createCondition$1(
          MATCH$1,
          MATCH$1,
          result
        ),
        MISMATCH$1
      );
    }
  }
  if (node2.min === 0) {
    result = createCondition$1(
      MATCH$1,
      MATCH$1,
      result
    );
  } else {
    for (let i = 0; i < node2.min - 1; i++) {
      if (node2.comma && result !== MATCH$1) {
        result = createCondition$1(
          { type: "Comma", syntax: node2 },
          result,
          MISMATCH$1
        );
      }
      result = createCondition$1(
        matchTerm,
        result,
        MISMATCH$1
      );
    }
  }
  return result;
}
function buildMatchGraphInternal$1(node2) {
  if (typeof node2 === "function") {
    return {
      type: "Generic",
      fn: node2
    };
  }
  switch (node2.type) {
    case "Group": {
      let result = buildGroupMatchGraph$1(
        node2.combinator,
        node2.terms.map(buildMatchGraphInternal$1),
        false
      );
      if (node2.disallowEmpty) {
        result = createCondition$1(
          result,
          DISALLOW_EMPTY$1,
          MISMATCH$1
        );
      }
      return result;
    }
    case "Multiplier":
      return buildMultiplierMatchGraph$1(node2);
    // https://drafts.csswg.org/css-values-5/#boolean
    case "Boolean": {
      const term = buildMatchGraphInternal$1(node2.term);
      const matchNode = buildMatchGraphInternal$1(groupNode([
        groupNode([
          { type: "Keyword", name: "not" },
          { type: "Type", name: "!boolean-group" }
        ]),
        groupNode([
          { type: "Type", name: "!boolean-group" },
          groupNode([
            { type: "Multiplier", comma: false, min: 0, max: 0, term: groupNode([
              { type: "Keyword", name: "and" },
              { type: "Type", name: "!boolean-group" }
            ]) },
            { type: "Multiplier", comma: false, min: 0, max: 0, term: groupNode([
              { type: "Keyword", name: "or" },
              { type: "Type", name: "!boolean-group" }
            ]) }
          ], "|")
        ])
      ], "|"));
      const booleanGroup = buildMatchGraphInternal$1(
        groupNode([
          { type: "Type", name: "!term" },
          groupNode([
            { type: "Token", value: "(" },
            { type: "Type", name: "!self" },
            { type: "Token", value: ")" }
          ]),
          { type: "Type", name: "general-enclosed" }
        ], "|")
      );
      replaceTypeInGraph(booleanGroup, { "!term": term, "!self": matchNode });
      replaceTypeInGraph(matchNode, { "!boolean-group": booleanGroup });
      return matchNode;
    }
    case "Type":
    case "Property":
      return {
        type: node2.type,
        name: node2.name,
        syntax: node2
      };
    case "Keyword":
      return {
        type: node2.type,
        name: node2.name.toLowerCase(),
        syntax: node2
      };
    case "AtKeyword":
      return {
        type: node2.type,
        name: "@" + node2.name.toLowerCase(),
        syntax: node2
      };
    case "Function":
      return {
        type: node2.type,
        name: node2.name.toLowerCase() + "(",
        syntax: node2
      };
    case "String":
      if (node2.value.length === 3) {
        return {
          type: "Token",
          value: node2.value.charAt(1),
          syntax: node2
        };
      }
      return {
        type: node2.type,
        value: node2.value.substr(1, node2.value.length - 2).replace(/\\'/g, "'"),
        syntax: node2
      };
    case "Token":
      return {
        type: node2.type,
        value: node2.value,
        syntax: node2
      };
    case "Comma":
      return {
        type: node2.type,
        syntax: node2
      };
    default:
      throw new Error("Unknown node type:", node2.type);
  }
}
function buildMatchGraph$1(syntaxTree, ref) {
  if (typeof syntaxTree === "string") {
    syntaxTree = parse$1u(syntaxTree);
  }
  return {
    type: "MatchGraph",
    match: buildMatchGraphInternal$1(syntaxTree),
    syntax: ref || null,
    source: syntaxTree
  };
}
const { hasOwnProperty: hasOwnProperty$a } = Object.prototype;
const STUB$1 = 0;
const TOKEN$1 = 1;
const OPEN_SYNTAX$1 = 2;
const CLOSE_SYNTAX$1 = 3;
const EXIT_REASON_MATCH$1 = "Match";
const EXIT_REASON_MISMATCH$1 = "Mismatch";
const EXIT_REASON_ITERATION_LIMIT$1 = "Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)";
const ITERATION_LIMIT$1 = 15e3;
function reverseList$1(list) {
  let prev = null;
  let next = null;
  let item = list;
  while (item !== null) {
    next = item.prev;
    item.prev = prev;
    prev = item;
    item = next;
  }
  return prev;
}
function areStringsEqualCaseInsensitive$1(testStr, referenceStr) {
  if (testStr.length !== referenceStr.length) {
    return false;
  }
  for (let i = 0; i < testStr.length; i++) {
    const referenceCode = referenceStr.charCodeAt(i);
    let testCode = testStr.charCodeAt(i);
    if (testCode >= 65 && testCode <= 90) {
      testCode = testCode | 32;
    }
    if (testCode !== referenceCode) {
      return false;
    }
  }
  return true;
}
function isContextEdgeDelim$1(token) {
  if (token.type !== Delim$1) {
    return false;
  }
  return token.value !== "?";
}
function isCommaContextStart$1(token) {
  if (token === null) {
    return true;
  }
  return token.type === Comma$1 || token.type === Function$3 || token.type === LeftParenthesis$1 || token.type === LeftSquareBracket$1 || token.type === LeftCurlyBracket$1 || isContextEdgeDelim$1(token);
}
function isCommaContextEnd$1(token) {
  if (token === null) {
    return true;
  }
  return token.type === RightParenthesis$1 || token.type === RightSquareBracket$1 || token.type === RightCurlyBracket$1 || token.type === Delim$1 && token.value === "/";
}
function internalMatch$1(tokens, state, syntaxes) {
  function moveToNextToken() {
    do {
      tokenIndex++;
      token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
    } while (token !== null && (token.type === WhiteSpace$3 || token.type === Comment$3));
  }
  function getNextToken(offset) {
    const nextIndex = tokenIndex + offset;
    return nextIndex < tokens.length ? tokens[nextIndex] : null;
  }
  function stateSnapshotFromSyntax(nextState, prev) {
    return {
      nextState,
      matchStack,
      syntaxStack,
      thenStack,
      tokenIndex,
      prev
    };
  }
  function pushThenStack(nextState) {
    thenStack = {
      nextState,
      matchStack,
      syntaxStack,
      prev: thenStack
    };
  }
  function pushElseStack(nextState) {
    elseStack = stateSnapshotFromSyntax(nextState, elseStack);
  }
  function addTokenToMatch() {
    matchStack = {
      type: TOKEN$1,
      syntax: state.syntax,
      token,
      prev: matchStack
    };
    moveToNextToken();
    syntaxStash = null;
    if (tokenIndex > longestMatch) {
      longestMatch = tokenIndex;
    }
  }
  function openSyntax() {
    syntaxStack = {
      syntax: state.syntax,
      opts: state.syntax.opts || syntaxStack !== null && syntaxStack.opts || null,
      prev: syntaxStack
    };
    matchStack = {
      type: OPEN_SYNTAX$1,
      syntax: state.syntax,
      token: matchStack.token,
      prev: matchStack
    };
  }
  function closeSyntax() {
    if (matchStack.type === OPEN_SYNTAX$1) {
      matchStack = matchStack.prev;
    } else {
      matchStack = {
        type: CLOSE_SYNTAX$1,
        syntax: syntaxStack.syntax,
        token: matchStack.token,
        prev: matchStack
      };
    }
    syntaxStack = syntaxStack.prev;
  }
  let syntaxStack = null;
  let thenStack = null;
  let elseStack = null;
  let syntaxStash = null;
  let iterationCount = 0;
  let exitReason = null;
  let token = null;
  let tokenIndex = -1;
  let longestMatch = 0;
  let matchStack = {
    type: STUB$1,
    syntax: null,
    token: null,
    prev: null
  };
  moveToNextToken();
  while (exitReason === null && ++iterationCount < ITERATION_LIMIT$1) {
    switch (state.type) {
      case "Match":
        if (thenStack === null) {
          if (token !== null) {
            if (tokenIndex !== tokens.length - 1 || token.value !== "\\0" && token.value !== "\\9") {
              state = MISMATCH$1;
              break;
            }
          }
          exitReason = EXIT_REASON_MATCH$1;
          break;
        }
        state = thenStack.nextState;
        if (state === DISALLOW_EMPTY$1) {
          if (thenStack.matchStack === matchStack) {
            state = MISMATCH$1;
            break;
          } else {
            state = MATCH$1;
          }
        }
        while (thenStack.syntaxStack !== syntaxStack) {
          closeSyntax();
        }
        thenStack = thenStack.prev;
        break;
      case "Mismatch":
        if (syntaxStash !== null && syntaxStash !== false) {
          if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
            elseStack = syntaxStash;
            syntaxStash = false;
          }
        } else if (elseStack === null) {
          exitReason = EXIT_REASON_MISMATCH$1;
          break;
        }
        state = elseStack.nextState;
        thenStack = elseStack.thenStack;
        syntaxStack = elseStack.syntaxStack;
        matchStack = elseStack.matchStack;
        tokenIndex = elseStack.tokenIndex;
        token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
        elseStack = elseStack.prev;
        break;
      case "MatchGraph":
        state = state.match;
        break;
      case "If":
        if (state.else !== MISMATCH$1) {
          pushElseStack(state.else);
        }
        if (state.then !== MATCH$1) {
          pushThenStack(state.then);
        }
        state = state.match;
        break;
      case "MatchOnce":
        state = {
          type: "MatchOnceBuffer",
          syntax: state,
          index: 0,
          mask: 0
        };
        break;
      case "MatchOnceBuffer": {
        const terms = state.syntax.terms;
        if (state.index === terms.length) {
          if (state.mask === 0 || state.syntax.all) {
            state = MISMATCH$1;
            break;
          }
          state = MATCH$1;
          break;
        }
        if (state.mask === (1 << terms.length) - 1) {
          state = MATCH$1;
          break;
        }
        for (; state.index < terms.length; state.index++) {
          const matchFlag = 1 << state.index;
          if ((state.mask & matchFlag) === 0) {
            pushElseStack(state);
            pushThenStack({
              type: "AddMatchOnce",
              syntax: state.syntax,
              mask: state.mask | matchFlag
            });
            state = terms[state.index++];
            break;
          }
        }
        break;
      }
      case "AddMatchOnce":
        state = {
          type: "MatchOnceBuffer",
          syntax: state.syntax,
          index: 0,
          mask: state.mask
        };
        break;
      case "Enum":
        if (token !== null) {
          let name2 = token.value.toLowerCase();
          if (name2.indexOf("\\") !== -1) {
            name2 = name2.replace(/\\[09].*$/, "");
          }
          if (hasOwnProperty$a.call(state.map, name2)) {
            state = state.map[name2];
            break;
          }
        }
        state = MISMATCH$1;
        break;
      case "Generic": {
        const opts = syntaxStack !== null ? syntaxStack.opts : null;
        const lastTokenIndex2 = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));
        if (!isNaN(lastTokenIndex2) && lastTokenIndex2 > tokenIndex) {
          while (tokenIndex < lastTokenIndex2) {
            addTokenToMatch();
          }
          state = MATCH$1;
        } else {
          state = MISMATCH$1;
        }
        break;
      }
      case "Type":
      case "Property": {
        const syntaxDict = state.type === "Type" ? "types" : "properties";
        const dictSyntax = hasOwnProperty$a.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;
        if (!dictSyntax || !dictSyntax.match) {
          throw new Error(
            "Bad syntax reference: " + (state.type === "Type" ? "<" + state.name + ">" : "<'" + state.name + "'>")
          );
        }
        if (syntaxStash !== false && token !== null && state.type === "Type") {
          const lowPriorityMatching = (
            // https://drafts.csswg.org/css-values-4/#custom-idents
            // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
            // can only claim the keyword if no other unfulfilled production can claim it.
            state.name === "custom-ident" && token.type === Ident$1 || // https://drafts.csswg.org/css-values-4/#lengths
            // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
            // it must parse as a <number>
            state.name === "length" && token.value === "0"
          );
          if (lowPriorityMatching) {
            if (syntaxStash === null) {
              syntaxStash = stateSnapshotFromSyntax(state, elseStack);
            }
            state = MISMATCH$1;
            break;
          }
        }
        openSyntax();
        state = dictSyntax.matchRef || dictSyntax.match;
        break;
      }
      case "Keyword": {
        const name2 = state.name;
        if (token !== null) {
          let keywordName = token.value;
          if (keywordName.indexOf("\\") !== -1) {
            keywordName = keywordName.replace(/\\[09].*$/, "");
          }
          if (areStringsEqualCaseInsensitive$1(keywordName, name2)) {
            addTokenToMatch();
            state = MATCH$1;
            break;
          }
        }
        state = MISMATCH$1;
        break;
      }
      case "AtKeyword":
      case "Function":
        if (token !== null && areStringsEqualCaseInsensitive$1(token.value, state.name)) {
          addTokenToMatch();
          state = MATCH$1;
          break;
        }
        state = MISMATCH$1;
        break;
      case "Token":
        if (token !== null && token.value === state.value) {
          addTokenToMatch();
          state = MATCH$1;
          break;
        }
        state = MISMATCH$1;
        break;
      case "Comma":
        if (token !== null && token.type === Comma$1) {
          if (isCommaContextStart$1(matchStack.token)) {
            state = MISMATCH$1;
          } else {
            addTokenToMatch();
            state = isCommaContextEnd$1(token) ? MISMATCH$1 : MATCH$1;
          }
        } else {
          state = isCommaContextStart$1(matchStack.token) || isCommaContextEnd$1(token) ? MATCH$1 : MISMATCH$1;
        }
        break;
      case "String":
        let string = "";
        let lastTokenIndex = tokenIndex;
        for (; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
          string += tokens[lastTokenIndex].value;
        }
        if (areStringsEqualCaseInsensitive$1(string, state.value)) {
          while (tokenIndex < lastTokenIndex) {
            addTokenToMatch();
          }
          state = MATCH$1;
        } else {
          state = MISMATCH$1;
        }
        break;
      default:
        throw new Error("Unknown node type: " + state.type);
    }
  }
  switch (exitReason) {
    case null:
      console.warn("[csstree-match] BREAK after " + ITERATION_LIMIT$1 + " iterations");
      exitReason = EXIT_REASON_ITERATION_LIMIT$1;
      matchStack = null;
      break;
    case EXIT_REASON_MATCH$1:
      while (syntaxStack !== null) {
        closeSyntax();
      }
      break;
    default:
      matchStack = null;
  }
  return {
    tokens,
    reason: exitReason,
    iterations: iterationCount,
    match: matchStack,
    longestMatch
  };
}
function matchAsTree$1(tokens, matchGraph, syntaxes) {
  const matchResult = internalMatch$1(tokens, matchGraph, syntaxes || {});
  if (matchResult.match === null) {
    return matchResult;
  }
  let item = matchResult.match;
  let host = matchResult.match = {
    syntax: matchGraph.syntax || null,
    match: []
  };
  const hostStack = [host];
  item = reverseList$1(item).prev;
  while (item !== null) {
    switch (item.type) {
      case OPEN_SYNTAX$1:
        host.match.push(host = {
          syntax: item.syntax,
          match: []
        });
        hostStack.push(host);
        break;
      case CLOSE_SYNTAX$1:
        hostStack.pop();
        host = hostStack[hostStack.length - 1];
        break;
      default:
        host.match.push({
          syntax: item.syntax || null,
          token: item.token.value,
          node: item.token.node
        });
    }
    item = item.prev;
  }
  return matchResult;
}
function getTrace$1(node2) {
  function shouldPutToTrace(syntax2) {
    if (syntax2 === null) {
      return false;
    }
    return syntax2.type === "Type" || syntax2.type === "Property" || syntax2.type === "Keyword";
  }
  function hasMatch(matchNode) {
    if (Array.isArray(matchNode.match)) {
      for (let i = 0; i < matchNode.match.length; i++) {
        if (hasMatch(matchNode.match[i])) {
          if (shouldPutToTrace(matchNode.syntax)) {
            result.unshift(matchNode.syntax);
          }
          return true;
        }
      }
    } else if (matchNode.node === node2) {
      result = shouldPutToTrace(matchNode.syntax) ? [matchNode.syntax] : [];
      return true;
    }
    return false;
  }
  let result = null;
  if (this.matched !== null) {
    hasMatch(this.matched);
  }
  return result;
}
function isType$1(node2, type) {
  return testNode$1(this, node2, (match) => match.type === "Type" && match.name === type);
}
function isProperty$1(node2, property2) {
  return testNode$1(this, node2, (match) => match.type === "Property" && match.name === property2);
}
function isKeyword$1(node2) {
  return testNode$1(this, node2, (match) => match.type === "Keyword");
}
function testNode$1(match, node2, fn2) {
  const trace2 = getTrace$1.call(match, node2);
  if (trace2 === null) {
    return false;
  }
  return trace2.some(fn2);
}
const trace$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getTrace: getTrace$1,
  isKeyword: isKeyword$1,
  isProperty: isProperty$1,
  isType: isType$1
}, Symbol.toStringTag, { value: "Module" }));
function getFirstMatchNode$1(matchNode) {
  if ("node" in matchNode) {
    return matchNode.node;
  }
  return getFirstMatchNode$1(matchNode.match[0]);
}
function getLastMatchNode$1(matchNode) {
  if ("node" in matchNode) {
    return matchNode.node;
  }
  return getLastMatchNode$1(matchNode.match[matchNode.match.length - 1]);
}
function matchFragments$1(lexer2, ast, match, type, name2) {
  function findFragments(matchNode) {
    if (matchNode.syntax !== null && matchNode.syntax.type === type && matchNode.syntax.name === name2) {
      const start = getFirstMatchNode$1(matchNode);
      const end = getLastMatchNode$1(matchNode);
      lexer2.syntax.walk(ast, function(node2, item, list) {
        if (node2 === start) {
          const nodes = new List$1();
          do {
            nodes.appendData(item.data);
            if (item.data === end) {
              break;
            }
            item = item.next;
          } while (item !== null);
          fragments.push({
            parent: list,
            nodes
          });
        }
      });
    }
    if (Array.isArray(matchNode.match)) {
      matchNode.match.forEach(findFragments);
    }
  }
  const fragments = [];
  if (match.matched !== null) {
    findFragments(match.matched);
  }
  return fragments;
}
const { hasOwnProperty: hasOwnProperty$9 } = Object.prototype;
function isValidNumber$1(value2) {
  return typeof value2 === "number" && isFinite(value2) && Math.floor(value2) === value2 && value2 >= 0;
}
function isValidLocation$1(loc) {
  return Boolean(loc) && isValidNumber$1(loc.offset) && isValidNumber$1(loc.line) && isValidNumber$1(loc.column);
}
function createNodeStructureChecker$1(type, fields) {
  return function checkNode(node2, warn) {
    if (!node2 || node2.constructor !== Object) {
      return warn(node2, "Type of node should be an Object");
    }
    for (let key in node2) {
      let valid = true;
      if (hasOwnProperty$9.call(node2, key) === false) {
        continue;
      }
      if (key === "type") {
        if (node2.type !== type) {
          warn(node2, "Wrong node type `" + node2.type + "`, expected `" + type + "`");
        }
      } else if (key === "loc") {
        if (node2.loc === null) {
          continue;
        } else if (node2.loc && node2.loc.constructor === Object) {
          if (typeof node2.loc.source !== "string") {
            key += ".source";
          } else if (!isValidLocation$1(node2.loc.start)) {
            key += ".start";
          } else if (!isValidLocation$1(node2.loc.end)) {
            key += ".end";
          } else {
            continue;
          }
        }
        valid = false;
      } else if (fields.hasOwnProperty(key)) {
        valid = false;
        for (let i = 0; !valid && i < fields[key].length; i++) {
          const fieldType = fields[key][i];
          switch (fieldType) {
            case String:
              valid = typeof node2[key] === "string";
              break;
            case Boolean:
              valid = typeof node2[key] === "boolean";
              break;
            case null:
              valid = node2[key] === null;
              break;
            default:
              if (typeof fieldType === "string") {
                valid = node2[key] && node2[key].type === fieldType;
              } else if (Array.isArray(fieldType)) {
                valid = node2[key] instanceof List$1;
              }
          }
        }
      } else {
        warn(node2, "Unknown field `" + key + "` for " + type + " node type");
      }
      if (!valid) {
        warn(node2, "Bad value for `" + type + "." + key + "`");
      }
    }
    for (const key in fields) {
      if (hasOwnProperty$9.call(fields, key) && hasOwnProperty$9.call(node2, key) === false) {
        warn(node2, "Field `" + type + "." + key + "` is missed");
      }
    }
  };
}
function genTypesList(fieldTypes, path) {
  const docsTypes = [];
  for (let i = 0; i < fieldTypes.length; i++) {
    const fieldType = fieldTypes[i];
    if (fieldType === String || fieldType === Boolean) {
      docsTypes.push(fieldType.name.toLowerCase());
    } else if (fieldType === null) {
      docsTypes.push("null");
    } else if (typeof fieldType === "string") {
      docsTypes.push(fieldType);
    } else if (Array.isArray(fieldType)) {
      docsTypes.push("List<" + (genTypesList(fieldType, path) || "any") + ">");
    } else {
      throw new Error("Wrong value `" + fieldType + "` in `" + path + "` structure definition");
    }
  }
  return docsTypes.join(" | ");
}
function processStructure$1(name2, nodeType) {
  const structure2 = nodeType.structure;
  const fields = {
    type: String,
    loc: true
  };
  const docs = {
    type: '"' + name2 + '"'
  };
  for (const key in structure2) {
    if (hasOwnProperty$9.call(structure2, key) === false) {
      continue;
    }
    const fieldTypes = fields[key] = Array.isArray(structure2[key]) ? structure2[key].slice() : [structure2[key]];
    docs[key] = genTypesList(fieldTypes, name2 + "." + key);
  }
  return {
    docs,
    check: createNodeStructureChecker$1(name2, fields)
  };
}
function getStructureFromConfig$1(config) {
  const structure2 = {};
  if (config.node) {
    for (const name2 in config.node) {
      if (hasOwnProperty$9.call(config.node, name2)) {
        const nodeType = config.node[name2];
        if (nodeType.structure) {
          structure2[name2] = processStructure$1(name2, nodeType);
        } else {
          throw new Error("Missed `structure` field in `" + name2 + "` node type definition");
        }
      }
    }
  }
  return structure2;
}
function dumpMapSyntax$1(map, compact, syntaxAsAst) {
  const result = {};
  for (const name2 in map) {
    if (map[name2].syntax) {
      result[name2] = syntaxAsAst ? map[name2].syntax : generate$1u(map[name2].syntax, { compact });
    }
  }
  return result;
}
function dumpAtruleMapSyntax$1(map, compact, syntaxAsAst) {
  const result = {};
  for (const [name2, atrule2] of Object.entries(map)) {
    result[name2] = {
      prelude: atrule2.prelude && (syntaxAsAst ? atrule2.prelude.syntax : generate$1u(atrule2.prelude.syntax, { compact })),
      descriptors: atrule2.descriptors && dumpMapSyntax$1(atrule2.descriptors, compact, syntaxAsAst)
    };
  }
  return result;
}
function valueHasVar$1(tokens) {
  for (let i = 0; i < tokens.length; i++) {
    if (tokens[i].value.toLowerCase() === "var(") {
      return true;
    }
  }
  return false;
}
function syntaxHasTopLevelCommaMultiplier(syntax2) {
  const singleTerm = syntax2.terms[0];
  return syntax2.explicit === false && syntax2.terms.length === 1 && singleTerm.type === "Multiplier" && singleTerm.comma === true;
}
function buildMatchResult$1(matched, error2, iterations) {
  return {
    matched,
    iterations,
    error: error2,
    ...trace$1
  };
}
function matchSyntax$1(lexer2, syntax2, value2, useCssWideKeywords) {
  const tokens = prepareTokens$1(value2, lexer2.syntax);
  let result;
  if (valueHasVar$1(tokens)) {
    return buildMatchResult$1(null, new Error("Matching for a tree with var() is not supported"));
  }
  if (useCssWideKeywords) {
    result = matchAsTree$1(tokens, lexer2.cssWideKeywordsSyntax, lexer2);
  }
  if (!useCssWideKeywords || !result.match) {
    result = matchAsTree$1(tokens, syntax2.match, lexer2);
    if (!result.match) {
      return buildMatchResult$1(
        null,
        new SyntaxMatchError$1(result.reason, syntax2.syntax, value2, result),
        result.iterations
      );
    }
  }
  return buildMatchResult$1(result.match, null, result.iterations);
}
let Lexer$1 = class Lexer {
  constructor(config, syntax2, structure2) {
    this.cssWideKeywords = cssWideKeywords$1;
    this.syntax = syntax2;
    this.generic = false;
    this.units = { ...units };
    this.atrules = /* @__PURE__ */ Object.create(null);
    this.properties = /* @__PURE__ */ Object.create(null);
    this.types = /* @__PURE__ */ Object.create(null);
    this.structure = structure2 || getStructureFromConfig$1(config);
    if (config) {
      if (config.cssWideKeywords) {
        this.cssWideKeywords = config.cssWideKeywords;
      }
      if (config.units) {
        for (const group of Object.keys(units)) {
          if (Array.isArray(config.units[group])) {
            this.units[group] = config.units[group];
          }
        }
      }
      if (config.types) {
        for (const [name2, type] of Object.entries(config.types)) {
          this.addType_(name2, type);
        }
      }
      if (config.generic) {
        this.generic = true;
        for (const [name2, value2] of Object.entries(createGenericTypes(this.units))) {
          this.addType_(name2, value2);
        }
      }
      if (config.atrules) {
        for (const [name2, atrule2] of Object.entries(config.atrules)) {
          this.addAtrule_(name2, atrule2);
        }
      }
      if (config.properties) {
        for (const [name2, property2] of Object.entries(config.properties)) {
          this.addProperty_(name2, property2);
        }
      }
    }
    this.cssWideKeywordsSyntax = buildMatchGraph$1(this.cssWideKeywords.join(" |  "));
  }
  checkStructure(ast) {
    function collectWarning(node2, message) {
      warns.push({ node: node2, message });
    }
    const structure2 = this.structure;
    const warns = [];
    this.syntax.walk(ast, function(node2) {
      if (structure2.hasOwnProperty(node2.type)) {
        structure2[node2.type].check(node2, collectWarning);
      } else {
        collectWarning(node2, "Unknown node type `" + node2.type + "`");
      }
    });
    return warns.length ? warns : false;
  }
  createDescriptor(syntax2, type, name2, parent = null) {
    const ref = {
      type,
      name: name2
    };
    const descriptor = {
      type,
      name: name2,
      parent,
      serializable: typeof syntax2 === "string" || syntax2 && typeof syntax2.type === "string",
      syntax: null,
      match: null,
      matchRef: null
      // used for properties when a syntax referenced as <'property'> in other syntax definitions
    };
    if (typeof syntax2 === "function") {
      descriptor.match = buildMatchGraph$1(syntax2, ref);
    } else {
      if (typeof syntax2 === "string") {
        Object.defineProperty(descriptor, "syntax", {
          get() {
            Object.defineProperty(descriptor, "syntax", {
              value: parse$1u(syntax2)
            });
            return descriptor.syntax;
          }
        });
      } else {
        descriptor.syntax = syntax2;
      }
      Object.defineProperty(descriptor, "match", {
        get() {
          Object.defineProperty(descriptor, "match", {
            value: buildMatchGraph$1(descriptor.syntax, ref)
          });
          return descriptor.match;
        }
      });
      if (type === "Property") {
        Object.defineProperty(descriptor, "matchRef", {
          get() {
            const syntax3 = descriptor.syntax;
            const value2 = syntaxHasTopLevelCommaMultiplier(syntax3) ? buildMatchGraph$1({
              ...syntax3,
              terms: [syntax3.terms[0].term]
            }, ref) : null;
            Object.defineProperty(descriptor, "matchRef", {
              value: value2
            });
            return value2;
          }
        });
      }
    }
    return descriptor;
  }
  addAtrule_(name2, syntax2) {
    if (!syntax2) {
      return;
    }
    this.atrules[name2] = {
      type: "Atrule",
      name: name2,
      prelude: syntax2.prelude ? this.createDescriptor(syntax2.prelude, "AtrulePrelude", name2) : null,
      descriptors: syntax2.descriptors ? Object.keys(syntax2.descriptors).reduce(
        (map, descName) => {
          map[descName] = this.createDescriptor(syntax2.descriptors[descName], "AtruleDescriptor", descName, name2);
          return map;
        },
        /* @__PURE__ */ Object.create(null)
      ) : null
    };
  }
  addProperty_(name2, syntax2) {
    if (!syntax2) {
      return;
    }
    this.properties[name2] = this.createDescriptor(syntax2, "Property", name2);
  }
  addType_(name2, syntax2) {
    if (!syntax2) {
      return;
    }
    this.types[name2] = this.createDescriptor(syntax2, "Type", name2);
  }
  checkAtruleName(atruleName) {
    if (!this.getAtrule(atruleName)) {
      return new SyntaxReferenceError$1("Unknown at-rule", "@" + atruleName);
    }
  }
  checkAtrulePrelude(atruleName, prelude) {
    const error2 = this.checkAtruleName(atruleName);
    if (error2) {
      return error2;
    }
    const atrule2 = this.getAtrule(atruleName);
    if (!atrule2.prelude && prelude) {
      return new SyntaxError("At-rule `@" + atruleName + "` should not contain a prelude");
    }
    if (atrule2.prelude && !prelude) {
      if (!matchSyntax$1(this, atrule2.prelude, "", false).matched) {
        return new SyntaxError("At-rule `@" + atruleName + "` should contain a prelude");
      }
    }
  }
  checkAtruleDescriptorName(atruleName, descriptorName) {
    const error2 = this.checkAtruleName(atruleName);
    if (error2) {
      return error2;
    }
    const atrule2 = this.getAtrule(atruleName);
    const descriptor = keyword$1(descriptorName);
    if (!atrule2.descriptors) {
      return new SyntaxError("At-rule `@" + atruleName + "` has no known descriptors");
    }
    if (!atrule2.descriptors[descriptor.name] && !atrule2.descriptors[descriptor.basename]) {
      return new SyntaxReferenceError$1("Unknown at-rule descriptor", descriptorName);
    }
  }
  checkPropertyName(propertyName) {
    if (!this.getProperty(propertyName)) {
      return new SyntaxReferenceError$1("Unknown property", propertyName);
    }
  }
  matchAtrulePrelude(atruleName, prelude) {
    const error2 = this.checkAtrulePrelude(atruleName, prelude);
    if (error2) {
      return buildMatchResult$1(null, error2);
    }
    const atrule2 = this.getAtrule(atruleName);
    if (!atrule2.prelude) {
      return buildMatchResult$1(null, null);
    }
    return matchSyntax$1(this, atrule2.prelude, prelude || "", false);
  }
  matchAtruleDescriptor(atruleName, descriptorName, value2) {
    const error2 = this.checkAtruleDescriptorName(atruleName, descriptorName);
    if (error2) {
      return buildMatchResult$1(null, error2);
    }
    const atrule2 = this.getAtrule(atruleName);
    const descriptor = keyword$1(descriptorName);
    return matchSyntax$1(this, atrule2.descriptors[descriptor.name] || atrule2.descriptors[descriptor.basename], value2, false);
  }
  matchDeclaration(node2) {
    if (node2.type !== "Declaration") {
      return buildMatchResult$1(null, new Error("Not a Declaration node"));
    }
    return this.matchProperty(node2.property, node2.value);
  }
  matchProperty(propertyName, value2) {
    if (property$1(propertyName).custom) {
      return buildMatchResult$1(null, new Error("Lexer matching doesn't applicable for custom properties"));
    }
    const error2 = this.checkPropertyName(propertyName);
    if (error2) {
      return buildMatchResult$1(null, error2);
    }
    return matchSyntax$1(this, this.getProperty(propertyName), value2, true);
  }
  matchType(typeName, value2) {
    const typeSyntax = this.getType(typeName);
    if (!typeSyntax) {
      return buildMatchResult$1(null, new SyntaxReferenceError$1("Unknown type", typeName));
    }
    return matchSyntax$1(this, typeSyntax, value2, false);
  }
  match(syntax2, value2) {
    if (typeof syntax2 !== "string" && (!syntax2 || !syntax2.type)) {
      return buildMatchResult$1(null, new SyntaxReferenceError$1("Bad syntax"));
    }
    if (typeof syntax2 === "string" || !syntax2.match) {
      syntax2 = this.createDescriptor(syntax2, "Type", "anonymous");
    }
    return matchSyntax$1(this, syntax2, value2, false);
  }
  findValueFragments(propertyName, value2, type, name2) {
    return matchFragments$1(this, value2, this.matchProperty(propertyName, value2), type, name2);
  }
  findDeclarationValueFragments(declaration, type, name2) {
    return matchFragments$1(this, declaration.value, this.matchDeclaration(declaration), type, name2);
  }
  findAllFragments(ast, type, name2) {
    const result = [];
    this.syntax.walk(ast, {
      visit: "Declaration",
      enter: (declaration) => {
        result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name2));
      }
    });
    return result;
  }
  getAtrule(atruleName, fallbackBasename = true) {
    const atrule2 = keyword$1(atruleName);
    const atruleEntry = atrule2.vendor && fallbackBasename ? this.atrules[atrule2.name] || this.atrules[atrule2.basename] : this.atrules[atrule2.name];
    return atruleEntry || null;
  }
  getAtrulePrelude(atruleName, fallbackBasename = true) {
    const atrule2 = this.getAtrule(atruleName, fallbackBasename);
    return atrule2 && atrule2.prelude || null;
  }
  getAtruleDescriptor(atruleName, name2) {
    return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators ? this.atrules[atruleName].declarators[name2] || null : null;
  }
  getProperty(propertyName, fallbackBasename = true) {
    const property2 = property$1(propertyName);
    const propertyEntry = property2.vendor && fallbackBasename ? this.properties[property2.name] || this.properties[property2.basename] : this.properties[property2.name];
    return propertyEntry || null;
  }
  getType(name2) {
    return hasOwnProperty.call(this.types, name2) ? this.types[name2] : null;
  }
  validate() {
    function syntaxRef(name2, isType2) {
      return isType2 ? `<${name2}>` : `<'${name2}'>`;
    }
    function validate(syntax2, name2, broken, descriptor) {
      if (broken.has(name2)) {
        return broken.get(name2);
      }
      broken.set(name2, false);
      if (descriptor.syntax !== null) {
        walk$4(descriptor.syntax, function(node2) {
          if (node2.type !== "Type" && node2.type !== "Property") {
            return;
          }
          const map = node2.type === "Type" ? syntax2.types : syntax2.properties;
          const brokenMap = node2.type === "Type" ? brokenTypes : brokenProperties;
          if (!hasOwnProperty.call(map, node2.name)) {
            errors.push(`${syntaxRef(name2, broken === brokenTypes)} used missed syntax definition ${syntaxRef(node2.name, node2.type === "Type")}`);
            broken.set(name2, true);
          } else if (validate(syntax2, node2.name, brokenMap, map[node2.name])) {
            errors.push(`${syntaxRef(name2, broken === brokenTypes)} used broken syntax definition ${syntaxRef(node2.name, node2.type === "Type")}`);
            broken.set(name2, true);
          }
        }, this);
      }
    }
    const errors = [];
    let brokenTypes = /* @__PURE__ */ new Map();
    let brokenProperties = /* @__PURE__ */ new Map();
    for (const key in this.types) {
      validate(this, key, brokenTypes, this.types[key]);
    }
    for (const key in this.properties) {
      validate(this, key, brokenProperties, this.properties[key]);
    }
    const brokenTypesArray = [...brokenTypes.keys()].filter((name2) => brokenTypes.get(name2));
    const brokenPropertiesArray = [...brokenProperties.keys()].filter((name2) => brokenProperties.get(name2));
    if (brokenTypesArray.length || brokenPropertiesArray.length) {
      return {
        errors,
        types: brokenTypesArray,
        properties: brokenPropertiesArray
      };
    }
    return null;
  }
  dump(syntaxAsAst, pretty) {
    return {
      generic: this.generic,
      cssWideKeywords: this.cssWideKeywords,
      units: this.units,
      types: dumpMapSyntax$1(this.types, !pretty, syntaxAsAst),
      properties: dumpMapSyntax$1(this.properties, !pretty, syntaxAsAst),
      atrules: dumpAtruleMapSyntax$1(this.atrules, !pretty, syntaxAsAst)
    };
  }
  toString() {
    return JSON.stringify(this.dump());
  }
};
function appendOrSet(a, b) {
  if (typeof b === "string" && /^\s*\|/.test(b)) {
    return typeof a === "string" ? a + b : b.replace(/^\s*\|\s*/, "");
  }
  return b || null;
}
function sliceProps(obj, props) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const [key, value2] of Object.entries(obj)) {
    if (value2) {
      result[key] = {};
      for (const prop of Object.keys(value2)) {
        if (props.includes(prop)) {
          result[key][prop] = value2[prop];
        }
      }
    }
  }
  return result;
}
function mix$2(dest, src) {
  const result = { ...dest };
  for (const [prop, value2] of Object.entries(src)) {
    switch (prop) {
      case "generic":
        result[prop] = Boolean(value2);
        break;
      case "cssWideKeywords":
        result[prop] = dest[prop] ? [...dest[prop], ...value2] : value2 || [];
        break;
      case "units":
        result[prop] = { ...dest[prop] };
        for (const [name2, patch] of Object.entries(value2)) {
          result[prop][name2] = Array.isArray(patch) ? patch : [];
        }
        break;
      case "atrules":
        result[prop] = { ...dest[prop] };
        for (const [name2, atrule2] of Object.entries(value2)) {
          const exists = result[prop][name2] || {};
          const current = result[prop][name2] = {
            prelude: exists.prelude || null,
            descriptors: {
              ...exists.descriptors
            }
          };
          if (!atrule2) {
            continue;
          }
          current.prelude = atrule2.prelude ? appendOrSet(current.prelude, atrule2.prelude) : current.prelude || null;
          for (const [descriptorName, descriptorValue] of Object.entries(atrule2.descriptors || {})) {
            current.descriptors[descriptorName] = descriptorValue ? appendOrSet(current.descriptors[descriptorName], descriptorValue) : null;
          }
          if (!Object.keys(current.descriptors).length) {
            current.descriptors = null;
          }
        }
        break;
      case "types":
      case "properties":
        result[prop] = { ...dest[prop] };
        for (const [name2, syntax2] of Object.entries(value2)) {
          result[prop][name2] = appendOrSet(result[prop][name2], syntax2);
        }
        break;
      case "scope":
      case "features":
        result[prop] = { ...dest[prop] };
        for (const [name2, props] of Object.entries(value2)) {
          result[prop][name2] = { ...result[prop][name2], ...props };
        }
        break;
      case "parseContext":
        result[prop] = {
          ...dest[prop],
          ...value2
        };
        break;
      case "atrule":
      case "pseudo":
        result[prop] = {
          ...dest[prop],
          ...sliceProps(value2, ["parse"])
        };
        break;
      case "node":
        result[prop] = {
          ...dest[prop],
          ...sliceProps(value2, ["name", "structure", "parse", "generate", "walkContext"])
        };
        break;
    }
  }
  return result;
}
function createSyntax$2(config) {
  const parse2 = createParser$1(config);
  const walk2 = createWalker$1(config);
  const generate2 = createGenerator$1(config);
  const { fromPlainObject: fromPlainObject2, toPlainObject: toPlainObject2 } = createConvertor$1(walk2);
  const syntax2 = {
    lexer: null,
    createLexer: (config2) => new Lexer$1(config2, syntax2, syntax2.lexer.structure),
    tokenize: tokenize$4,
    parse: parse2,
    generate: generate2,
    walk: walk2,
    find: walk2.find,
    findLast: walk2.findLast,
    findAll: walk2.findAll,
    fromPlainObject: fromPlainObject2,
    toPlainObject: toPlainObject2,
    fork(extension) {
      const base = mix$2({}, config);
      return createSyntax$2(
        typeof extension === "function" ? extension(base) : mix$2(base, extension)
      );
    }
  };
  syntax2.lexer = new Lexer$1({
    generic: config.generic,
    cssWideKeywords: config.cssWideKeywords,
    units: config.units,
    types: config.types,
    atrules: config.atrules,
    properties: config.properties,
    node: config.node
  }, syntax2);
  return syntax2;
}
const createSyntax$3 = (config) => createSyntax$2(mix$2({}, config));
const definitions$1 = {
  "generic": true,
  "cssWideKeywords": [
    "initial",
    "inherit",
    "unset",
    "revert",
    "revert-layer"
  ],
  "units": {
    "angle": [
      "deg",
      "grad",
      "rad",
      "turn"
    ],
    "decibel": [
      "db"
    ],
    "flex": [
      "fr"
    ],
    "frequency": [
      "hz",
      "khz"
    ],
    "length": [
      "cm",
      "mm",
      "q",
      "in",
      "pt",
      "pc",
      "px",
      "em",
      "rem",
      "ex",
      "rex",
      "cap",
      "rcap",
      "ch",
      "rch",
      "ic",
      "ric",
      "lh",
      "rlh",
      "vw",
      "svw",
      "lvw",
      "dvw",
      "vh",
      "svh",
      "lvh",
      "dvh",
      "vi",
      "svi",
      "lvi",
      "dvi",
      "vb",
      "svb",
      "lvb",
      "dvb",
      "vmin",
      "svmin",
      "lvmin",
      "dvmin",
      "vmax",
      "svmax",
      "lvmax",
      "dvmax",
      "cqw",
      "cqh",
      "cqi",
      "cqb",
      "cqmin",
      "cqmax"
    ],
    "resolution": [
      "dpi",
      "dpcm",
      "dppx",
      "x"
    ],
    "semitones": [
      "st"
    ],
    "time": [
      "s",
      "ms"
    ]
  },
  "types": {
    "abs()": "abs( <calc-sum> )",
    "absolute-size": "xx-small|x-small|small|medium|large|x-large|xx-large|xxx-large",
    "acos()": "acos( <calc-sum> )",
    "alpha-value": "<number>|<percentage>",
    "angle-percentage": "<angle>|<percentage>",
    "angular-color-hint": "<angle-percentage>",
    "angular-color-stop": "<color>&&<color-stop-angle>?",
    "angular-color-stop-list": "[<angular-color-stop> [, <angular-color-hint>]?]# , <angular-color-stop>",
    "animateable-feature": "scroll-position|contents|<custom-ident>",
    "asin()": "asin( <calc-sum> )",
    "atan()": "atan( <calc-sum> )",
    "atan2()": "atan2( <calc-sum> , <calc-sum> )",
    "attachment": "scroll|fixed|local",
    "attr()": "attr( <attr-name> <type-or-unit>? [, <attr-fallback>]? )",
    "attr-matcher": "['~'|'|'|'^'|'$'|'*']? '='",
    "attr-modifier": "i|s",
    "attribute-selector": "'[' <wq-name> ']'|'[' <wq-name> <attr-matcher> [<string-token>|<ident-token>] <attr-modifier>? ']'",
    "auto-repeat": "repeat( [auto-fill|auto-fit] , [<line-names>? <fixed-size>]+ <line-names>? )",
    "auto-track-list": "[<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>? <auto-repeat> [<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>?",
    "axis": "block|inline|x|y",
    "baseline-position": "[first|last]? baseline",
    "basic-shape": "<inset()>|<xywh()>|<rect()>|<circle()>|<ellipse()>|<polygon()>|<path()>",
    "bg-image": "none|<image>",
    "bg-layer": "<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>",
    "bg-position": "[[left|center|right|top|bottom|<length-percentage>]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]|[center|[left|right] <length-percentage>?]&&[center|[top|bottom] <length-percentage>?]]",
    "bg-size": "[<length-percentage>|auto]{1,2}|cover|contain",
    "blur()": "blur( <length> )",
    "blend-mode": "normal|multiply|screen|overlay|darken|lighten|color-dodge|color-burn|hard-light|soft-light|difference|exclusion|hue|saturation|color|luminosity",
    "box": "border-box|padding-box|content-box",
    "brightness()": "brightness( <number-percentage> )",
    "calc()": "calc( <calc-sum> )",
    "calc-sum": "<calc-product> [['+'|'-'] <calc-product>]*",
    "calc-product": "<calc-value> ['*' <calc-value>|'/' <number>]*",
    "calc-value": "<number>|<dimension>|<percentage>|<calc-constant>|( <calc-sum> )",
    "calc-constant": "e|pi|infinity|-infinity|NaN",
    "cf-final-image": "<image>|<color>",
    "cf-mixing-image": "<percentage>?&&<image>",
    "circle()": "circle( [<shape-radius>]? [at <position>]? )",
    "clamp()": "clamp( <calc-sum>#{3} )",
    "class-selector": "'.' <ident-token>",
    "clip-source": "<url>",
    "color": "<color-base>|currentColor|<system-color>|<device-cmyk()>|<light-dark()>|<-non-standard-color>",
    "color-stop": "<color-stop-length>|<color-stop-angle>",
    "color-stop-angle": "<angle-percentage>{1,2}",
    "color-stop-length": "<length-percentage>{1,2}",
    "color-stop-list": "[<linear-color-stop> [, <linear-color-hint>]?]# , <linear-color-stop>",
    "color-interpolation-method": "in [<rectangular-color-space>|<polar-color-space> <hue-interpolation-method>?|<custom-color-space>]",
    "combinator": "'>'|'+'|'~'|['|' '|']",
    "common-lig-values": "[common-ligatures|no-common-ligatures]",
    "compat-auto": "searchfield|textarea|push-button|slider-horizontal|checkbox|radio|square-button|menulist|listbox|meter|progress-bar|button",
    "composite-style": "clear|copy|source-over|source-in|source-out|source-atop|destination-over|destination-in|destination-out|destination-atop|xor",
    "compositing-operator": "add|subtract|intersect|exclude",
    "compound-selector": "[<type-selector>? <subclass-selector>*]!",
    "compound-selector-list": "<compound-selector>#",
    "complex-selector": "<complex-selector-unit> [<combinator>? <complex-selector-unit>]*",
    "complex-selector-list": "<complex-selector>#",
    "conic-gradient()": "conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )",
    "contextual-alt-values": "[contextual|no-contextual]",
    "content-distribution": "space-between|space-around|space-evenly|stretch",
    "content-list": "[<string>|contents|<image>|<counter>|<quote>|<target>|<leader()>|<attr()>]+",
    "content-position": "center|start|end|flex-start|flex-end",
    "content-replacement": "<image>",
    "contrast()": "contrast( [<number-percentage>] )",
    "cos()": "cos( <calc-sum> )",
    "counter": "<counter()>|<counters()>",
    "counter()": "counter( <counter-name> , <counter-style>? )",
    "counter-name": "<custom-ident>",
    "counter-style": "<counter-style-name>|symbols( )",
    "counter-style-name": "<custom-ident>",
    "counters()": "counters( <counter-name> , <string> , <counter-style>? )",
    "cross-fade()": "cross-fade( <cf-mixing-image> , <cf-final-image>? )",
    "cubic-bezier-timing-function": "ease|ease-in|ease-out|ease-in-out|cubic-bezier( <number [0,1]> , <number> , <number [0,1]> , <number> )",
    "deprecated-system-color": "ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText",
    "discretionary-lig-values": "[discretionary-ligatures|no-discretionary-ligatures]",
    "display-box": "contents|none",
    "display-inside": "flow|flow-root|table|flex|grid|ruby",
    "display-internal": "table-row-group|table-header-group|table-footer-group|table-row|table-cell|table-column-group|table-column|table-caption|ruby-base|ruby-text|ruby-base-container|ruby-text-container",
    "display-legacy": "inline-block|inline-list-item|inline-table|inline-flex|inline-grid",
    "display-listitem": "<display-outside>?&&[flow|flow-root]?&&list-item",
    "display-outside": "block|inline|run-in",
    "drop-shadow()": "drop-shadow( <length>{2,3} <color>? )",
    "east-asian-variant-values": "[jis78|jis83|jis90|jis04|simplified|traditional]",
    "east-asian-width-values": "[full-width|proportional-width]",
    "element()": "element( <custom-ident> , [first|start|last|first-except]? )|element( <id-selector> )",
    "ellipse()": "ellipse( [<shape-radius>{2}]? [at <position>]? )",
    "ending-shape": "circle|ellipse",
    "env()": "env( <custom-ident> , <declaration-value>? )",
    "exp()": "exp( <calc-sum> )",
    "explicit-track-list": "[<line-names>? <track-size>]+ <line-names>?",
    "family-name": "<string>|<custom-ident>+",
    "feature-tag-value": "<string> [<integer>|on|off]?",
    "feature-type": "@stylistic|@historical-forms|/styleset|@character-variant|@swash|@ornaments|@annotation",
    "feature-value-block": "<feature-type> '{' <feature-value-declaration-list> '}'",
    "feature-value-block-list": "<feature-value-block>+",
    "feature-value-declaration": "<custom-ident> : <integer>+ ;",
    "feature-value-declaration-list": "<feature-value-declaration>",
    "feature-value-name": "<custom-ident>",
    "fill-rule": "nonzero|evenodd",
    "filter-function": "<blur()>|<brightness()>|<contrast()>|<drop-shadow()>|<grayscale()>|<hue-rotate()>|<invert()>|<opacity()>|<saturate()>|<sepia()>",
    "filter-function-list": "[<filter-function>|<url>]+",
    "final-bg-layer": "<'background-color'>||<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>",
    "fixed-breadth": "<length-percentage>",
    "fixed-repeat": "repeat( [<integer [1,∞]>] , [<line-names>? <fixed-size>]+ <line-names>? )",
    "fixed-size": "<fixed-breadth>|minmax( <fixed-breadth> , <track-breadth> )|minmax( <inflexible-breadth> , <fixed-breadth> )",
    "font-stretch-absolute": "normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded|<percentage>",
    "font-variant-css21": "[normal|small-caps]",
    "font-weight-absolute": "normal|bold|<number [1,1000]>",
    "frequency-percentage": "<frequency>|<percentage>",
    "general-enclosed": "[<function-token> <any-value>? )]|[( <any-value>? )]",
    "generic-family": "<generic-script-specific>|<generic-complete>|<generic-incomplete>|<-non-standard-generic-family>",
    "generic-name": "serif|sans-serif|cursive|fantasy|monospace",
    "geometry-box": "<shape-box>|fill-box|stroke-box|view-box",
    "gradient": "<linear-gradient()>|<repeating-linear-gradient()>|<radial-gradient()>|<repeating-radial-gradient()>|<conic-gradient()>|<repeating-conic-gradient()>|<-legacy-gradient>",
    "grayscale()": "grayscale( <number-percentage> )",
    "grid-line": "auto|<custom-ident>|[<integer>&&<custom-ident>?]|[span&&[<integer>||<custom-ident>]]",
    "historical-lig-values": "[historical-ligatures|no-historical-ligatures]",
    "hsl()": "hsl( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsl( <hue> , <percentage> , <percentage> , <alpha-value>? )",
    "hsla()": "hsla( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsla( <hue> , <percentage> , <percentage> , <alpha-value>? )",
    "hue": "<number>|<angle>",
    "hue-rotate()": "hue-rotate( <angle> )",
    "hue-interpolation-method": "[shorter|longer|increasing|decreasing] hue",
    "hwb()": "hwb( [<hue>|none] [<percentage>|none] [<percentage>|none] [/ [<alpha-value>|none]]? )",
    "hypot()": "hypot( <calc-sum># )",
    "image": "<url>|<image()>|<image-set()>|<element()>|<paint()>|<cross-fade()>|<gradient>",
    "image()": "image( <image-tags>? [<image-src>? , <color>?]! )",
    "image-set()": "image-set( <image-set-option># )",
    "image-set-option": "[<image>|<string>] [<resolution>||type( <string> )]",
    "image-src": "<url>|<string>",
    "image-tags": "ltr|rtl",
    "inflexible-breadth": "<length-percentage>|min-content|max-content|auto",
    "inset()": "inset( <length-percentage>{1,4} [round <'border-radius'>]? )",
    "invert()": "invert( <number-percentage> )",
    "keyframes-name": "<custom-ident>|<string>",
    "keyframe-block": "<keyframe-selector># { <declaration-list> }",
    "keyframe-block-list": "<keyframe-block>+",
    "keyframe-selector": "from|to|<percentage>|<timeline-range-name> <percentage>",
    "lab()": "lab( [<percentage>|<number>|none] [<percentage>|<number>|none] [<percentage>|<number>|none] [/ [<alpha-value>|none]]? )",
    "layer()": "layer( <layer-name> )",
    "layer-name": "<ident> ['.' <ident>]*",
    "lch()": "lch( [<percentage>|<number>|none] [<percentage>|<number>|none] [<hue>|none] [/ [<alpha-value>|none]]? )",
    "leader()": "leader( <leader-type> )",
    "leader-type": "dotted|solid|space|<string>",
    "length-percentage": "<length>|<percentage>",
    "light-dark()": "light-dark( <color> , <color> )",
    "line-names": "'[' <custom-ident>* ']'",
    "line-name-list": "[<line-names>|<name-repeat>]+",
    "line-style": "none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset",
    "line-width": "<length>|thin|medium|thick",
    "linear-color-hint": "<length-percentage>",
    "linear-color-stop": "<color> <color-stop-length>?",
    "linear-gradient()": "linear-gradient( [[<angle>|to <side-or-corner>]||<color-interpolation-method>]? , <color-stop-list> )",
    "log()": "log( <calc-sum> , <calc-sum>? )",
    "mask-layer": "<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||<geometry-box>||[<geometry-box>|no-clip]||<compositing-operator>||<masking-mode>",
    "mask-position": "[<length-percentage>|left|center|right] [<length-percentage>|top|center|bottom]?",
    "mask-reference": "none|<image>|<mask-source>",
    "mask-source": "<url>",
    "masking-mode": "alpha|luminance|match-source",
    "matrix()": "matrix( <number>#{6} )",
    "matrix3d()": "matrix3d( <number>#{16} )",
    "max()": "max( <calc-sum># )",
    "media-and": "<media-in-parens> [and <media-in-parens>]+",
    "media-condition": "<media-not>|<media-and>|<media-or>|<media-in-parens>",
    "media-condition-without-or": "<media-not>|<media-and>|<media-in-parens>",
    "media-feature": "( [<mf-plain>|<mf-boolean>|<mf-range>] )",
    "media-in-parens": "( <media-condition> )|<media-feature>|<general-enclosed>",
    "media-not": "not <media-in-parens>",
    "media-or": "<media-in-parens> [or <media-in-parens>]+",
    "media-query": "<media-condition>|[not|only]? <media-type> [and <media-condition-without-or>]?",
    "media-query-list": "<media-query>#",
    "media-type": "<ident>",
    "mf-boolean": "<mf-name>",
    "mf-name": "<ident>",
    "mf-plain": "<mf-name> : <mf-value>",
    "mf-range": "<mf-name> ['<'|'>']? '='? <mf-value>|<mf-value> ['<'|'>']? '='? <mf-name>|<mf-value> '<' '='? <mf-name> '<' '='? <mf-value>|<mf-value> '>' '='? <mf-name> '>' '='? <mf-value>",
    "mf-value": "<number>|<dimension>|<ident>|<ratio>",
    "min()": "min( <calc-sum># )",
    "minmax()": "minmax( [<length-percentage>|min-content|max-content|auto] , [<length-percentage>|<flex>|min-content|max-content|auto] )",
    "mod()": "mod( <calc-sum> , <calc-sum> )",
    "name-repeat": "repeat( [<integer [1,∞]>|auto-fill] , <line-names>+ )",
    "named-color": "transparent|aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|rebeccapurple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|violet|wheat|white|whitesmoke|yellow|yellowgreen",
    "namespace-prefix": "<ident>",
    "ns-prefix": "[<ident-token>|'*']? '|'",
    "number-percentage": "<number>|<percentage>",
    "numeric-figure-values": "[lining-nums|oldstyle-nums]",
    "numeric-fraction-values": "[diagonal-fractions|stacked-fractions]",
    "numeric-spacing-values": "[proportional-nums|tabular-nums]",
    "nth": "<an-plus-b>|even|odd",
    "opacity()": "opacity( [<number-percentage>] )",
    "overflow-position": "unsafe|safe",
    "outline-radius": "<length>|<percentage>",
    "page-body": "<declaration>? [; <page-body>]?|<page-margin-box> <page-body>",
    "page-margin-box": "<page-margin-box-type> '{' <declaration-list> '}'",
    "page-margin-box-type": "@top-left-corner|@top-left|@top-center|@top-right|@top-right-corner|@bottom-left-corner|@bottom-left|@bottom-center|@bottom-right|@bottom-right-corner|@left-top|@left-middle|@left-bottom|@right-top|@right-middle|@right-bottom",
    "page-selector-list": "[<page-selector>#]?",
    "page-selector": "<pseudo-page>+|<ident> <pseudo-page>*",
    "page-size": "A5|A4|A3|B5|B4|JIS-B5|JIS-B4|letter|legal|ledger",
    "path()": "path( [<fill-rule> ,]? <string> )",
    "paint()": "paint( <ident> , <declaration-value>? )",
    "perspective()": "perspective( [<length [0,∞]>|none] )",
    "polygon()": "polygon( <fill-rule>? , [<length-percentage> <length-percentage>]# )",
    "polar-color-space": "hsl|hwb|lch|oklch",
    "position": "[[left|center|right]||[top|center|bottom]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]?|[[left|right] <length-percentage>]&&[[top|bottom] <length-percentage>]]",
    "pow()": "pow( <calc-sum> , <calc-sum> )",
    "pseudo-class-selector": "':' <ident-token>|':' <function-token> <any-value> ')'",
    "pseudo-element-selector": "':' <pseudo-class-selector>|<legacy-pseudo-element-selector>",
    "pseudo-page": ": [left|right|first|blank]",
    "quote": "open-quote|close-quote|no-open-quote|no-close-quote",
    "radial-gradient()": "radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )",
    "ratio": "<number [0,∞]> [/ <number [0,∞]>]?",
    "ray()": "ray( <angle>&&<ray-size>?&&contain?&&[at <position>]? )",
    "ray-size": "closest-side|closest-corner|farthest-side|farthest-corner|sides",
    "rectangular-color-space": "srgb|srgb-linear|display-p3|a98-rgb|prophoto-rgb|rec2020|lab|oklab|xyz|xyz-d50|xyz-d65",
    "relative-selector": "<combinator>? <complex-selector>",
    "relative-selector-list": "<relative-selector>#",
    "relative-size": "larger|smaller",
    "rem()": "rem( <calc-sum> , <calc-sum> )",
    "repeat-style": "repeat-x|repeat-y|[repeat|space|round|no-repeat]{1,2}",
    "repeating-conic-gradient()": "repeating-conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )",
    "repeating-linear-gradient()": "repeating-linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )",
    "repeating-radial-gradient()": "repeating-radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )",
    "reversed-counter-name": "reversed( <counter-name> )",
    "rgb()": "rgb( <percentage>{3} [/ <alpha-value>]? )|rgb( <number>{3} [/ <alpha-value>]? )|rgb( <percentage>#{3} , <alpha-value>? )|rgb( <number>#{3} , <alpha-value>? )",
    "rgba()": "rgba( <percentage>{3} [/ <alpha-value>]? )|rgba( <number>{3} [/ <alpha-value>]? )|rgba( <percentage>#{3} , <alpha-value>? )|rgba( <number>#{3} , <alpha-value>? )",
    "rotate()": "rotate( [<angle>|<zero>] )",
    "rotate3d()": "rotate3d( <number> , <number> , <number> , [<angle>|<zero>] )",
    "rotateX()": "rotateX( [<angle>|<zero>] )",
    "rotateY()": "rotateY( [<angle>|<zero>] )",
    "rotateZ()": "rotateZ( [<angle>|<zero>] )",
    "round()": "round( <rounding-strategy>? , <calc-sum> , <calc-sum> )",
    "rounding-strategy": "nearest|up|down|to-zero",
    "saturate()": "saturate( <number-percentage> )",
    "scale()": "scale( [<number>|<percentage>]#{1,2} )",
    "scale3d()": "scale3d( [<number>|<percentage>]#{3} )",
    "scaleX()": "scaleX( [<number>|<percentage>] )",
    "scaleY()": "scaleY( [<number>|<percentage>] )",
    "scaleZ()": "scaleZ( [<number>|<percentage>] )",
    "scroll()": "scroll( [<axis>||<scroller>]? )",
    "scroller": "root|nearest|self",
    "self-position": "center|start|end|self-start|self-end|flex-start|flex-end",
    "shape-radius": "<length-percentage>|closest-side|farthest-side",
    "sign()": "sign( <calc-sum> )",
    "skew()": "skew( [<angle>|<zero>] , [<angle>|<zero>]? )",
    "skewX()": "skewX( [<angle>|<zero>] )",
    "skewY()": "skewY( [<angle>|<zero>] )",
    "sepia()": "sepia( <number-percentage> )",
    "shadow": "inset?&&<length>{2,4}&&<color>?",
    "shadow-t": "[<length>{2,3}&&<color>?]",
    "shape": "rect( <top> , <right> , <bottom> , <left> )|rect( <top> <right> <bottom> <left> )",
    "shape-box": "<box>|margin-box",
    "side-or-corner": "[left|right]||[top|bottom]",
    "sin()": "sin( <calc-sum> )",
    "single-animation": "<'animation-duration'>||<easing-function>||<'animation-delay'>||<single-animation-iteration-count>||<single-animation-direction>||<single-animation-fill-mode>||<single-animation-play-state>||[none|<keyframes-name>]||<single-animation-timeline>",
    "single-animation-direction": "normal|reverse|alternate|alternate-reverse",
    "single-animation-fill-mode": "none|forwards|backwards|both",
    "single-animation-iteration-count": "infinite|<number>",
    "single-animation-play-state": "running|paused",
    "single-animation-timeline": "auto|none|<dashed-ident>|<scroll()>|<view()>",
    "single-transition": "[none|<single-transition-property>]||<time>||<easing-function>||<time>||<transition-behavior-value>",
    "single-transition-property": "all|<custom-ident>",
    "size": "closest-side|farthest-side|closest-corner|farthest-corner|<length>|<length-percentage>{2}",
    "sqrt()": "sqrt( <calc-sum> )",
    "step-position": "jump-start|jump-end|jump-none|jump-both|start|end",
    "step-timing-function": "step-start|step-end|steps( <integer> [, <step-position>]? )",
    "subclass-selector": "<id-selector>|<class-selector>|<attribute-selector>|<pseudo-class-selector>",
    "supports-condition": "not <supports-in-parens>|<supports-in-parens> [and <supports-in-parens>]*|<supports-in-parens> [or <supports-in-parens>]*",
    "supports-in-parens": "( <supports-condition> )|<supports-feature>|<general-enclosed>",
    "supports-feature": "<supports-decl>|<supports-selector-fn>",
    "supports-decl": "( <declaration> )",
    "supports-selector-fn": "selector( <complex-selector> )",
    "symbol": "<string>|<image>|<custom-ident>",
    "system-color": "AccentColor|AccentColorText|ActiveText|ButtonBorder|ButtonFace|ButtonText|Canvas|CanvasText|Field|FieldText|GrayText|Highlight|HighlightText|LinkText|Mark|MarkText|SelectedItem|SelectedItemText|VisitedText",
    "tan()": "tan( <calc-sum> )",
    "target": "<target-counter()>|<target-counters()>|<target-text()>",
    "target-counter()": "target-counter( [<string>|<url>] , <custom-ident> , <counter-style>? )",
    "target-counters()": "target-counters( [<string>|<url>] , <custom-ident> , <string> , <counter-style>? )",
    "target-text()": "target-text( [<string>|<url>] , [content|before|after|first-letter]? )",
    "time-percentage": "<time>|<percentage>",
    "timeline-range-name": "cover|contain|entry|exit|entry-crossing|exit-crossing",
    "easing-function": "linear|<cubic-bezier-timing-function>|<step-timing-function>",
    "track-breadth": "<length-percentage>|<flex>|min-content|max-content|auto",
    "track-list": "[<line-names>? [<track-size>|<track-repeat>]]+ <line-names>?",
    "track-repeat": "repeat( [<integer [1,∞]>] , [<line-names>? <track-size>]+ <line-names>? )",
    "track-size": "<track-breadth>|minmax( <inflexible-breadth> , <track-breadth> )|fit-content( <length-percentage> )",
    "transform-function": "<matrix()>|<translate()>|<translateX()>|<translateY()>|<scale()>|<scaleX()>|<scaleY()>|<rotate()>|<skew()>|<skewX()>|<skewY()>|<matrix3d()>|<translate3d()>|<translateZ()>|<scale3d()>|<scaleZ()>|<rotate3d()>|<rotateX()>|<rotateY()>|<rotateZ()>|<perspective()>",
    "transform-list": "<transform-function>+",
    "transition-behavior-value": "normal|allow-discrete",
    "translate()": "translate( <length-percentage> , <length-percentage>? )",
    "translate3d()": "translate3d( <length-percentage> , <length-percentage> , <length> )",
    "translateX()": "translateX( <length-percentage> )",
    "translateY()": "translateY( <length-percentage> )",
    "translateZ()": "translateZ( <length> )",
    "type-or-unit": "string|color|url|integer|number|length|angle|time|frequency|cap|ch|em|ex|ic|lh|rlh|rem|vb|vi|vw|vh|vmin|vmax|mm|Q|cm|in|pt|pc|px|deg|grad|rad|turn|ms|s|Hz|kHz|%",
    "type-selector": "<wq-name>|<ns-prefix>? '*'",
    "var()": "var( <custom-property-name> , <declaration-value>? )",
    "view()": "view( [<axis>||<'view-timeline-inset'>]? )",
    "viewport-length": "auto|<length-percentage>",
    "visual-box": "content-box|padding-box|border-box",
    "wq-name": "<ns-prefix>? <ident-token>",
    "-legacy-gradient": "<-webkit-gradient()>|<-legacy-linear-gradient>|<-legacy-repeating-linear-gradient>|<-legacy-radial-gradient>|<-legacy-repeating-radial-gradient>",
    "-legacy-linear-gradient": "-moz-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-linear-gradient( <-legacy-linear-gradient-arguments> )",
    "-legacy-repeating-linear-gradient": "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )",
    "-legacy-linear-gradient-arguments": "[<angle>|<side-or-corner>]? , <color-stop-list>",
    "-legacy-radial-gradient": "-moz-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-radial-gradient( <-legacy-radial-gradient-arguments> )",
    "-legacy-repeating-radial-gradient": "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )",
    "-legacy-radial-gradient-arguments": "[<position> ,]? [[[<-legacy-radial-gradient-shape>||<-legacy-radial-gradient-size>]|[<length>|<percentage>]{2}] ,]? <color-stop-list>",
    "-legacy-radial-gradient-size": "closest-side|closest-corner|farthest-side|farthest-corner|contain|cover",
    "-legacy-radial-gradient-shape": "circle|ellipse",
    "-non-standard-font": "-apple-system-body|-apple-system-headline|-apple-system-subheadline|-apple-system-caption1|-apple-system-caption2|-apple-system-footnote|-apple-system-short-body|-apple-system-short-headline|-apple-system-short-subheadline|-apple-system-short-caption1|-apple-system-short-footnote|-apple-system-tall-body",
    "-non-standard-color": "-moz-ButtonDefault|-moz-ButtonHoverFace|-moz-ButtonHoverText|-moz-CellHighlight|-moz-CellHighlightText|-moz-Combobox|-moz-ComboboxText|-moz-Dialog|-moz-DialogText|-moz-dragtargetzone|-moz-EvenTreeRow|-moz-Field|-moz-FieldText|-moz-html-CellHighlight|-moz-html-CellHighlightText|-moz-mac-accentdarkestshadow|-moz-mac-accentdarkshadow|-moz-mac-accentface|-moz-mac-accentlightesthighlight|-moz-mac-accentlightshadow|-moz-mac-accentregularhighlight|-moz-mac-accentregularshadow|-moz-mac-chrome-active|-moz-mac-chrome-inactive|-moz-mac-focusring|-moz-mac-menuselect|-moz-mac-menushadow|-moz-mac-menutextselect|-moz-MenuHover|-moz-MenuHoverText|-moz-MenuBarText|-moz-MenuBarHoverText|-moz-nativehyperlinktext|-moz-OddTreeRow|-moz-win-communicationstext|-moz-win-mediatext|-moz-activehyperlinktext|-moz-default-background-color|-moz-default-color|-moz-hyperlinktext|-moz-visitedhyperlinktext|-webkit-activelink|-webkit-focus-ring-color|-webkit-link|-webkit-text",
    "-non-standard-image-rendering": "optimize-contrast|-moz-crisp-edges|-o-crisp-edges|-webkit-optimize-contrast",
    "-non-standard-overflow": "overlay|-moz-scrollbars-none|-moz-scrollbars-horizontal|-moz-scrollbars-vertical|-moz-hidden-unscrollable",
    "-non-standard-size": "intrinsic|min-intrinsic|-webkit-fill-available|-webkit-fit-content|-webkit-min-content|-webkit-max-content|-moz-available|-moz-fit-content|-moz-min-content|-moz-max-content",
    "-webkit-gradient()": "-webkit-gradient( <-webkit-gradient-type> , <-webkit-gradient-point> [, <-webkit-gradient-point>|, <-webkit-gradient-radius> , <-webkit-gradient-point>] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )",
    "-webkit-gradient-color-stop": "from( <color> )|color-stop( [<number-zero-one>|<percentage>] , <color> )|to( <color> )",
    "-webkit-gradient-point": "[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]",
    "-webkit-gradient-radius": "<length>|<percentage>",
    "-webkit-gradient-type": "linear|radial",
    "-webkit-mask-box-repeat": "repeat|stretch|round",
    "-ms-filter-function-list": "<-ms-filter-function>+",
    "-ms-filter-function": "<-ms-filter-function-progid>|<-ms-filter-function-legacy>",
    "-ms-filter-function-progid": "'progid:' [<ident-token> '.']* [<ident-token>|<function-token> <any-value>? )]",
    "-ms-filter-function-legacy": "<ident-token>|<function-token> <any-value>? )",
    "absolute-color-base": "<hex-color>|<absolute-color-function>|<named-color>|transparent",
    "absolute-color-function": "<rgb()>|<rgba()>|<hsl()>|<hsla()>|<hwb()>|<lab()>|<lch()>|<oklab()>|<oklch()>|<color()>",
    "age": "child|young|old",
    "anchor-name": "<dashed-ident>",
    "attr-name": "<wq-name>",
    "attr-fallback": "<any-value>",
    "bg-clip": "<box>|border|text",
    "bottom": "<length>|auto",
    "container-name": "<custom-ident>",
    "container-condition": "not <query-in-parens>|<query-in-parens> [[and <query-in-parens>]*|[or <query-in-parens>]*]",
    "coord-box": "content-box|padding-box|border-box|fill-box|stroke-box|view-box",
    "generic-voice": "[<age>? <gender> <integer>?]",
    "gender": "male|female|neutral",
    "generic-script-specific": "generic( kai )|generic( fangsong )|generic( nastaliq )",
    "generic-complete": "serif|sans-serif|system-ui|cursive|fantasy|math|monospace",
    "generic-incomplete": "ui-serif|ui-sans-serif|ui-monospace|ui-rounded",
    "-non-standard-generic-family": "-apple-system|BlinkMacSystemFont",
    "left": "<length>|auto",
    "color-base": "<hex-color>|<color-function>|<named-color>|<color-mix()>|transparent",
    "color-function": "<rgb()>|<rgba()>|<hsl()>|<hsla()>|<hwb()>|<lab()>|<lch()>|<oklab()>|<oklch()>|<color()>",
    "device-cmyk()": "<legacy-device-cmyk-syntax>|<modern-device-cmyk-syntax>",
    "legacy-device-cmyk-syntax": "device-cmyk( <number>#{4} )",
    "modern-device-cmyk-syntax": "device-cmyk( <cmyk-component>{4} [/ [<alpha-value>|none]]? )",
    "cmyk-component": "<number>|<percentage>|none",
    "color-mix()": "color-mix( <color-interpolation-method> , [<color>&&<percentage [0,100]>?]#{2} )",
    "color-space": "<rectangular-color-space>|<polar-color-space>|<custom-color-space>",
    "custom-color-space": "<dashed-ident>",
    "paint": "none|<color>|<url> [none|<color>]?|context-fill|context-stroke",
    "palette-identifier": "<dashed-ident>",
    "right": "<length>|auto",
    "scope-start": "<forgiving-selector-list>",
    "scope-end": "<forgiving-selector-list>",
    "forgiving-selector-list": "<complex-real-selector-list>",
    "forgiving-relative-selector-list": "<relative-real-selector-list>",
    "selector-list": "<complex-selector-list>",
    "complex-real-selector-list": "<complex-real-selector>#",
    "simple-selector-list": "<simple-selector>#",
    "relative-real-selector-list": "<relative-real-selector>#",
    "complex-selector-unit": "[<compound-selector>? <pseudo-compound-selector>*]!",
    "complex-real-selector": "<compound-selector> [<combinator>? <compound-selector>]*",
    "relative-real-selector": "<combinator>? <complex-real-selector>",
    "pseudo-compound-selector": "<pseudo-element-selector> <pseudo-class-selector>*",
    "simple-selector": "<type-selector>|<subclass-selector>",
    "legacy-pseudo-element-selector": "':' [before|after|first-line|first-letter]",
    "single-animation-composition": "replace|add|accumulate",
    "svg-length": "<percentage>|<length>|<number>",
    "svg-writing-mode": "lr-tb|rl-tb|tb-rl|lr|rl|tb",
    "top": "<length>|auto",
    "x": "<number>",
    "y": "<number>",
    "declaration": "<ident-token> : <declaration-value>? ['!' important]?",
    "declaration-list": "[<declaration>? ';']* <declaration>?",
    "url": "url( <string> <url-modifier>* )|<url-token>",
    "url-modifier": "<ident>|<function-token> <any-value> )",
    "number-zero-one": "<number [0,1]>",
    "number-one-or-greater": "<number [1,∞]>",
    "color()": "color( <colorspace-params> [/ [<alpha-value>|none]]? )",
    "colorspace-params": "[<predefined-rgb-params>|<xyz-params>]",
    "predefined-rgb-params": "<predefined-rgb> [<number>|<percentage>|none]{3}",
    "predefined-rgb": "srgb|srgb-linear|display-p3|a98-rgb|prophoto-rgb|rec2020",
    "xyz-params": "<xyz-space> [<number>|<percentage>|none]{3}",
    "xyz-space": "xyz|xyz-d50|xyz-d65",
    "oklab()": "oklab( [<percentage>|<number>|none] [<percentage>|<number>|none] [<percentage>|<number>|none] [/ [<alpha-value>|none]]? )",
    "oklch()": "oklch( [<percentage>|<number>|none] [<percentage>|<number>|none] [<hue>|none] [/ [<alpha-value>|none]]? )",
    "offset-path": "<ray()>|<url>|<basic-shape>",
    "rect()": "rect( [<length-percentage>|auto]{4} [round <'border-radius'>]? )",
    "xywh()": "xywh( <length-percentage>{2} <length-percentage [0,∞]>{2} [round <'border-radius'>]? )",
    "query-in-parens": "( <container-condition> )|( <size-feature> )|style( <style-query> )|<general-enclosed>",
    "size-feature": "<mf-plain>|<mf-boolean>|<mf-range>",
    "style-feature": "<declaration>",
    "style-query": "<style-condition>|<style-feature>",
    "style-condition": "not <style-in-parens>|<style-in-parens> [[and <style-in-parens>]*|[or <style-in-parens>]*]",
    "style-in-parens": "( <style-condition> )|( <style-feature> )|<general-enclosed>",
    "-non-standard-display": "-ms-inline-flexbox|-ms-grid|-ms-inline-grid|-webkit-flex|-webkit-inline-flex|-webkit-box|-webkit-inline-box|-moz-inline-stack|-moz-box|-moz-inline-box",
    "inset-area": "[[left|center|right|span-left|span-right|x-start|x-end|span-x-start|span-x-end|x-self-start|x-self-end|span-x-self-start|span-x-self-end|span-all]||[top|center|bottom|span-top|span-bottom|y-start|y-end|span-y-start|span-y-end|y-self-start|y-self-end|span-y-self-start|span-y-self-end|span-all]|[block-start|center|block-end|span-block-start|span-block-end|span-all]||[inline-start|center|inline-end|span-inline-start|span-inline-end|span-all]|[self-block-start|self-block-end|span-self-block-start|span-self-block-end|span-all]||[self-inline-start|self-inline-end|span-self-inline-start|span-self-inline-end|span-all]|[start|center|end|span-start|span-end|span-all]{1,2}|[self-start|center|self-end|span-self-start|span-self-end|span-all]{1,2}]",
    "position-area": "[[left|center|right|span-left|span-right|x-start|x-end|span-x-start|span-x-end|x-self-start|x-self-end|span-x-self-start|span-x-self-end|span-all]||[top|center|bottom|span-top|span-bottom|y-start|y-end|span-y-start|span-y-end|y-self-start|y-self-end|span-y-self-start|span-y-self-end|span-all]|[block-start|center|block-end|span-block-start|span-block-end|span-all]||[inline-start|center|inline-end|span-inline-start|span-inline-end|span-all]|[self-block-start|center|self-block-end|span-self-block-start|span-self-block-end|span-all]||[self-inline-start|center|self-inline-end|span-self-inline-start|span-self-inline-end|span-all]|[start|center|end|span-start|span-end|span-all]{1,2}|[self-start|center|self-end|span-self-start|span-self-end|span-all]{1,2}]",
    "anchor()": "anchor( <anchor-element>?&&<anchor-side> , <length-percentage>? )",
    "anchor-side": "inside|outside|top|left|right|bottom|start|end|self-start|self-end|<percentage>|center",
    "anchor-size()": "anchor-size( [<anchor-element>||<anchor-size>]? , <length-percentage>? )",
    "anchor-size": "width|height|block|inline|self-block|self-inline",
    "anchor-element": "<dashed-ident>",
    "try-size": "most-width|most-height|most-block-size|most-inline-size",
    "try-tactic": "flip-block||flip-inline||flip-start",
    "font-variant-css2": "normal|small-caps",
    "font-width-css3": "normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded",
    "system-family-name": "caption|icon|menu|message-box|small-caption|status-bar"
  },
  "properties": {
    "--*": "<declaration-value>",
    "-ms-accelerator": "false|true",
    "-ms-block-progression": "tb|rl|bt|lr",
    "-ms-content-zoom-chaining": "none|chained",
    "-ms-content-zooming": "none|zoom",
    "-ms-content-zoom-limit": "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
    "-ms-content-zoom-limit-max": "<percentage>",
    "-ms-content-zoom-limit-min": "<percentage>",
    "-ms-content-zoom-snap": "<'-ms-content-zoom-snap-type'>||<'-ms-content-zoom-snap-points'>",
    "-ms-content-zoom-snap-points": "snapInterval( <percentage> , <percentage> )|snapList( <percentage># )",
    "-ms-content-zoom-snap-type": "none|proximity|mandatory",
    "-ms-filter": "<string>",
    "-ms-flow-from": "[none|<custom-ident>]#",
    "-ms-flow-into": "[none|<custom-ident>]#",
    "-ms-grid-columns": "none|<track-list>|<auto-track-list>",
    "-ms-grid-rows": "none|<track-list>|<auto-track-list>",
    "-ms-high-contrast-adjust": "auto|none",
    "-ms-hyphenate-limit-chars": "auto|<integer>{1,3}",
    "-ms-hyphenate-limit-lines": "no-limit|<integer>",
    "-ms-hyphenate-limit-zone": "<percentage>|<length>",
    "-ms-ime-align": "auto|after",
    "-ms-overflow-style": "auto|none|scrollbar|-ms-autohiding-scrollbar",
    "-ms-scrollbar-3dlight-color": "<color>",
    "-ms-scrollbar-arrow-color": "<color>",
    "-ms-scrollbar-base-color": "<color>",
    "-ms-scrollbar-darkshadow-color": "<color>",
    "-ms-scrollbar-face-color": "<color>",
    "-ms-scrollbar-highlight-color": "<color>",
    "-ms-scrollbar-shadow-color": "<color>",
    "-ms-scrollbar-track-color": "<color>",
    "-ms-scroll-chaining": "chained|none",
    "-ms-scroll-limit": "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
    "-ms-scroll-limit-x-max": "auto|<length>",
    "-ms-scroll-limit-x-min": "<length>",
    "-ms-scroll-limit-y-max": "auto|<length>",
    "-ms-scroll-limit-y-min": "<length>",
    "-ms-scroll-rails": "none|railed",
    "-ms-scroll-snap-points-x": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )",
    "-ms-scroll-snap-points-y": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )",
    "-ms-scroll-snap-type": "none|proximity|mandatory",
    "-ms-scroll-snap-x": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
    "-ms-scroll-snap-y": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
    "-ms-scroll-translation": "none|vertical-to-horizontal",
    "-ms-text-autospace": "none|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space",
    "-ms-touch-select": "grippers|none",
    "-ms-user-select": "none|element|text",
    "-ms-wrap-flow": "auto|both|start|end|maximum|clear",
    "-ms-wrap-margin": "<length>",
    "-ms-wrap-through": "wrap|none",
    "-moz-appearance": "none|button|button-arrow-down|button-arrow-next|button-arrow-previous|button-arrow-up|button-bevel|button-focus|caret|checkbox|checkbox-container|checkbox-label|checkmenuitem|dualbutton|groupbox|listbox|listitem|menuarrow|menubar|menucheckbox|menuimage|menuitem|menuitemtext|menulist|menulist-button|menulist-text|menulist-textfield|menupopup|menuradio|menuseparator|meterbar|meterchunk|progressbar|progressbar-vertical|progresschunk|progresschunk-vertical|radio|radio-container|radio-label|radiomenuitem|range|range-thumb|resizer|resizerpanel|scale-horizontal|scalethumbend|scalethumb-horizontal|scalethumbstart|scalethumbtick|scalethumb-vertical|scale-vertical|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|separator|sheet|spinner|spinner-downbutton|spinner-textfield|spinner-upbutton|splitter|statusbar|statusbarpanel|tab|tabpanel|tabpanels|tab-scroll-arrow-back|tab-scroll-arrow-forward|textfield|textfield-multiline|toolbar|toolbarbutton|toolbarbutton-dropdown|toolbargripper|toolbox|tooltip|treeheader|treeheadercell|treeheadersortarrow|treeitem|treeline|treetwisty|treetwistyopen|treeview|-moz-mac-unified-toolbar|-moz-win-borderless-glass|-moz-win-browsertabbar-toolbox|-moz-win-communicationstext|-moz-win-communications-toolbox|-moz-win-exclude-glass|-moz-win-glass|-moz-win-mediatext|-moz-win-media-toolbox|-moz-window-button-box|-moz-window-button-box-maximized|-moz-window-button-close|-moz-window-button-maximize|-moz-window-button-minimize|-moz-window-button-restore|-moz-window-frame-bottom|-moz-window-frame-left|-moz-window-frame-right|-moz-window-titlebar|-moz-window-titlebar-maximized",
    "-moz-binding": "<url>|none",
    "-moz-border-bottom-colors": "<color>+|none",
    "-moz-border-left-colors": "<color>+|none",
    "-moz-border-right-colors": "<color>+|none",
    "-moz-border-top-colors": "<color>+|none",
    "-moz-context-properties": "none|[fill|fill-opacity|stroke|stroke-opacity]#",
    "-moz-float-edge": "border-box|content-box|margin-box|padding-box",
    "-moz-force-broken-image-icon": "0|1",
    "-moz-image-region": "<shape>|auto",
    "-moz-orient": "inline|block|horizontal|vertical",
    "-moz-outline-radius": "<outline-radius>{1,4} [/ <outline-radius>{1,4}]?",
    "-moz-outline-radius-bottomleft": "<outline-radius>",
    "-moz-outline-radius-bottomright": "<outline-radius>",
    "-moz-outline-radius-topleft": "<outline-radius>",
    "-moz-outline-radius-topright": "<outline-radius>",
    "-moz-stack-sizing": "ignore|stretch-to-fit",
    "-moz-text-blink": "none|blink",
    "-moz-user-focus": "ignore|normal|select-after|select-before|select-menu|select-same|select-all|none",
    "-moz-user-input": "auto|none|enabled|disabled",
    "-moz-user-modify": "read-only|read-write|write-only",
    "-moz-window-dragging": "drag|no-drag",
    "-moz-window-shadow": "default|menu|tooltip|sheet|none",
    "-webkit-appearance": "none|button|button-bevel|caps-lock-indicator|caret|checkbox|default-button|inner-spin-button|listbox|listitem|media-controls-background|media-controls-fullscreen-background|media-current-time-display|media-enter-fullscreen-button|media-exit-fullscreen-button|media-fullscreen-button|media-mute-button|media-overlay-play-button|media-play-button|media-seek-back-button|media-seek-forward-button|media-slider|media-sliderthumb|media-time-remaining-display|media-toggle-closed-captions-button|media-volume-slider|media-volume-slider-container|media-volume-sliderthumb|menulist|menulist-button|menulist-text|menulist-textfield|meter|progress-bar|progress-bar-value|push-button|radio|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbargripper-horizontal|scrollbargripper-vertical|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|searchfield-cancel-button|searchfield-decoration|searchfield-results-button|searchfield-results-decoration|slider-horizontal|slider-vertical|sliderthumb-horizontal|sliderthumb-vertical|square-button|textarea|textfield|-apple-pay-button",
    "-webkit-border-before": "<'border-width'>||<'border-style'>||<color>",
    "-webkit-border-before-color": "<color>",
    "-webkit-border-before-style": "<'border-style'>",
    "-webkit-border-before-width": "<'border-width'>",
    "-webkit-box-reflect": "[above|below|right|left]? <length>? <image>?",
    "-webkit-line-clamp": "none|<integer>",
    "-webkit-mask": "[<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||[<box>|border|padding|content|text]||[<box>|border|padding|content]]#",
    "-webkit-mask-attachment": "<attachment>#",
    "-webkit-mask-clip": "[<box>|border|padding|content|text]#",
    "-webkit-mask-composite": "<composite-style>#",
    "-webkit-mask-image": "<mask-reference>#",
    "-webkit-mask-origin": "[<box>|border|padding|content]#",
    "-webkit-mask-position": "<position>#",
    "-webkit-mask-position-x": "[<length-percentage>|left|center|right]#",
    "-webkit-mask-position-y": "[<length-percentage>|top|center|bottom]#",
    "-webkit-mask-repeat": "<repeat-style>#",
    "-webkit-mask-repeat-x": "repeat|no-repeat|space|round",
    "-webkit-mask-repeat-y": "repeat|no-repeat|space|round",
    "-webkit-mask-size": "<bg-size>#",
    "-webkit-overflow-scrolling": "auto|touch",
    "-webkit-tap-highlight-color": "<color>",
    "-webkit-text-fill-color": "<color>",
    "-webkit-text-stroke": "<length>||<color>",
    "-webkit-text-stroke-color": "<color>",
    "-webkit-text-stroke-width": "<length>",
    "-webkit-touch-callout": "default|none",
    "-webkit-user-modify": "read-only|read-write|read-write-plaintext-only",
    "accent-color": "auto|<color>",
    "align-content": "normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>",
    "align-items": "normal|stretch|<baseline-position>|[<overflow-position>? <self-position>]",
    "align-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? <self-position>",
    "align-tracks": "[normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>]#",
    "all": "initial|inherit|unset|revert|revert-layer",
    "anchor-name": "none|<dashed-ident>#",
    "anchor-scope": "none|all|<dashed-ident>#",
    "animation": "<single-animation>#",
    "animation-composition": "<single-animation-composition>#",
    "animation-delay": "<time>#",
    "animation-direction": "<single-animation-direction>#",
    "animation-duration": "<time>#",
    "animation-fill-mode": "<single-animation-fill-mode>#",
    "animation-iteration-count": "<single-animation-iteration-count>#",
    "animation-name": "[none|<keyframes-name>]#",
    "animation-play-state": "<single-animation-play-state>#",
    "animation-range": "[<'animation-range-start'> <'animation-range-end'>?]#",
    "animation-range-end": "[normal|<length-percentage>|<timeline-range-name> <length-percentage>?]#",
    "animation-range-start": "[normal|<length-percentage>|<timeline-range-name> <length-percentage>?]#",
    "animation-timing-function": "<easing-function>#",
    "animation-timeline": "<single-animation-timeline>#",
    "appearance": "none|auto|textfield|menulist-button|<compat-auto>",
    "aspect-ratio": "auto||<ratio>",
    "azimuth": "<angle>|[[left-side|far-left|left|center-left|center|center-right|right|far-right|right-side]||behind]|leftwards|rightwards",
    "backdrop-filter": "none|<filter-function-list>",
    "backface-visibility": "visible|hidden",
    "background": "[<bg-layer> ,]* <final-bg-layer>",
    "background-attachment": "<attachment>#",
    "background-blend-mode": "<blend-mode>#",
    "background-clip": "<bg-clip>#",
    "background-color": "<color>",
    "background-image": "<bg-image>#",
    "background-origin": "<box>#",
    "background-position": "<bg-position>#",
    "background-position-x": "[center|[[left|right|x-start|x-end]? <length-percentage>?]!]#",
    "background-position-y": "[center|[[top|bottom|y-start|y-end]? <length-percentage>?]!]#",
    "background-repeat": "<repeat-style>#",
    "background-size": "<bg-size>#",
    "block-size": "<'width'>",
    "border": "<line-width>||<line-style>||<color>",
    "border-block": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-block-color": "<'border-top-color'>{1,2}",
    "border-block-style": "<'border-top-style'>",
    "border-block-width": "<'border-top-width'>",
    "border-block-end": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-block-end-color": "<'border-top-color'>",
    "border-block-end-style": "<'border-top-style'>",
    "border-block-end-width": "<'border-top-width'>",
    "border-block-start": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-block-start-color": "<'border-top-color'>",
    "border-block-start-style": "<'border-top-style'>",
    "border-block-start-width": "<'border-top-width'>",
    "border-bottom": "<line-width>||<line-style>||<color>",
    "border-bottom-color": "<'border-top-color'>",
    "border-bottom-left-radius": "<length-percentage>{1,2}",
    "border-bottom-right-radius": "<length-percentage>{1,2}",
    "border-bottom-style": "<line-style>",
    "border-bottom-width": "<line-width>",
    "border-collapse": "collapse|separate",
    "border-color": "<color>{1,4}",
    "border-end-end-radius": "<length-percentage>{1,2}",
    "border-end-start-radius": "<length-percentage>{1,2}",
    "border-image": "<'border-image-source'>||<'border-image-slice'> [/ <'border-image-width'>|/ <'border-image-width'>? / <'border-image-outset'>]?||<'border-image-repeat'>",
    "border-image-outset": "[<length>|<number>]{1,4}",
    "border-image-repeat": "[stretch|repeat|round|space]{1,2}",
    "border-image-slice": "<number-percentage>{1,4}&&fill?",
    "border-image-source": "none|<image>",
    "border-image-width": "[<length-percentage>|<number>|auto]{1,4}",
    "border-inline": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-inline-end": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-inline-color": "<'border-top-color'>{1,2}",
    "border-inline-style": "<'border-top-style'>",
    "border-inline-width": "<'border-top-width'>",
    "border-inline-end-color": "<'border-top-color'>",
    "border-inline-end-style": "<'border-top-style'>",
    "border-inline-end-width": "<'border-top-width'>",
    "border-inline-start": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-inline-start-color": "<'border-top-color'>",
    "border-inline-start-style": "<'border-top-style'>",
    "border-inline-start-width": "<'border-top-width'>",
    "border-left": "<line-width>||<line-style>||<color>",
    "border-left-color": "<color>",
    "border-left-style": "<line-style>",
    "border-left-width": "<line-width>",
    "border-radius": "<length-percentage>{1,4} [/ <length-percentage>{1,4}]?",
    "border-right": "<line-width>||<line-style>||<color>",
    "border-right-color": "<color>",
    "border-right-style": "<line-style>",
    "border-right-width": "<line-width>",
    "border-spacing": "<length> <length>?",
    "border-start-end-radius": "<length-percentage>{1,2}",
    "border-start-start-radius": "<length-percentage>{1,2}",
    "border-style": "<line-style>{1,4}",
    "border-top": "<line-width>||<line-style>||<color>",
    "border-top-color": "<color>",
    "border-top-left-radius": "<length-percentage>{1,2}",
    "border-top-right-radius": "<length-percentage>{1,2}",
    "border-top-style": "<line-style>",
    "border-top-width": "<line-width>",
    "border-width": "<line-width>{1,4}",
    "bottom": "<length>|<percentage>|auto",
    "box-align": "start|center|end|baseline|stretch",
    "box-decoration-break": "slice|clone",
    "box-direction": "normal|reverse|inherit",
    "box-flex": "<number>",
    "box-flex-group": "<integer>",
    "box-lines": "single|multiple",
    "box-ordinal-group": "<integer>",
    "box-orient": "horizontal|vertical|inline-axis|block-axis|inherit",
    "box-pack": "start|center|end|justify",
    "box-shadow": "none|<shadow>#",
    "box-sizing": "content-box|border-box",
    "break-after": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region",
    "break-before": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region",
    "break-inside": "auto|avoid|avoid-page|avoid-column|avoid-region",
    "caption-side": "top|bottom|block-start|block-end|inline-start|inline-end",
    "caret": "<'caret-color'>||<'caret-shape'>",
    "caret-color": "auto|<color>",
    "caret-shape": "auto|bar|block|underscore",
    "clear": "none|left|right|both|inline-start|inline-end",
    "clip": "<shape>|auto",
    "clip-path": "<clip-source>|[<basic-shape>||<geometry-box>]|none",
    "clip-rule": "nonzero|evenodd",
    "color": "<color>",
    "color-interpolation-filters": "auto|sRGB|linearRGB",
    "color-scheme": "normal|[light|dark|<custom-ident>]+&&only?",
    "column-count": "<integer>|auto",
    "column-fill": "auto|balance",
    "column-gap": "normal|<length-percentage>",
    "column-rule": "<'column-rule-width'>||<'column-rule-style'>||<'column-rule-color'>",
    "column-rule-color": "<color>",
    "column-rule-style": "<'border-style'>",
    "column-rule-width": "<'border-width'>",
    "column-span": "none|all",
    "column-width": "<length>|auto",
    "columns": "<'column-width'>||<'column-count'>",
    "contain": "none|strict|content|[[size||inline-size]||layout||style||paint]",
    "contain-intrinsic-size": "[auto? [none|<length>]]{1,2}",
    "contain-intrinsic-block-size": "auto? [none|<length>]",
    "contain-intrinsic-height": "auto? [none|<length>]",
    "contain-intrinsic-inline-size": "auto? [none|<length>]",
    "contain-intrinsic-width": "auto? [none|<length>]",
    "container": "<'container-name'> [/ <'container-type'>]?",
    "container-name": "none|<custom-ident>+",
    "container-type": "normal||[size|inline-size]",
    "content": "normal|none|[<content-replacement>|<content-list>] [/ [<string>|<counter>]+]?",
    "content-visibility": "visible|auto|hidden",
    "counter-increment": "[<counter-name> <integer>?]+|none",
    "counter-reset": "[<counter-name> <integer>?|<reversed-counter-name> <integer>?]+|none",
    "counter-set": "[<counter-name> <integer>?]+|none",
    "cursor": "[[<url> [<x> <y>]? ,]* [auto|default|none|context-menu|help|pointer|progress|wait|cell|crosshair|text|vertical-text|alias|copy|move|no-drop|not-allowed|e-resize|n-resize|ne-resize|nw-resize|s-resize|se-resize|sw-resize|w-resize|ew-resize|ns-resize|nesw-resize|nwse-resize|col-resize|row-resize|all-scroll|zoom-in|zoom-out|grab|grabbing|hand|-webkit-grab|-webkit-grabbing|-webkit-zoom-in|-webkit-zoom-out|-moz-grab|-moz-grabbing|-moz-zoom-in|-moz-zoom-out]]",
    "d": "none|path( <string> )",
    "cx": "<length>|<percentage>",
    "cy": "<length>|<percentage>",
    "direction": "ltr|rtl",
    "display": "[<display-outside>||<display-inside>]|<display-listitem>|<display-internal>|<display-box>|<display-legacy>|<-non-standard-display>",
    "dominant-baseline": "auto|use-script|no-change|reset-size|ideographic|alphabetic|hanging|mathematical|central|middle|text-after-edge|text-before-edge",
    "empty-cells": "show|hide",
    "field-sizing": "content|fixed",
    "fill": "<paint>",
    "fill-opacity": "<number-zero-one>",
    "fill-rule": "nonzero|evenodd",
    "filter": "none|<filter-function-list>|<-ms-filter-function-list>",
    "flex": "none|[<'flex-grow'> <'flex-shrink'>?||<'flex-basis'>]",
    "flex-basis": "content|<'width'>",
    "flex-direction": "row|row-reverse|column|column-reverse",
    "flex-flow": "<'flex-direction'>||<'flex-wrap'>",
    "flex-grow": "<number>",
    "flex-shrink": "<number>",
    "flex-wrap": "nowrap|wrap|wrap-reverse",
    "float": "left|right|none|inline-start|inline-end",
    "font": "[[<'font-style'>||<font-variant-css2>||<'font-weight'>||<font-width-css3>]? <'font-size'> [/ <'line-height'>]? <'font-family'>#]|<system-family-name>|<-non-standard-font>",
    "font-family": "[<family-name>|<generic-family>]#",
    "font-feature-settings": "normal|<feature-tag-value>#",
    "font-kerning": "auto|normal|none",
    "font-language-override": "normal|<string>",
    "font-optical-sizing": "auto|none",
    "font-palette": "normal|light|dark|<palette-identifier>",
    "font-variation-settings": "normal|[<string> <number>]#",
    "font-size": "<absolute-size>|<relative-size>|<length-percentage>",
    "font-size-adjust": "none|[ex-height|cap-height|ch-width|ic-width|ic-height]? [from-font|<number>]",
    "font-smooth": "auto|never|always|<absolute-size>|<length>",
    "font-stretch": "<font-stretch-absolute>",
    "font-style": "normal|italic|oblique <angle>?",
    "font-synthesis": "none|[weight||style||small-caps||position]",
    "font-synthesis-position": "auto|none",
    "font-synthesis-small-caps": "auto|none",
    "font-synthesis-style": "auto|none",
    "font-synthesis-weight": "auto|none",
    "font-variant": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>||stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )||[small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps]||<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero||<east-asian-variant-values>||<east-asian-width-values>||ruby]",
    "font-variant-alternates": "normal|[stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )]",
    "font-variant-caps": "normal|small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps",
    "font-variant-east-asian": "normal|[<east-asian-variant-values>||<east-asian-width-values>||ruby]",
    "font-variant-emoji": "normal|text|emoji|unicode",
    "font-variant-ligatures": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>]",
    "font-variant-numeric": "normal|[<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero]",
    "font-variant-position": "normal|sub|super",
    "font-weight": "<font-weight-absolute>|bolder|lighter",
    "forced-color-adjust": "auto|none|preserve-parent-color",
    "gap": "<'row-gap'> <'column-gap'>?",
    "grid": "<'grid-template'>|<'grid-template-rows'> / [auto-flow&&dense?] <'grid-auto-columns'>?|[auto-flow&&dense?] <'grid-auto-rows'>? / <'grid-template-columns'>",
    "grid-area": "<grid-line> [/ <grid-line>]{0,3}",
    "grid-auto-columns": "<track-size>+",
    "grid-auto-flow": "[row|column]||dense",
    "grid-auto-rows": "<track-size>+",
    "grid-column": "<grid-line> [/ <grid-line>]?",
    "grid-column-end": "<grid-line>",
    "grid-column-gap": "<length-percentage>",
    "grid-column-start": "<grid-line>",
    "grid-gap": "<'grid-row-gap'> <'grid-column-gap'>?",
    "grid-row": "<grid-line> [/ <grid-line>]?",
    "grid-row-end": "<grid-line>",
    "grid-row-gap": "<length-percentage>",
    "grid-row-start": "<grid-line>",
    "grid-template": "none|[<'grid-template-rows'> / <'grid-template-columns'>]|[<line-names>? <string> <track-size>? <line-names>?]+ [/ <explicit-track-list>]?",
    "grid-template-areas": "none|<string>+",
    "grid-template-columns": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?",
    "grid-template-rows": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?",
    "hanging-punctuation": "none|[first||[force-end|allow-end]||last]",
    "height": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
    "hyphenate-character": "auto|<string>",
    "hyphenate-limit-chars": "[auto|<integer>]{1,3}",
    "hyphens": "none|manual|auto",
    "image-orientation": "from-image|<angle>|[<angle>? flip]",
    "image-rendering": "auto|crisp-edges|pixelated|optimizeSpeed|optimizeQuality|<-non-standard-image-rendering>",
    "image-resolution": "[from-image||<resolution>]&&snap?",
    "ime-mode": "auto|normal|active|inactive|disabled",
    "initial-letter": "normal|[<number> <integer>?]",
    "initial-letter-align": "[auto|alphabetic|hanging|ideographic]",
    "inline-size": "<'width'>",
    "input-security": "auto|none",
    "inset": "<'top'>{1,4}",
    "inset-block": "<'top'>{1,2}",
    "inset-block-end": "<'top'>",
    "inset-block-start": "<'top'>",
    "inset-inline": "<'top'>{1,2}",
    "inset-inline-end": "<'top'>",
    "inset-inline-start": "<'top'>",
    "interpolate-size": "numeric-only|allow-keywords",
    "isolation": "auto|isolate",
    "justify-content": "normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]",
    "justify-items": "normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]|legacy|legacy&&[left|right|center]",
    "justify-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]",
    "justify-tracks": "[normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]]#",
    "left": "<length>|<percentage>|auto",
    "letter-spacing": "normal|<length-percentage>",
    "line-break": "auto|loose|normal|strict|anywhere",
    "line-clamp": "none|<integer>",
    "line-height": "normal|<number>|<length>|<percentage>",
    "line-height-step": "<length>",
    "list-style": "<'list-style-type'>||<'list-style-position'>||<'list-style-image'>",
    "list-style-image": "<image>|none",
    "list-style-position": "inside|outside",
    "list-style-type": "<counter-style>|<string>|none",
    "margin": "[<length>|<percentage>|auto]{1,4}",
    "margin-block": "<'margin-left'>{1,2}",
    "margin-block-end": "<'margin-left'>",
    "margin-block-start": "<'margin-left'>",
    "margin-bottom": "<length>|<percentage>|auto",
    "margin-inline": "<'margin-left'>{1,2}",
    "margin-inline-end": "<'margin-left'>",
    "margin-inline-start": "<'margin-left'>",
    "margin-left": "<length>|<percentage>|auto",
    "margin-right": "<length>|<percentage>|auto",
    "margin-top": "<length>|<percentage>|auto",
    "margin-trim": "none|in-flow|all",
    "marker": "none|<url>",
    "marker-end": "none|<url>",
    "marker-mid": "none|<url>",
    "marker-start": "none|<url>",
    "mask": "<mask-layer>#",
    "mask-border": "<'mask-border-source'>||<'mask-border-slice'> [/ <'mask-border-width'>? [/ <'mask-border-outset'>]?]?||<'mask-border-repeat'>||<'mask-border-mode'>",
    "mask-border-mode": "luminance|alpha",
    "mask-border-outset": "[<length>|<number>]{1,4}",
    "mask-border-repeat": "[stretch|repeat|round|space]{1,2}",
    "mask-border-slice": "<number-percentage>{1,4} fill?",
    "mask-border-source": "none|<image>",
    "mask-border-width": "[<length-percentage>|<number>|auto]{1,4}",
    "mask-clip": "[<geometry-box>|no-clip]#",
    "mask-composite": "<compositing-operator>#",
    "mask-image": "<mask-reference>#",
    "mask-mode": "<masking-mode>#",
    "mask-origin": "<geometry-box>#",
    "mask-position": "<position>#",
    "mask-repeat": "<repeat-style>#",
    "mask-size": "<bg-size>#",
    "mask-type": "luminance|alpha",
    "masonry-auto-flow": "[pack|next]||[definite-first|ordered]",
    "math-depth": "auto-add|add( <integer> )|<integer>",
    "math-shift": "normal|compact",
    "math-style": "normal|compact",
    "max-block-size": "<'max-width'>",
    "max-height": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
    "max-inline-size": "<'max-width'>",
    "max-lines": "none|<integer>",
    "max-width": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
    "min-block-size": "<'min-width'>",
    "min-height": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
    "min-inline-size": "<'min-width'>",
    "min-width": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
    "mix-blend-mode": "<blend-mode>|plus-lighter",
    "object-fit": "fill|contain|cover|none|scale-down",
    "object-position": "<position>",
    "offset": "[<'offset-position'>? [<'offset-path'> [<'offset-distance'>||<'offset-rotate'>]?]?]! [/ <'offset-anchor'>]?",
    "offset-anchor": "auto|<position>",
    "offset-distance": "<length-percentage>",
    "offset-path": "none|<offset-path>||<coord-box>",
    "offset-position": "normal|auto|<position>",
    "offset-rotate": "[auto|reverse]||<angle>",
    "opacity": "<alpha-value>",
    "order": "<integer>",
    "orphans": "<integer>",
    "outline": "[<'outline-width'>||<'outline-style'>||<'outline-color'>]",
    "outline-color": "auto|<color>",
    "outline-offset": "<length>",
    "outline-style": "auto|<'border-style'>",
    "outline-width": "<line-width>",
    "overflow": "[visible|hidden|clip|scroll|auto]{1,2}|<-non-standard-overflow>",
    "overflow-anchor": "auto|none",
    "overflow-block": "visible|hidden|clip|scroll|auto",
    "overflow-clip-box": "padding-box|content-box",
    "overflow-clip-margin": "<visual-box>||<length [0,∞]>",
    "overflow-inline": "visible|hidden|clip|scroll|auto",
    "overflow-wrap": "normal|break-word|anywhere",
    "overflow-x": "visible|hidden|clip|scroll|auto",
    "overflow-y": "visible|hidden|clip|scroll|auto",
    "overlay": "none|auto",
    "overscroll-behavior": "[contain|none|auto]{1,2}",
    "overscroll-behavior-block": "contain|none|auto",
    "overscroll-behavior-inline": "contain|none|auto",
    "overscroll-behavior-x": "contain|none|auto",
    "overscroll-behavior-y": "contain|none|auto",
    "padding": "[<length>|<percentage>]{1,4}",
    "padding-block": "<'padding-left'>{1,2}",
    "padding-block-end": "<'padding-left'>",
    "padding-block-start": "<'padding-left'>",
    "padding-bottom": "<length>|<percentage>",
    "padding-inline": "<'padding-left'>{1,2}",
    "padding-inline-end": "<'padding-left'>",
    "padding-inline-start": "<'padding-left'>",
    "padding-left": "<length>|<percentage>",
    "padding-right": "<length>|<percentage>",
    "padding-top": "<length>|<percentage>",
    "page": "auto|<custom-ident>",
    "page-break-after": "auto|always|avoid|left|right|recto|verso",
    "page-break-before": "auto|always|avoid|left|right|recto|verso",
    "page-break-inside": "auto|avoid",
    "paint-order": "normal|[fill||stroke||markers]",
    "perspective": "none|<length>",
    "perspective-origin": "<position>",
    "place-content": "<'align-content'> <'justify-content'>?",
    "place-items": "<'align-items'> <'justify-items'>?",
    "place-self": "<'align-self'> <'justify-self'>?",
    "pointer-events": "auto|none|visiblePainted|visibleFill|visibleStroke|visible|painted|fill|stroke|all|inherit",
    "position": "static|relative|absolute|sticky|fixed|-webkit-sticky",
    "position-anchor": "auto|<anchor-name>",
    "position-area": "none|<position-area>",
    "position-try": "<'position-try-order'>? <'position-try-fallbacks'>",
    "position-try-fallbacks": "none|[[<dashed-ident>||<try-tactic>]|<'position-area'>]#",
    "position-try-order": "normal|<try-size>",
    "position-visibility": "always|[anchors-valid||anchors-visible||no-overflow]",
    "print-color-adjust": "economy|exact",
    "quotes": "none|auto|[<string> <string>]+",
    "r": "<length>|<percentage>",
    "resize": "none|both|horizontal|vertical|block|inline",
    "right": "<length>|<percentage>|auto",
    "rotate": "none|<angle>|[x|y|z|<number>{3}]&&<angle>",
    "row-gap": "normal|<length-percentage>",
    "ruby-align": "start|center|space-between|space-around",
    "ruby-merge": "separate|collapse|auto",
    "ruby-position": "[alternate||[over|under]]|inter-character",
    "rx": "<length>|<percentage>",
    "ry": "<length>|<percentage>",
    "scale": "none|[<number>|<percentage>]{1,3}",
    "scrollbar-color": "auto|<color>{2}",
    "scrollbar-gutter": "auto|stable&&both-edges?",
    "scrollbar-width": "auto|thin|none",
    "scroll-behavior": "auto|smooth",
    "scroll-margin": "<length>{1,4}",
    "scroll-margin-block": "<length>{1,2}",
    "scroll-margin-block-start": "<length>",
    "scroll-margin-block-end": "<length>",
    "scroll-margin-bottom": "<length>",
    "scroll-margin-inline": "<length>{1,2}",
    "scroll-margin-inline-start": "<length>",
    "scroll-margin-inline-end": "<length>",
    "scroll-margin-left": "<length>",
    "scroll-margin-right": "<length>",
    "scroll-margin-top": "<length>",
    "scroll-padding": "[auto|<length-percentage>]{1,4}",
    "scroll-padding-block": "[auto|<length-percentage>]{1,2}",
    "scroll-padding-block-start": "auto|<length-percentage>",
    "scroll-padding-block-end": "auto|<length-percentage>",
    "scroll-padding-bottom": "auto|<length-percentage>",
    "scroll-padding-inline": "[auto|<length-percentage>]{1,2}",
    "scroll-padding-inline-start": "auto|<length-percentage>",
    "scroll-padding-inline-end": "auto|<length-percentage>",
    "scroll-padding-left": "auto|<length-percentage>",
    "scroll-padding-right": "auto|<length-percentage>",
    "scroll-padding-top": "auto|<length-percentage>",
    "scroll-snap-align": "[none|start|end|center]{1,2}",
    "scroll-snap-coordinate": "none|<position>#",
    "scroll-snap-destination": "<position>",
    "scroll-snap-points-x": "none|repeat( <length-percentage> )",
    "scroll-snap-points-y": "none|repeat( <length-percentage> )",
    "scroll-snap-stop": "normal|always",
    "scroll-snap-type": "none|[x|y|block|inline|both] [mandatory|proximity]?",
    "scroll-snap-type-x": "none|mandatory|proximity",
    "scroll-snap-type-y": "none|mandatory|proximity",
    "scroll-timeline": "[<'scroll-timeline-name'>||<'scroll-timeline-axis'>]#",
    "scroll-timeline-axis": "[block|inline|x|y]#",
    "scroll-timeline-name": "[none|<dashed-ident>]#",
    "shape-image-threshold": "<alpha-value>",
    "shape-margin": "<length-percentage>",
    "shape-outside": "none|[<shape-box>||<basic-shape>]|<image>",
    "shape-rendering": "auto|optimizeSpeed|crispEdges|geometricPrecision",
    "stroke": "<paint>",
    "stroke-dasharray": "none|[<svg-length>+]#",
    "stroke-dashoffset": "<svg-length>",
    "stroke-linecap": "butt|round|square",
    "stroke-linejoin": "miter|round|bevel",
    "stroke-miterlimit": "<number-one-or-greater>",
    "stroke-opacity": "<'opacity'>",
    "stroke-width": "<svg-length>",
    "tab-size": "<integer>|<length>",
    "table-layout": "auto|fixed",
    "text-align": "start|end|left|right|center|justify|match-parent",
    "text-align-last": "auto|start|end|left|right|center|justify",
    "text-anchor": "start|middle|end",
    "text-combine-upright": "none|all|[digits <integer>?]",
    "text-decoration": "<'text-decoration-line'>||<'text-decoration-style'>||<'text-decoration-color'>||<'text-decoration-thickness'>",
    "text-decoration-color": "<color>",
    "text-decoration-line": "none|[underline||overline||line-through||blink]|spelling-error|grammar-error",
    "text-decoration-skip": "none|[objects||[spaces|[leading-spaces||trailing-spaces]]||edges||box-decoration]",
    "text-decoration-skip-ink": "auto|all|none",
    "text-decoration-style": "solid|double|dotted|dashed|wavy",
    "text-decoration-thickness": "auto|from-font|<length>|<percentage>",
    "text-emphasis": "<'text-emphasis-style'>||<'text-emphasis-color'>",
    "text-emphasis-color": "<color>",
    "text-emphasis-position": "auto|[over|under]&&[right|left]?",
    "text-emphasis-style": "none|[[filled|open]||[dot|circle|double-circle|triangle|sesame]]|<string>",
    "text-indent": "<length-percentage>&&hanging?&&each-line?",
    "text-justify": "auto|inter-character|inter-word|none",
    "text-orientation": "mixed|upright|sideways",
    "text-overflow": "[clip|ellipsis|<string>]{1,2}",
    "text-rendering": "auto|optimizeSpeed|optimizeLegibility|geometricPrecision",
    "text-shadow": "none|<shadow-t>#",
    "text-size-adjust": "none|auto|<percentage>",
    "text-spacing-trim": "space-all|normal|space-first|trim-start|trim-both|trim-all|auto",
    "text-transform": "none|capitalize|uppercase|lowercase|full-width|full-size-kana",
    "text-underline-offset": "auto|<length>|<percentage>",
    "text-underline-position": "auto|from-font|[under||[left|right]]",
    "text-wrap": "<'text-wrap-mode'>||<'text-wrap-style'>",
    "text-wrap-mode": "auto|wrap|nowrap",
    "text-wrap-style": "auto|balance|stable|pretty",
    "timeline-scope": "none|<dashed-ident>#",
    "top": "<length>|<percentage>|auto",
    "touch-action": "auto|none|[[pan-x|pan-left|pan-right]||[pan-y|pan-up|pan-down]||pinch-zoom]|manipulation",
    "transform": "none|<transform-list>",
    "transform-box": "content-box|border-box|fill-box|stroke-box|view-box",
    "transform-origin": "[<length-percentage>|left|center|right|top|bottom]|[[<length-percentage>|left|center|right]&&[<length-percentage>|top|center|bottom]] <length>?",
    "transform-style": "flat|preserve-3d",
    "transition": "<single-transition>#",
    "transition-behavior": "<transition-behavior-value>#",
    "transition-delay": "<time>#",
    "transition-duration": "<time>#",
    "transition-property": "none|<single-transition-property>#",
    "transition-timing-function": "<easing-function>#",
    "translate": "none|<length-percentage> [<length-percentage> <length>?]?",
    "unicode-bidi": "normal|embed|isolate|bidi-override|isolate-override|plaintext|-moz-isolate|-moz-isolate-override|-moz-plaintext|-webkit-isolate|-webkit-isolate-override|-webkit-plaintext",
    "user-select": "auto|text|none|contain|all",
    "vector-effect": "none|non-scaling-stroke|non-scaling-size|non-rotation|fixed-position",
    "vertical-align": "baseline|sub|super|text-top|text-bottom|middle|top|bottom|<percentage>|<length>",
    "view-timeline": "[<'view-timeline-name'> <'view-timeline-axis'>?]#",
    "view-timeline-axis": "[block|inline|x|y]#",
    "view-timeline-inset": "[[auto|<length-percentage>]{1,2}]#",
    "view-timeline-name": "none|<dashed-ident>#",
    "view-transition-name": "none|<custom-ident>",
    "visibility": "visible|hidden|collapse",
    "white-space": "normal|pre|nowrap|pre-wrap|pre-line|break-spaces|[<'white-space-collapse'>||<'text-wrap'>||<'white-space-trim'>]",
    "white-space-collapse": "collapse|discard|preserve|preserve-breaks|preserve-spaces|break-spaces",
    "widows": "<integer>",
    "width": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
    "will-change": "auto|<animateable-feature>#",
    "word-break": "normal|break-all|keep-all|break-word|auto-phrase",
    "word-spacing": "normal|<length>",
    "word-wrap": "normal|break-word",
    "writing-mode": "horizontal-tb|vertical-rl|vertical-lr|sideways-rl|sideways-lr|<svg-writing-mode>",
    "x": "<length>|<percentage>",
    "y": "<length>|<percentage>",
    "z-index": "auto|<integer>",
    "zoom": "normal|reset|<number>|<percentage>",
    "-moz-background-clip": "padding|border",
    "-moz-border-radius-bottomleft": "<'border-bottom-left-radius'>",
    "-moz-border-radius-bottomright": "<'border-bottom-right-radius'>",
    "-moz-border-radius-topleft": "<'border-top-left-radius'>",
    "-moz-border-radius-topright": "<'border-bottom-right-radius'>",
    "-moz-control-character-visibility": "visible|hidden",
    "-moz-osx-font-smoothing": "auto|grayscale",
    "-moz-user-select": "none|text|all|-moz-none",
    "-ms-flex-align": "start|end|center|baseline|stretch",
    "-ms-flex-item-align": "auto|start|end|center|baseline|stretch",
    "-ms-flex-line-pack": "start|end|center|justify|distribute|stretch",
    "-ms-flex-negative": "<'flex-shrink'>",
    "-ms-flex-pack": "start|end|center|justify|distribute",
    "-ms-flex-order": "<integer>",
    "-ms-flex-positive": "<'flex-grow'>",
    "-ms-flex-preferred-size": "<'flex-basis'>",
    "-ms-interpolation-mode": "nearest-neighbor|bicubic",
    "-ms-grid-column-align": "start|end|center|stretch",
    "-ms-grid-row-align": "start|end|center|stretch",
    "-ms-hyphenate-limit-last": "none|always|column|page|spread",
    "-webkit-background-clip": "[<box>|border|padding|content|text]#",
    "-webkit-column-break-after": "always|auto|avoid",
    "-webkit-column-break-before": "always|auto|avoid",
    "-webkit-column-break-inside": "always|auto|avoid",
    "-webkit-font-smoothing": "auto|none|antialiased|subpixel-antialiased",
    "-webkit-mask-box-image": "[<url>|<gradient>|none] [<length-percentage>{4} <-webkit-mask-box-repeat>{2}]?",
    "-webkit-print-color-adjust": "economy|exact",
    "-webkit-text-security": "none|circle|disc|square",
    "-webkit-user-drag": "none|element|auto",
    "-webkit-user-select": "auto|none|text|all",
    "alignment-baseline": "auto|baseline|before-edge|text-before-edge|middle|central|after-edge|text-after-edge|ideographic|alphabetic|hanging|mathematical",
    "baseline-shift": "baseline|sub|super|<svg-length>",
    "behavior": "<url>+",
    "cue": "<'cue-before'> <'cue-after'>?",
    "cue-after": "<url> <decibel>?|none",
    "cue-before": "<url> <decibel>?|none",
    "glyph-orientation-horizontal": "<angle>",
    "glyph-orientation-vertical": "<angle>",
    "kerning": "auto|<svg-length>",
    "pause": "<'pause-before'> <'pause-after'>?",
    "pause-after": "<time>|none|x-weak|weak|medium|strong|x-strong",
    "pause-before": "<time>|none|x-weak|weak|medium|strong|x-strong",
    "rest": "<'rest-before'> <'rest-after'>?",
    "rest-after": "<time>|none|x-weak|weak|medium|strong|x-strong",
    "rest-before": "<time>|none|x-weak|weak|medium|strong|x-strong",
    "src": "[<url> [format( <string># )]?|local( <family-name> )]#",
    "speak": "auto|never|always",
    "speak-as": "normal|spell-out||digits||[literal-punctuation|no-punctuation]",
    "unicode-range": "<urange>#",
    "voice-balance": "<number>|left|center|right|leftwards|rightwards",
    "voice-duration": "auto|<time>",
    "voice-family": "[[<family-name>|<generic-voice>] ,]* [<family-name>|<generic-voice>]|preserve",
    "voice-pitch": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]",
    "voice-range": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]",
    "voice-rate": "[normal|x-slow|slow|medium|fast|x-fast]||<percentage>",
    "voice-stress": "normal|strong|moderate|none|reduced",
    "voice-volume": "silent|[[x-soft|soft|medium|loud|x-loud]||<decibel>]",
    "white-space-trim": "none|discard-before||discard-after||discard-inner"
  },
  "atrules": {
    "charset": {
      "prelude": "<string>",
      "descriptors": null
    },
    "counter-style": {
      "prelude": "<counter-style-name>",
      "descriptors": {
        "additive-symbols": "[<integer>&&<symbol>]#",
        "fallback": "<counter-style-name>",
        "negative": "<symbol> <symbol>?",
        "pad": "<integer>&&<symbol>",
        "prefix": "<symbol>",
        "range": "[[<integer>|infinite]{2}]#|auto",
        "speak-as": "auto|bullets|numbers|words|spell-out|<counter-style-name>",
        "suffix": "<symbol>",
        "symbols": "<symbol>+",
        "system": "cyclic|numeric|alphabetic|symbolic|additive|[fixed <integer>?]|[extends <counter-style-name>]"
      }
    },
    "document": {
      "prelude": "[<url>|url-prefix( <string> )|domain( <string> )|media-document( <string> )|regexp( <string> )]#",
      "descriptors": null
    },
    "font-palette-values": {
      "prelude": "<dashed-ident>",
      "descriptors": {
        "base-palette": "light|dark|<integer [0,∞]>",
        "font-family": "<family-name>#",
        "override-colors": "[<integer [0,∞]> <absolute-color-base>]#"
      }
    },
    "font-face": {
      "prelude": null,
      "descriptors": {
        "ascent-override": "normal|<percentage>",
        "descent-override": "normal|<percentage>",
        "font-display": "[auto|block|swap|fallback|optional]",
        "font-family": "<family-name>",
        "font-feature-settings": "normal|<feature-tag-value>#",
        "font-variation-settings": "normal|[<string> <number>]#",
        "font-stretch": "<font-stretch-absolute>{1,2}",
        "font-style": "normal|italic|oblique <angle>{0,2}",
        "font-weight": "<font-weight-absolute>{1,2}",
        "line-gap-override": "normal|<percentage>",
        "size-adjust": "<percentage>",
        "src": "[<url> [format( <string># )]?|local( <family-name> )]#",
        "unicode-range": "<urange>#"
      }
    },
    "font-feature-values": {
      "prelude": "<family-name>#",
      "descriptors": null
    },
    "import": {
      "prelude": "[<string>|<url>] [layer|layer( <layer-name> )]? [supports( [<supports-condition>|<declaration>] )]? <media-query-list>?",
      "descriptors": null
    },
    "keyframes": {
      "prelude": "<keyframes-name>",
      "descriptors": null
    },
    "layer": {
      "prelude": "[<layer-name>#|<layer-name>?]",
      "descriptors": null
    },
    "media": {
      "prelude": "<media-query-list>",
      "descriptors": null
    },
    "namespace": {
      "prelude": "<namespace-prefix>? [<string>|<url>]",
      "descriptors": null
    },
    "page": {
      "prelude": "<page-selector-list>",
      "descriptors": {
        "bleed": "auto|<length>",
        "marks": "none|[crop||cross]",
        "page-orientation": "upright|rotate-left|rotate-right",
        "size": "<length>{1,2}|auto|[<page-size>||[portrait|landscape]]"
      }
    },
    "position-try": {
      "prelude": "<dashed-ident>",
      "descriptors": {
        "top": "<'top'>",
        "left": "<'left'>",
        "bottom": "<'bottom'>",
        "right": "<'right'>",
        "inset-block-start": "<'inset-block-start'>",
        "inset-block-end": "<'inset-block-end'>",
        "inset-inline-start": "<'inset-inline-start'>",
        "inset-inline-end": "<'inset-inline-end'>",
        "inset-block": "<'inset-block'>",
        "inset-inline": "<'inset-inline'>",
        "inset": "<'inset'>",
        "margin-top": "<'margin-top'>",
        "margin-left": "<'margin-left'>",
        "margin-bottom": "<'margin-bottom'>",
        "margin-right": "<'margin-right'>",
        "margin-block-start": "<'margin-block-start'>",
        "margin-block-end": "<'margin-block-end'>",
        "margin-inline-start": "<'margin-inline-start'>",
        "margin-inline-end": "<'margin-inline-end'>",
        "margin": "<'margin'>",
        "margin-block": "<'margin-block'>",
        "margin-inline": "<'margin-inline'>",
        "width": "<'width'>",
        "height": "<'height'>",
        "min-width": "<'min-width'>",
        "min-height": "<'min-height'>",
        "max-width": "<'max-width'>",
        "max-height": "<'max-height'>",
        "block-size": "<'block-size'>",
        "inline-size": "<'inline-size'>",
        "min-block-size": "<'min-block-size'>",
        "min-inline-size": "<'min-inline-size'>",
        "max-block-size": "<'max-block-size'>",
        "max-inline-size": "<'max-inline-size'>",
        "align-self": "<'align-self'>|anchor-center",
        "justify-self": "<'justify-self'>|anchor-center"
      }
    },
    "property": {
      "prelude": "<custom-property-name>",
      "descriptors": {
        "syntax": "<string>",
        "inherits": "true|false",
        "initial-value": "<declaration-value>?"
      }
    },
    "scope": {
      "prelude": "[( <scope-start> )]? [to ( <scope-end> )]?",
      "descriptors": null
    },
    "starting-style": {
      "prelude": null,
      "descriptors": null
    },
    "supports": {
      "prelude": "<supports-condition>",
      "descriptors": null
    },
    "container": {
      "prelude": "[<container-name>]? <container-condition>",
      "descriptors": null
    },
    "nest": {
      "prelude": "<complex-selector-list>",
      "descriptors": null
    }
  }
};
const PLUSSIGN$f = 43;
const HYPHENMINUS$9 = 45;
const N$5 = 110;
const DISALLOW_SIGN$2 = true;
const ALLOW_SIGN$2 = false;
function checkInteger$2(offset, disallowSign) {
  let pos = this.tokenStart + offset;
  const code2 = this.charCodeAt(pos);
  if (code2 === PLUSSIGN$f || code2 === HYPHENMINUS$9) {
    if (disallowSign) {
      this.error("Number sign is not allowed");
    }
    pos++;
  }
  for (; pos < this.tokenEnd; pos++) {
    if (!isDigit$2(this.charCodeAt(pos))) {
      this.error("Integer is expected", pos);
    }
  }
}
function checkTokenIsInteger$1(disallowSign) {
  return checkInteger$2.call(this, 0, disallowSign);
}
function expectCharCode$1(offset, code2) {
  if (!this.cmpChar(this.tokenStart + offset, code2)) {
    let msg = "";
    switch (code2) {
      case N$5:
        msg = "N is expected";
        break;
      case HYPHENMINUS$9:
        msg = "HyphenMinus is expected";
        break;
    }
    this.error(msg, this.tokenStart + offset);
  }
}
function consumeB$2() {
  let offset = 0;
  let sign = 0;
  let type = this.tokenType;
  while (type === WhiteSpace$3 || type === Comment$3) {
    type = this.lookupType(++offset);
  }
  if (type !== Number$5) {
    if (this.isDelim(PLUSSIGN$f, offset) || this.isDelim(HYPHENMINUS$9, offset)) {
      sign = this.isDelim(PLUSSIGN$f, offset) ? PLUSSIGN$f : HYPHENMINUS$9;
      do {
        type = this.lookupType(++offset);
      } while (type === WhiteSpace$3 || type === Comment$3);
      if (type !== Number$5) {
        this.skip(offset);
        checkTokenIsInteger$1.call(this, DISALLOW_SIGN$2);
      }
    } else {
      return null;
    }
  }
  if (offset > 0) {
    this.skip(offset);
  }
  if (sign === 0) {
    type = this.charCodeAt(this.tokenStart);
    if (type !== PLUSSIGN$f && type !== HYPHENMINUS$9) {
      this.error("Number sign is expected");
    }
  }
  checkTokenIsInteger$1.call(this, sign !== 0);
  return sign === HYPHENMINUS$9 ? "-" + this.consume(Number$5) : this.consume(Number$5);
}
const name$2a = "AnPlusB";
const structure$1o = {
  a: [String, null],
  b: [String, null]
};
function parse$1t() {
  const start = this.tokenStart;
  let a = null;
  let b = null;
  if (this.tokenType === Number$5) {
    checkTokenIsInteger$1.call(this, ALLOW_SIGN$2);
    b = this.consume(Number$5);
  } else if (this.tokenType === Ident$1 && this.cmpChar(this.tokenStart, HYPHENMINUS$9)) {
    a = "-1";
    expectCharCode$1.call(this, 1, N$5);
    switch (this.tokenEnd - this.tokenStart) {
      // -n
      // -n <signed-integer>
      // -n ['+' | '-'] <signless-integer>
      case 2:
        this.next();
        b = consumeB$2.call(this);
        break;
      // -n- <signless-integer>
      case 3:
        expectCharCode$1.call(this, 2, HYPHENMINUS$9);
        this.next();
        this.skipSC();
        checkTokenIsInteger$1.call(this, DISALLOW_SIGN$2);
        b = "-" + this.consume(Number$5);
        break;
      // <dashndashdigit-ident>
      default:
        expectCharCode$1.call(this, 2, HYPHENMINUS$9);
        checkInteger$2.call(this, 3, DISALLOW_SIGN$2);
        this.next();
        b = this.substrToCursor(start + 2);
    }
  } else if (this.tokenType === Ident$1 || this.isDelim(PLUSSIGN$f) && this.lookupType(1) === Ident$1) {
    let sign = 0;
    a = "1";
    if (this.isDelim(PLUSSIGN$f)) {
      sign = 1;
      this.next();
    }
    expectCharCode$1.call(this, 0, N$5);
    switch (this.tokenEnd - this.tokenStart) {
      // '+'? n
      // '+'? n <signed-integer>
      // '+'? n ['+' | '-'] <signless-integer>
      case 1:
        this.next();
        b = consumeB$2.call(this);
        break;
      // '+'? n- <signless-integer>
      case 2:
        expectCharCode$1.call(this, 1, HYPHENMINUS$9);
        this.next();
        this.skipSC();
        checkTokenIsInteger$1.call(this, DISALLOW_SIGN$2);
        b = "-" + this.consume(Number$5);
        break;
      // '+'? <ndashdigit-ident>
      default:
        expectCharCode$1.call(this, 1, HYPHENMINUS$9);
        checkInteger$2.call(this, 2, DISALLOW_SIGN$2);
        this.next();
        b = this.substrToCursor(start + sign + 1);
    }
  } else if (this.tokenType === Dimension$3) {
    const code2 = this.charCodeAt(this.tokenStart);
    const sign = code2 === PLUSSIGN$f || code2 === HYPHENMINUS$9;
    let i = this.tokenStart + sign;
    for (; i < this.tokenEnd; i++) {
      if (!isDigit$2(this.charCodeAt(i))) {
        break;
      }
    }
    if (i === this.tokenStart + sign) {
      this.error("Integer is expected", this.tokenStart + sign);
    }
    expectCharCode$1.call(this, i - this.tokenStart, N$5);
    a = this.substring(start, i);
    if (i + 1 === this.tokenEnd) {
      this.next();
      b = consumeB$2.call(this);
    } else {
      expectCharCode$1.call(this, i - this.tokenStart + 1, HYPHENMINUS$9);
      if (i + 2 === this.tokenEnd) {
        this.next();
        this.skipSC();
        checkTokenIsInteger$1.call(this, DISALLOW_SIGN$2);
        b = "-" + this.consume(Number$5);
      } else {
        checkInteger$2.call(this, i - this.tokenStart + 2, DISALLOW_SIGN$2);
        this.next();
        b = this.substrToCursor(i + 1);
      }
    }
  } else {
    this.error();
  }
  if (a !== null && a.charCodeAt(0) === PLUSSIGN$f) {
    a = a.substr(1);
  }
  if (b !== null && b.charCodeAt(0) === PLUSSIGN$f) {
    b = b.substr(1);
  }
  return {
    type: "AnPlusB",
    loc: this.getLocation(start, this.tokenStart),
    a,
    b
  };
}
function generate$1t(node2) {
  if (node2.a) {
    const a = node2.a === "+1" && "n" || node2.a === "1" && "n" || node2.a === "-1" && "-n" || node2.a + "n";
    if (node2.b) {
      const b = node2.b[0] === "-" || node2.b[0] === "+" ? node2.b : "+" + node2.b;
      this.tokenize(a + b);
    } else {
      this.tokenize(a);
    }
  } else {
    this.tokenize(node2.b);
  }
}
const AnPlusB$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$1t,
  name: name$2a,
  parse: parse$1t,
  structure: structure$1o
}, Symbol.toStringTag, { value: "Module" }));
function consumeRaw$a() {
  return this.Raw(this.consumeUntilLeftCurlyBracketOrSemicolon, true);
}
function isDeclarationBlockAtrule$1() {
  for (let offset = 1, type; type = this.lookupType(offset); offset++) {
    if (type === RightCurlyBracket$1) {
      return true;
    }
    if (type === LeftCurlyBracket$1 || type === AtKeyword$1) {
      return false;
    }
  }
  return false;
}
const name$29 = "Atrule";
const walkContext$j = "atrule";
const structure$1n = {
  name: String,
  prelude: ["AtrulePrelude", "Raw", null],
  block: ["Block", null]
};
function parse$1s(isDeclaration = false) {
  const start = this.tokenStart;
  let name2;
  let nameLowerCase;
  let prelude = null;
  let block = null;
  this.eat(AtKeyword$1);
  name2 = this.substrToCursor(start + 1);
  nameLowerCase = name2.toLowerCase();
  this.skipSC();
  if (this.eof === false && this.tokenType !== LeftCurlyBracket$1 && this.tokenType !== Semicolon$1) {
    if (this.parseAtrulePrelude) {
      prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name2, isDeclaration), consumeRaw$a);
    } else {
      prelude = consumeRaw$a.call(this, this.tokenIndex);
    }
    this.skipSC();
  }
  switch (this.tokenType) {
    case Semicolon$1:
      this.next();
      break;
    case LeftCurlyBracket$1:
      if (hasOwnProperty.call(this.atrule, nameLowerCase) && typeof this.atrule[nameLowerCase].block === "function") {
        block = this.atrule[nameLowerCase].block.call(this, isDeclaration);
      } else {
        block = this.Block(isDeclarationBlockAtrule$1.call(this));
      }
      break;
  }
  return {
    type: "Atrule",
    loc: this.getLocation(start, this.tokenStart),
    name: name2,
    prelude,
    block
  };
}
function generate$1s(node2) {
  this.token(AtKeyword$1, "@" + node2.name);
  if (node2.prelude !== null) {
    this.node(node2.prelude);
  }
  if (node2.block) {
    this.node(node2.block);
  } else {
    this.token(Semicolon$1, ";");
  }
}
const Atrule$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$1s,
  name: name$29,
  parse: parse$1s,
  structure: structure$1n,
  walkContext: walkContext$j
}, Symbol.toStringTag, { value: "Module" }));
const name$28 = "AtrulePrelude";
const walkContext$i = "atrulePrelude";
const structure$1m = {
  children: [[]]
};
function parse$1r(name2) {
  let children = null;
  if (name2 !== null) {
    name2 = name2.toLowerCase();
  }
  this.skipSC();
  if (hasOwnProperty.call(this.atrule, name2) && typeof this.atrule[name2].prelude === "function") {
    children = this.atrule[name2].prelude.call(this);
  } else {
    children = this.readSequence(this.scope.AtrulePrelude);
  }
  this.skipSC();
  if (this.eof !== true && this.tokenType !== LeftCurlyBracket$1 && this.tokenType !== Semicolon$1) {
    this.error("Semicolon or block is expected");
  }
  return {
    type: "AtrulePrelude",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate$1r(node2) {
  this.children(node2);
}
const AtrulePrelude$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$1r,
  name: name$28,
  parse: parse$1r,
  structure: structure$1m,
  walkContext: walkContext$i
}, Symbol.toStringTag, { value: "Module" }));
const DOLLARSIGN$3 = 36;
const ASTERISK$c = 42;
const EQUALSSIGN$2 = 61;
const CIRCUMFLEXACCENT$1 = 94;
const VERTICALLINE$6 = 124;
const TILDE$5 = 126;
function getAttributeName$1() {
  if (this.eof) {
    this.error("Unexpected end of input");
  }
  const start = this.tokenStart;
  let expectIdent = false;
  if (this.isDelim(ASTERISK$c)) {
    expectIdent = true;
    this.next();
  } else if (!this.isDelim(VERTICALLINE$6)) {
    this.eat(Ident$1);
  }
  if (this.isDelim(VERTICALLINE$6)) {
    if (this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN$2) {
      this.next();
      this.eat(Ident$1);
    } else if (expectIdent) {
      this.error("Identifier is expected", this.tokenEnd);
    }
  } else if (expectIdent) {
    this.error("Vertical line is expected");
  }
  return {
    type: "Identifier",
    loc: this.getLocation(start, this.tokenStart),
    name: this.substrToCursor(start)
  };
}
function getOperator$1() {
  const start = this.tokenStart;
  const code2 = this.charCodeAt(start);
  if (code2 !== EQUALSSIGN$2 && // =
  code2 !== TILDE$5 && // ~=
  code2 !== CIRCUMFLEXACCENT$1 && // ^=
  code2 !== DOLLARSIGN$3 && // $=
  code2 !== ASTERISK$c && // *=
  code2 !== VERTICALLINE$6) {
    this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected");
  }
  this.next();
  if (code2 !== EQUALSSIGN$2) {
    if (!this.isDelim(EQUALSSIGN$2)) {
      this.error("Equal sign is expected");
    }
    this.next();
  }
  return this.substrToCursor(start);
}
const name$27 = "AttributeSelector";
const structure$1l = {
  name: "Identifier",
  matcher: [String, null],
  value: ["String", "Identifier", null],
  flags: [String, null]
};
function parse$1q() {
  const start = this.tokenStart;
  let name2;
  let matcher = null;
  let value2 = null;
  let flags = null;
  this.eat(LeftSquareBracket$1);
  this.skipSC();
  name2 = getAttributeName$1.call(this);
  this.skipSC();
  if (this.tokenType !== RightSquareBracket$1) {
    if (this.tokenType !== Ident$1) {
      matcher = getOperator$1.call(this);
      this.skipSC();
      value2 = this.tokenType === String$4 ? this.String() : this.Identifier();
      this.skipSC();
    }
    if (this.tokenType === Ident$1) {
      flags = this.consume(Ident$1);
      this.skipSC();
    }
  }
  this.eat(RightSquareBracket$1);
  return {
    type: "AttributeSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: name2,
    matcher,
    value: value2,
    flags
  };
}
function generate$1q(node2) {
  this.token(Delim$1, "[");
  this.node(node2.name);
  if (node2.matcher !== null) {
    this.tokenize(node2.matcher);
    this.node(node2.value);
  }
  if (node2.flags !== null) {
    this.token(Ident$1, node2.flags);
  }
  this.token(Delim$1, "]");
}
const AttributeSelector$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$1q,
  name: name$27,
  parse: parse$1q,
  structure: structure$1l
}, Symbol.toStringTag, { value: "Module" }));
const AMPERSAND$6 = 38;
function consumeRaw$9() {
  return this.Raw(null, true);
}
function consumeRule$1() {
  return this.parseWithFallback(this.Rule, consumeRaw$9);
}
function consumeRawDeclaration$1() {
  return this.Raw(this.consumeUntilSemicolonIncluded, true);
}
function consumeDeclaration$1() {
  if (this.tokenType === Semicolon$1) {
    return consumeRawDeclaration$1.call(this, this.tokenIndex);
  }
  const node2 = this.parseWithFallback(this.Declaration, consumeRawDeclaration$1);
  if (this.tokenType === Semicolon$1) {
    this.next();
  }
  return node2;
}
const name$26 = "Block";
const walkContext$h = "block";
const structure$1k = {
  children: [[
    "Atrule",
    "Rule",
    "Declaration"
  ]]
};
function parse$1p(isStyleBlock) {
  const consumer = isStyleBlock ? consumeDeclaration$1 : consumeRule$1;
  const start = this.tokenStart;
  let children = this.createList();
  this.eat(LeftCurlyBracket$1);
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case RightCurlyBracket$1:
          break scan;
        case WhiteSpace$3:
        case Comment$3:
          this.next();
          break;
        case AtKeyword$1:
          children.push(this.parseWithFallback(this.Atrule.bind(this, isStyleBlock), consumeRaw$9));
          break;
        default:
          if (isStyleBlock && this.isDelim(AMPERSAND$6)) {
            children.push(consumeRule$1.call(this));
          } else {
            children.push(consumer.call(this));
          }
      }
    }
  if (!this.eof) {
    this.eat(RightCurlyBracket$1);
  }
  return {
    type: "Block",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate$1p(node2) {
  this.token(LeftCurlyBracket$1, "{");
  this.children(node2, (prev) => {
    if (prev.type === "Declaration") {
      this.token(Semicolon$1, ";");
    }
  });
  this.token(RightCurlyBracket$1, "}");
}
const Block$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$1p,
  name: name$26,
  parse: parse$1p,
  structure: structure$1k,
  walkContext: walkContext$h
}, Symbol.toStringTag, { value: "Module" }));
const name$25 = "Brackets";
const structure$1j = {
  children: [[]]
};
function parse$1o(readSequence2, recognizer) {
  const start = this.tokenStart;
  let children = null;
  this.eat(LeftSquareBracket$1);
  children = readSequence2.call(this, recognizer);
  if (!this.eof) {
    this.eat(RightSquareBracket$1);
  }
  return {
    type: "Brackets",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate$1o(node2) {
  this.token(Delim$1, "[");
  this.children(node2);
  this.token(Delim$1, "]");
}
const Brackets$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$1o,
  name: name$25,
  parse: parse$1o,
  structure: structure$1j
}, Symbol.toStringTag, { value: "Module" }));
const name$24 = "CDC";
const structure$1i = [];
function parse$1n() {
  const start = this.tokenStart;
  this.eat(CDC$3);
  return {
    type: "CDC",
    loc: this.getLocation(start, this.tokenStart)
  };
}
function generate$1n() {
  this.token(CDC$3, "-->");
}
const CDC$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$1n,
  name: name$24,
  parse: parse$1n,
  structure: structure$1i
}, Symbol.toStringTag, { value: "Module" }));
const name$23 = "CDO";
const structure$1h = [];
function parse$1m() {
  const start = this.tokenStart;
  this.eat(CDO$3);
  return {
    type: "CDO",
    loc: this.getLocation(start, this.tokenStart)
  };
}
function generate$1m() {
  this.token(CDO$3, "<!--");
}
const CDO$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$1m,
  name: name$23,
  parse: parse$1m,
  structure: structure$1h
}, Symbol.toStringTag, { value: "Module" }));
const FULLSTOP$5 = 46;
const name$22 = "ClassSelector";
const structure$1g = {
  name: String
};
function parse$1l() {
  this.eatDelim(FULLSTOP$5);
  return {
    type: "ClassSelector",
    loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),
    name: this.consume(Ident$1)
  };
}
function generate$1l(node2) {
  this.token(Delim$1, ".");
  this.token(Ident$1, node2.name);
}
const ClassSelector$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$1l,
  name: name$22,
  parse: parse$1l,
  structure: structure$1g
}, Symbol.toStringTag, { value: "Module" }));
const PLUSSIGN$e = 43;
const SOLIDUS$d = 47;
const GREATERTHANSIGN$5 = 62;
const TILDE$4 = 126;
const name$21 = "Combinator";
const structure$1f = {
  name: String
};
function parse$1k() {
  const start = this.tokenStart;
  let name2;
  switch (this.tokenType) {
    case WhiteSpace$3:
      name2 = " ";
      break;
    case Delim$1:
      switch (this.charCodeAt(this.tokenStart)) {
        case GREATERTHANSIGN$5:
        case PLUSSIGN$e:
        case TILDE$4:
          this.next();
          break;
        case SOLIDUS$d:
          this.next();
          this.eatIdent("deep");
          this.eatDelim(SOLIDUS$d);
          break;
        default:
          this.error("Combinator is expected");
      }
      name2 = this.substrToCursor(start);
      break;
  }
  return {
    type: "Combinator",
    loc: this.getLocation(start, this.tokenStart),
    name: name2
  };
}
function generate$1k(node2) {
  this.tokenize(node2.name);
}
const Combinator$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$1k,
  name: name$21,
  parse: parse$1k,
  structure: structure$1f
}, Symbol.toStringTag, { value: "Module" }));
const ASTERISK$b = 42;
const SOLIDUS$c = 47;
const name$20 = "Comment";
const structure$1e = {
  value: String
};
function parse$1j() {
  const start = this.tokenStart;
  let end = this.tokenEnd;
  this.eat(Comment$3);
  if (end - start + 2 >= 2 && this.charCodeAt(end - 2) === ASTERISK$b && this.charCodeAt(end - 1) === SOLIDUS$c) {
    end -= 2;
  }
  return {
    type: "Comment",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substring(start + 2, end)
  };
}
function generate$1j(node2) {
  this.token(Comment$3, "/*" + node2.value + "*/");
}
const Comment$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$1j,
  name: name$20,
  parse: parse$1j,
  structure: structure$1e
}, Symbol.toStringTag, { value: "Module" }));
const likelyFeatureToken = /* @__PURE__ */ new Set([Colon$1, RightParenthesis$1, EOF$3]);
const name$1$ = "Condition";
const structure$1d = {
  kind: String,
  children: [[
    "Identifier",
    "Feature",
    "FeatureFunction",
    "FeatureRange",
    "SupportsDeclaration"
  ]]
};
function featureOrRange(kind) {
  if (this.lookupTypeNonSC(1) === Ident$1 && likelyFeatureToken.has(this.lookupTypeNonSC(2))) {
    return this.Feature(kind);
  }
  return this.FeatureRange(kind);
}
const parentheses$1 = {
  media: featureOrRange,
  container: featureOrRange,
  supports() {
    return this.SupportsDeclaration();
  }
};
function parse$1i(kind = "media") {
  const children = this.createList();
  scan: while (!this.eof) {
    switch (this.tokenType) {
      case Comment$3:
      case WhiteSpace$3:
        this.next();
        continue;
      case Ident$1:
        children.push(this.Identifier());
        break;
      case LeftParenthesis$1: {
        let term = this.parseWithFallback(
          () => parentheses$1[kind].call(this, kind),
          () => null
        );
        if (!term) {
          term = this.parseWithFallback(
            () => {
              this.eat(LeftParenthesis$1);
              const res = this.Condition(kind);
              this.eat(RightParenthesis$1);
              return res;
            },
            () => {
              return this.GeneralEnclosed(kind);
            }
          );
        }
        children.push(term);
        break;
      }
      case Function$3: {
        let term = this.parseWithFallback(
          () => this.FeatureFunction(kind),
          () => null
        );
        if (!term) {
          term = this.GeneralEnclosed(kind);
        }
        children.push(term);
        break;
      }
      default:
        break scan;
    }
  }
  if (children.isEmpty) {
    this.error("Condition is expected");
  }
  return {
    type: "Condition",
    loc: this.getLocationFromList(children),
    kind,
    children
  };
}
function generate$1i(node2) {
  node2.children.forEach((child) => {
    if (child.type === "Condition") {
      this.token(LeftParenthesis$1, "(");
      this.node(child);
      this.token(RightParenthesis$1, ")");
    } else {
      this.node(child);
    }
  });
}
const Condition = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$1i,
  name: name$1$,
  parse: parse$1i,
  structure: structure$1d
}, Symbol.toStringTag, { value: "Module" }));
const EXCLAMATIONMARK$5 = 33;
const NUMBERSIGN$7 = 35;
const DOLLARSIGN$2 = 36;
const AMPERSAND$5 = 38;
const ASTERISK$a = 42;
const PLUSSIGN$d = 43;
const SOLIDUS$b = 47;
function consumeValueRaw$1() {
  return this.Raw(this.consumeUntilExclamationMarkOrSemicolon, true);
}
function consumeCustomPropertyRaw$1() {
  return this.Raw(this.consumeUntilExclamationMarkOrSemicolon, false);
}
function consumeValue$1() {
  const startValueToken = this.tokenIndex;
  const value2 = this.Value();
  if (value2.type !== "Raw" && this.eof === false && this.tokenType !== Semicolon$1 && this.isDelim(EXCLAMATIONMARK$5) === false && this.isBalanceEdge(startValueToken) === false) {
    this.error();
  }
  return value2;
}
const name$1_ = "Declaration";
const walkContext$g = "declaration";
const structure$1c = {
  important: [Boolean, String],
  property: String,
  value: ["Value", "Raw"]
};
function parse$1h() {
  const start = this.tokenStart;
  const startToken = this.tokenIndex;
  const property2 = readProperty$2.call(this);
  const customProperty = isCustomProperty$1(property2);
  const parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
  const consumeRaw2 = customProperty ? consumeCustomPropertyRaw$1 : consumeValueRaw$1;
  let important = false;
  let value2;
  this.skipSC();
  this.eat(Colon$1);
  const valueStart = this.tokenIndex;
  if (!customProperty) {
    this.skipSC();
  }
  if (parseValue) {
    value2 = this.parseWithFallback(consumeValue$1, consumeRaw2);
  } else {
    value2 = consumeRaw2.call(this, this.tokenIndex);
  }
  if (customProperty && value2.type === "Value" && value2.children.isEmpty) {
    for (let offset = valueStart - this.tokenIndex; offset <= 0; offset++) {
      if (this.lookupType(offset) === WhiteSpace$3) {
        value2.children.appendData({
          type: "WhiteSpace",
          loc: null,
          value: " "
        });
        break;
      }
    }
  }
  if (this.isDelim(EXCLAMATIONMARK$5)) {
    important = getImportant$1.call(this);
    this.skipSC();
  }
  if (this.eof === false && this.tokenType !== Semicolon$1 && this.isBalanceEdge(startToken) === false) {
    this.error();
  }
  return {
    type: "Declaration",
    loc: this.getLocation(start, this.tokenStart),
    important,
    property: property2,
    value: value2
  };
}
function generate$1h(node2) {
  this.token(Ident$1, node2.property);
  this.token(Colon$1, ":");
  this.node(node2.value);
  if (node2.important) {
    this.token(Delim$1, "!");
    this.token(Ident$1, node2.important === true ? "important" : node2.important);
  }
}
function readProperty$2() {
  const start = this.tokenStart;
  if (this.tokenType === Delim$1) {
    switch (this.charCodeAt(this.tokenStart)) {
      case ASTERISK$a:
      case DOLLARSIGN$2:
      case PLUSSIGN$d:
      case NUMBERSIGN$7:
      case AMPERSAND$5:
        this.next();
        break;
      // TODO: not sure we should support this hack
      case SOLIDUS$b:
        this.next();
        if (this.isDelim(SOLIDUS$b)) {
          this.next();
        }
        break;
    }
  }
  if (this.tokenType === Hash$3) {
    this.eat(Hash$3);
  } else {
    this.eat(Ident$1);
  }
  return this.substrToCursor(start);
}
function getImportant$1() {
  this.eat(Delim$1);
  this.skipSC();
  const important = this.consume(Ident$1);
  return important === "important" ? true : important;
}
const Declaration$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$1h,
  name: name$1_,
  parse: parse$1h,
  structure: structure$1c,
  walkContext: walkContext$g
}, Symbol.toStringTag, { value: "Module" }));
const AMPERSAND$4 = 38;
function consumeRaw$8() {
  return this.Raw(this.consumeUntilSemicolonIncluded, true);
}
const name$1Z = "DeclarationList";
const structure$1b = {
  children: [[
    "Declaration",
    "Atrule",
    "Rule"
  ]]
};
function parse$1g() {
  const children = this.createList();
  while (!this.eof) {
    switch (this.tokenType) {
      case WhiteSpace$3:
      case Comment$3:
      case Semicolon$1:
        this.next();
        break;
      case AtKeyword$1:
        children.push(this.parseWithFallback(this.Atrule.bind(this, true), consumeRaw$8));
        break;
      default:
        if (this.isDelim(AMPERSAND$4)) {
          children.push(this.parseWithFallback(this.Rule, consumeRaw$8));
        } else {
          children.push(this.parseWithFallback(this.Declaration, consumeRaw$8));
        }
    }
  }
  return {
    type: "DeclarationList",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate$1g(node2) {
  this.children(node2, (prev) => {
    if (prev.type === "Declaration") {
      this.token(Semicolon$1, ";");
    }
  });
}
const DeclarationList$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$1g,
  name: name$1Z,
  parse: parse$1g,
  structure: structure$1b
}, Symbol.toStringTag, { value: "Module" }));
const name$1Y = "Dimension";
const structure$1a = {
  value: String,
  unit: String
};
function parse$1f() {
  const start = this.tokenStart;
  const value2 = this.consumeNumber(Dimension$3);
  return {
    type: "Dimension",
    loc: this.getLocation(start, this.tokenStart),
    value: value2,
    unit: this.substring(start + value2.length, this.tokenStart)
  };
}
function generate$1f(node2) {
  this.token(Dimension$3, node2.value + node2.unit);
}
const Dimension$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$1f,
  name: name$1Y,
  parse: parse$1f,
  structure: structure$1a
}, Symbol.toStringTag, { value: "Module" }));
const SOLIDUS$a = 47;
const name$1X = "Feature";
const structure$19 = {
  kind: String,
  name: String,
  value: ["Identifier", "Number", "Dimension", "Ratio", "Function", null]
};
function parse$1e(kind) {
  const start = this.tokenStart;
  let name2;
  let value2 = null;
  this.eat(LeftParenthesis$1);
  this.skipSC();
  name2 = this.consume(Ident$1);
  this.skipSC();
  if (this.tokenType !== RightParenthesis$1) {
    this.eat(Colon$1);
    this.skipSC();
    switch (this.tokenType) {
      case Number$5:
        if (this.lookupNonWSType(1) === Delim$1) {
          value2 = this.Ratio();
        } else {
          value2 = this.Number();
        }
        break;
      case Dimension$3:
        value2 = this.Dimension();
        break;
      case Ident$1:
        value2 = this.Identifier();
        break;
      case Function$3:
        value2 = this.parseWithFallback(
          () => {
            const res = this.Function(this.readSequence, this.scope.Value);
            this.skipSC();
            if (this.isDelim(SOLIDUS$a)) {
              this.error();
            }
            return res;
          },
          () => {
            return this.Ratio();
          }
        );
        break;
      default:
        this.error("Number, dimension, ratio or identifier is expected");
    }
    this.skipSC();
  }
  if (!this.eof) {
    this.eat(RightParenthesis$1);
  }
  return {
    type: "Feature",
    loc: this.getLocation(start, this.tokenStart),
    kind,
    name: name2,
    value: value2
  };
}
function generate$1e(node2) {
  this.token(LeftParenthesis$1, "(");
  this.token(Ident$1, node2.name);
  if (node2.value !== null) {
    this.token(Colon$1, ":");
    this.node(node2.value);
  }
  this.token(RightParenthesis$1, ")");
}
const Feature = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$1e,
  name: name$1X,
  parse: parse$1e,
  structure: structure$19
}, Symbol.toStringTag, { value: "Module" }));
const name$1W = "FeatureFunction";
const structure$18 = {
  kind: String,
  feature: String,
  value: ["Declaration", "Selector"]
};
function getFeatureParser(kind, name2) {
  const featuresOfKind = this.features[kind] || {};
  const parser = featuresOfKind[name2];
  if (typeof parser !== "function") {
    this.error(`Unknown feature ${name2}()`);
  }
  return parser;
}
function parse$1d(kind = "unknown") {
  const start = this.tokenStart;
  const functionName = this.consumeFunctionName();
  const valueParser = getFeatureParser.call(this, kind, functionName.toLowerCase());
  this.skipSC();
  const value2 = this.parseWithFallback(
    () => {
      const startValueToken = this.tokenIndex;
      const value3 = valueParser.call(this);
      if (this.eof === false && this.isBalanceEdge(startValueToken) === false) {
        this.error();
      }
      return value3;
    },
    () => this.Raw(null, false)
  );
  if (!this.eof) {
    this.eat(RightParenthesis$1);
  }
  return {
    type: "FeatureFunction",
    loc: this.getLocation(start, this.tokenStart),
    kind,
    feature: functionName,
    value: value2
  };
}
function generate$1d(node2) {
  this.token(Function$3, node2.feature + "(");
  this.node(node2.value);
  this.token(RightParenthesis$1, ")");
}
const FeatureFunction = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$1d,
  name: name$1W,
  parse: parse$1d,
  structure: structure$18
}, Symbol.toStringTag, { value: "Module" }));
const SOLIDUS$9 = 47;
const LESSTHANSIGN$1 = 60;
const EQUALSSIGN$1 = 61;
const GREATERTHANSIGN$4 = 62;
const name$1V = "FeatureRange";
const structure$17 = {
  kind: String,
  left: ["Identifier", "Number", "Dimension", "Ratio", "Function"],
  leftComparison: String,
  middle: ["Identifier", "Number", "Dimension", "Ratio", "Function"],
  rightComparison: [String, null],
  right: ["Identifier", "Number", "Dimension", "Ratio", "Function", null]
};
function readTerm() {
  this.skipSC();
  switch (this.tokenType) {
    case Number$5:
      if (this.isDelim(SOLIDUS$9, this.lookupOffsetNonSC(1))) {
        return this.Ratio();
      } else {
        return this.Number();
      }
    case Dimension$3:
      return this.Dimension();
    case Ident$1:
      return this.Identifier();
    case Function$3:
      return this.parseWithFallback(
        () => {
          const res = this.Function(this.readSequence, this.scope.Value);
          this.skipSC();
          if (this.isDelim(SOLIDUS$9)) {
            this.error();
          }
          return res;
        },
        () => {
          return this.Ratio();
        }
      );
    default:
      this.error("Number, dimension, ratio or identifier is expected");
  }
}
function readComparison(expectColon) {
  this.skipSC();
  if (this.isDelim(LESSTHANSIGN$1) || this.isDelim(GREATERTHANSIGN$4)) {
    const value2 = this.source[this.tokenStart];
    this.next();
    if (this.isDelim(EQUALSSIGN$1)) {
      this.next();
      return value2 + "=";
    }
    return value2;
  }
  if (this.isDelim(EQUALSSIGN$1)) {
    return "=";
  }
  this.error(`Expected ${expectColon ? '":", ' : ""}"<", ">", "=" or ")"`);
}
function parse$1c(kind = "unknown") {
  const start = this.tokenStart;
  this.skipSC();
  this.eat(LeftParenthesis$1);
  const left = readTerm.call(this);
  const leftComparison = readComparison.call(this, left.type === "Identifier");
  const middle = readTerm.call(this);
  let rightComparison = null;
  let right = null;
  if (this.lookupNonWSType(0) !== RightParenthesis$1) {
    rightComparison = readComparison.call(this);
    right = readTerm.call(this);
  }
  this.skipSC();
  this.eat(RightParenthesis$1);
  return {
    type: "FeatureRange",
    loc: this.getLocation(start, this.tokenStart),
    kind,
    left,
    leftComparison,
    middle,
    rightComparison,
    right
  };
}
function generate$1c(node2) {
  this.token(LeftParenthesis$1, "(");
  this.node(node2.left);
  this.tokenize(node2.leftComparison);
  this.node(node2.middle);
  if (node2.right) {
    this.tokenize(node2.rightComparison);
    this.node(node2.right);
  }
  this.token(RightParenthesis$1, ")");
}
const FeatureRange = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$1c,
  name: name$1V,
  parse: parse$1c,
  structure: structure$17
}, Symbol.toStringTag, { value: "Module" }));
const name$1U = "Function";
const walkContext$f = "function";
const structure$16 = {
  name: String,
  children: [[]]
};
function parse$1b(readSequence2, recognizer) {
  const start = this.tokenStart;
  const name2 = this.consumeFunctionName();
  const nameLowerCase = name2.toLowerCase();
  let children;
  children = recognizer.hasOwnProperty(nameLowerCase) ? recognizer[nameLowerCase].call(this, recognizer) : readSequence2.call(this, recognizer);
  if (!this.eof) {
    this.eat(RightParenthesis$1);
  }
  return {
    type: "Function",
    loc: this.getLocation(start, this.tokenStart),
    name: name2,
    children
  };
}
function generate$1b(node2) {
  this.token(Function$3, node2.name + "(");
  this.children(node2);
  this.token(RightParenthesis$1, ")");
}
const Function$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$1b,
  name: name$1U,
  parse: parse$1b,
  structure: structure$16,
  walkContext: walkContext$f
}, Symbol.toStringTag, { value: "Module" }));
const name$1T = "GeneralEnclosed";
const structure$15 = {
  kind: String,
  function: [String, null],
  children: [[]]
};
function parse$1a(kind) {
  const start = this.tokenStart;
  let functionName = null;
  if (this.tokenType === Function$3) {
    functionName = this.consumeFunctionName();
  } else {
    this.eat(LeftParenthesis$1);
  }
  const children = this.parseWithFallback(
    () => {
      const startValueToken = this.tokenIndex;
      const children2 = this.readSequence(this.scope.Value);
      if (this.eof === false && this.isBalanceEdge(startValueToken) === false) {
        this.error();
      }
      return children2;
    },
    () => this.createSingleNodeList(
      this.Raw(null, false)
    )
  );
  if (!this.eof) {
    this.eat(RightParenthesis$1);
  }
  return {
    type: "GeneralEnclosed",
    loc: this.getLocation(start, this.tokenStart),
    kind,
    function: functionName,
    children
  };
}
function generate$1a(node2) {
  if (node2.function) {
    this.token(Function$3, node2.function + "(");
  } else {
    this.token(LeftParenthesis$1, "(");
  }
  this.children(node2);
  this.token(RightParenthesis$1, ")");
}
const GeneralEnclosed = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$1a,
  name: name$1T,
  parse: parse$1a,
  structure: structure$15
}, Symbol.toStringTag, { value: "Module" }));
const xxx$1 = "XXX";
const name$1S = "Hash";
const structure$14 = {
  value: String
};
function parse$19() {
  const start = this.tokenStart;
  this.eat(Hash$3);
  return {
    type: "Hash",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substrToCursor(start + 1)
  };
}
function generate$19(node2) {
  this.token(Hash$3, "#" + node2.value);
}
const Hash$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$19,
  name: name$1S,
  parse: parse$19,
  structure: structure$14,
  xxx: xxx$1
}, Symbol.toStringTag, { value: "Module" }));
const name$1R = "Identifier";
const structure$13 = {
  name: String
};
function parse$18() {
  return {
    type: "Identifier",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    name: this.consume(Ident$1)
  };
}
function generate$18(node2) {
  this.token(Ident$1, node2.name);
}
const Identifier$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$18,
  name: name$1R,
  parse: parse$18,
  structure: structure$13
}, Symbol.toStringTag, { value: "Module" }));
const name$1Q = "IdSelector";
const structure$12 = {
  name: String
};
function parse$17() {
  const start = this.tokenStart;
  this.eat(Hash$3);
  return {
    type: "IdSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: this.substrToCursor(start + 1)
  };
}
function generate$17(node2) {
  this.token(Delim$1, "#" + node2.name);
}
const IdSelector$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$17,
  name: name$1Q,
  parse: parse$17,
  structure: structure$12
}, Symbol.toStringTag, { value: "Module" }));
const FULLSTOP$4 = 46;
const name$1P = "Layer";
const structure$11 = {
  name: String
};
function parse$16() {
  let tokenStart = this.tokenStart;
  let name2 = this.consume(Ident$1);
  while (this.isDelim(FULLSTOP$4)) {
    this.eat(Delim$1);
    name2 += "." + this.consume(Ident$1);
  }
  return {
    type: "Layer",
    loc: this.getLocation(tokenStart, this.tokenStart),
    name: name2
  };
}
function generate$16(node2) {
  this.tokenize(node2.name);
}
const Layer = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$16,
  name: name$1P,
  parse: parse$16,
  structure: structure$11
}, Symbol.toStringTag, { value: "Module" }));
const name$1O = "LayerList";
const structure$10 = {
  children: [[
    "Layer"
  ]]
};
function parse$15() {
  const children = this.createList();
  this.skipSC();
  while (!this.eof) {
    children.push(this.Layer());
    if (this.lookupTypeNonSC(0) !== Comma$1) {
      break;
    }
    this.skipSC();
    this.next();
    this.skipSC();
  }
  return {
    type: "LayerList",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate$15(node2) {
  this.children(node2, () => this.token(Comma$1, ","));
}
const LayerList = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$15,
  name: name$1O,
  parse: parse$15,
  structure: structure$10
}, Symbol.toStringTag, { value: "Module" }));
const name$1N = "MediaQuery";
const structure$$ = {
  modifier: [String, null],
  mediaType: [String, null],
  condition: ["Condition", null]
};
function parse$14() {
  const start = this.tokenStart;
  let modifier = null;
  let mediaType = null;
  let condition = null;
  this.skipSC();
  if (this.tokenType === Ident$1 && this.lookupTypeNonSC(1) !== LeftParenthesis$1) {
    const ident = this.consume(Ident$1);
    const identLowerCase = ident.toLowerCase();
    if (identLowerCase === "not" || identLowerCase === "only") {
      this.skipSC();
      modifier = identLowerCase;
      mediaType = this.consume(Ident$1);
    } else {
      mediaType = ident;
    }
    switch (this.lookupTypeNonSC(0)) {
      case Ident$1: {
        this.skipSC();
        this.eatIdent("and");
        condition = this.Condition("media");
        break;
      }
      case LeftCurlyBracket$1:
      case Semicolon$1:
      case Comma$1:
      case EOF$3:
        break;
      default:
        this.error("Identifier or parenthesis is expected");
    }
  } else {
    switch (this.tokenType) {
      case Ident$1:
      case LeftParenthesis$1:
      case Function$3: {
        condition = this.Condition("media");
        break;
      }
      case LeftCurlyBracket$1:
      case Semicolon$1:
      case EOF$3:
        break;
      default:
        this.error("Identifier or parenthesis is expected");
    }
  }
  return {
    type: "MediaQuery",
    loc: this.getLocation(start, this.tokenStart),
    modifier,
    mediaType,
    condition
  };
}
function generate$14(node2) {
  if (node2.mediaType) {
    if (node2.modifier) {
      this.token(Ident$1, node2.modifier);
    }
    this.token(Ident$1, node2.mediaType);
    if (node2.condition) {
      this.token(Ident$1, "and");
      this.node(node2.condition);
    }
  } else if (node2.condition) {
    this.node(node2.condition);
  }
}
const MediaQuery$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$14,
  name: name$1N,
  parse: parse$14,
  structure: structure$$
}, Symbol.toStringTag, { value: "Module" }));
const name$1M = "MediaQueryList";
const structure$_ = {
  children: [[
    "MediaQuery"
  ]]
};
function parse$13() {
  const children = this.createList();
  this.skipSC();
  while (!this.eof) {
    children.push(this.MediaQuery());
    if (this.tokenType !== Comma$1) {
      break;
    }
    this.next();
  }
  return {
    type: "MediaQueryList",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate$13(node2) {
  this.children(node2, () => this.token(Comma$1, ","));
}
const MediaQueryList$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$13,
  name: name$1M,
  parse: parse$13,
  structure: structure$_
}, Symbol.toStringTag, { value: "Module" }));
const AMPERSAND$3 = 38;
const name$1L = "NestingSelector";
const structure$Z = {};
function parse$12() {
  const start = this.tokenStart;
  this.eatDelim(AMPERSAND$3);
  return {
    type: "NestingSelector",
    loc: this.getLocation(start, this.tokenStart)
  };
}
function generate$12() {
  this.token(Delim$1, "&");
}
const NestingSelector = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$12,
  name: name$1L,
  parse: parse$12,
  structure: structure$Z
}, Symbol.toStringTag, { value: "Module" }));
const name$1K = "Nth";
const structure$Y = {
  nth: ["AnPlusB", "Identifier"],
  selector: ["SelectorList", null]
};
function parse$11() {
  this.skipSC();
  const start = this.tokenStart;
  let end = start;
  let selector2 = null;
  let nth2;
  if (this.lookupValue(0, "odd") || this.lookupValue(0, "even")) {
    nth2 = this.Identifier();
  } else {
    nth2 = this.AnPlusB();
  }
  end = this.tokenStart;
  this.skipSC();
  if (this.lookupValue(0, "of")) {
    this.next();
    selector2 = this.SelectorList();
    end = this.tokenStart;
  }
  return {
    type: "Nth",
    loc: this.getLocation(start, end),
    nth: nth2,
    selector: selector2
  };
}
function generate$11(node2) {
  this.node(node2.nth);
  if (node2.selector !== null) {
    this.token(Ident$1, "of");
    this.node(node2.selector);
  }
}
const Nth$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$11,
  name: name$1K,
  parse: parse$11,
  structure: structure$Y
}, Symbol.toStringTag, { value: "Module" }));
const name$1J = "Number";
const structure$X = {
  value: String
};
function parse$10() {
  return {
    type: "Number",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    value: this.consume(Number$5)
  };
}
function generate$10(node2) {
  this.token(Number$5, node2.value);
}
const Number$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$10,
  name: name$1J,
  parse: parse$10,
  structure: structure$X
}, Symbol.toStringTag, { value: "Module" }));
const name$1I = "Operator";
const structure$W = {
  value: String
};
function parse$$() {
  const start = this.tokenStart;
  this.next();
  return {
    type: "Operator",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substrToCursor(start)
  };
}
function generate$$(node2) {
  this.tokenize(node2.value);
}
const Operator$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$$,
  name: name$1I,
  parse: parse$$,
  structure: structure$W
}, Symbol.toStringTag, { value: "Module" }));
const name$1H = "Parentheses";
const structure$V = {
  children: [[]]
};
function parse$_(readSequence2, recognizer) {
  const start = this.tokenStart;
  let children = null;
  this.eat(LeftParenthesis$1);
  children = readSequence2.call(this, recognizer);
  if (!this.eof) {
    this.eat(RightParenthesis$1);
  }
  return {
    type: "Parentheses",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate$_(node2) {
  this.token(LeftParenthesis$1, "(");
  this.children(node2);
  this.token(RightParenthesis$1, ")");
}
const Parentheses$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$_,
  name: name$1H,
  parse: parse$_,
  structure: structure$V
}, Symbol.toStringTag, { value: "Module" }));
const name$1G = "Percentage";
const structure$U = {
  value: String
};
function parse$Z() {
  return {
    type: "Percentage",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    value: this.consumeNumber(Percentage$3)
  };
}
function generate$Z(node2) {
  this.token(Percentage$3, node2.value + "%");
}
const Percentage$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$Z,
  name: name$1G,
  parse: parse$Z,
  structure: structure$U
}, Symbol.toStringTag, { value: "Module" }));
const name$1F = "PseudoClassSelector";
const walkContext$e = "function";
const structure$T = {
  name: String,
  children: [["Raw"], null]
};
function parse$Y() {
  const start = this.tokenStart;
  let children = null;
  let name2;
  let nameLowerCase;
  this.eat(Colon$1);
  if (this.tokenType === Function$3) {
    name2 = this.consumeFunctionName();
    nameLowerCase = name2.toLowerCase();
    if (this.lookupNonWSType(0) == RightParenthesis$1) {
      children = this.createList();
    } else if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
      this.skipSC();
      children = this.pseudo[nameLowerCase].call(this);
      this.skipSC();
    } else {
      children = this.createList();
      children.push(
        this.Raw(null, false)
      );
    }
    this.eat(RightParenthesis$1);
  } else {
    name2 = this.consume(Ident$1);
  }
  return {
    type: "PseudoClassSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: name2,
    children
  };
}
function generate$Y(node2) {
  this.token(Colon$1, ":");
  if (node2.children === null) {
    this.token(Ident$1, node2.name);
  } else {
    this.token(Function$3, node2.name + "(");
    this.children(node2);
    this.token(RightParenthesis$1, ")");
  }
}
const PseudoClassSelector$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$Y,
  name: name$1F,
  parse: parse$Y,
  structure: structure$T,
  walkContext: walkContext$e
}, Symbol.toStringTag, { value: "Module" }));
const name$1E = "PseudoElementSelector";
const walkContext$d = "function";
const structure$S = {
  name: String,
  children: [["Raw"], null]
};
function parse$X() {
  const start = this.tokenStart;
  let children = null;
  let name2;
  let nameLowerCase;
  this.eat(Colon$1);
  this.eat(Colon$1);
  if (this.tokenType === Function$3) {
    name2 = this.consumeFunctionName();
    nameLowerCase = name2.toLowerCase();
    if (this.lookupNonWSType(0) == RightParenthesis$1) {
      children = this.createList();
    } else if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
      this.skipSC();
      children = this.pseudo[nameLowerCase].call(this);
      this.skipSC();
    } else {
      children = this.createList();
      children.push(
        this.Raw(null, false)
      );
    }
    this.eat(RightParenthesis$1);
  } else {
    name2 = this.consume(Ident$1);
  }
  return {
    type: "PseudoElementSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: name2,
    children
  };
}
function generate$X(node2) {
  this.token(Colon$1, ":");
  this.token(Colon$1, ":");
  if (node2.children === null) {
    this.token(Ident$1, node2.name);
  } else {
    this.token(Function$3, node2.name + "(");
    this.children(node2);
    this.token(RightParenthesis$1, ")");
  }
}
const PseudoElementSelector$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$X,
  name: name$1E,
  parse: parse$X,
  structure: structure$S,
  walkContext: walkContext$d
}, Symbol.toStringTag, { value: "Module" }));
const SOLIDUS$8 = 47;
function consumeTerm() {
  this.skipSC();
  switch (this.tokenType) {
    case Number$5:
      return this.Number();
    case Function$3:
      return this.Function(this.readSequence, this.scope.Value);
    default:
      this.error("Number of function is expected");
  }
}
const name$1D = "Ratio";
const structure$R = {
  left: ["Number", "Function"],
  right: ["Number", "Function", null]
};
function parse$W() {
  const start = this.tokenStart;
  const left = consumeTerm.call(this);
  let right = null;
  this.skipSC();
  if (this.isDelim(SOLIDUS$8)) {
    this.eatDelim(SOLIDUS$8);
    right = consumeTerm.call(this);
  }
  return {
    type: "Ratio",
    loc: this.getLocation(start, this.tokenStart),
    left,
    right
  };
}
function generate$W(node2) {
  this.node(node2.left);
  this.token(Delim$1, "/");
  if (node2.right) {
    this.node(node2.right);
  } else {
    this.node(Number$5, 1);
  }
}
const Ratio$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$W,
  name: name$1D,
  parse: parse$W,
  structure: structure$R
}, Symbol.toStringTag, { value: "Module" }));
function getOffsetExcludeWS$1() {
  if (this.tokenIndex > 0) {
    if (this.lookupType(-1) === WhiteSpace$3) {
      return this.tokenIndex > 1 ? this.getTokenStart(this.tokenIndex - 1) : this.firstCharOffset;
    }
  }
  return this.tokenStart;
}
const name$1C = "Raw";
const structure$Q = {
  value: String
};
function parse$V(consumeUntil, excludeWhiteSpace) {
  const startOffset = this.getTokenStart(this.tokenIndex);
  let endOffset;
  this.skipUntilBalanced(this.tokenIndex, consumeUntil || this.consumeUntilBalanceEnd);
  if (excludeWhiteSpace && this.tokenStart > startOffset) {
    endOffset = getOffsetExcludeWS$1.call(this);
  } else {
    endOffset = this.tokenStart;
  }
  return {
    type: "Raw",
    loc: this.getLocation(startOffset, endOffset),
    value: this.substring(startOffset, endOffset)
  };
}
function generate$V(node2) {
  this.tokenize(node2.value);
}
const Raw$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$V,
  name: name$1C,
  parse: parse$V,
  structure: structure$Q
}, Symbol.toStringTag, { value: "Module" }));
function consumeRaw$7() {
  return this.Raw(this.consumeUntilLeftCurlyBracket, true);
}
function consumePrelude$1() {
  const prelude = this.SelectorList();
  if (prelude.type !== "Raw" && this.eof === false && this.tokenType !== LeftCurlyBracket$1) {
    this.error();
  }
  return prelude;
}
const name$1B = "Rule";
const walkContext$c = "rule";
const structure$P = {
  prelude: ["SelectorList", "Raw"],
  block: ["Block"]
};
function parse$U() {
  const startToken = this.tokenIndex;
  const startOffset = this.tokenStart;
  let prelude;
  let block;
  if (this.parseRulePrelude) {
    prelude = this.parseWithFallback(consumePrelude$1, consumeRaw$7);
  } else {
    prelude = consumeRaw$7.call(this, startToken);
  }
  block = this.Block(true);
  return {
    type: "Rule",
    loc: this.getLocation(startOffset, this.tokenStart),
    prelude,
    block
  };
}
function generate$U(node2) {
  this.node(node2.prelude);
  this.node(node2.block);
}
const Rule$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$U,
  name: name$1B,
  parse: parse$U,
  structure: structure$P,
  walkContext: walkContext$c
}, Symbol.toStringTag, { value: "Module" }));
const name$1A = "Scope";
const structure$O = {
  root: ["SelectorList", "Raw", null],
  limit: ["SelectorList", "Raw", null]
};
function parse$T() {
  let root = null;
  let limit = null;
  this.skipSC();
  const startOffset = this.tokenStart;
  if (this.tokenType === LeftParenthesis$1) {
    this.next();
    this.skipSC();
    root = this.parseWithFallback(
      this.SelectorList,
      () => this.Raw(false, true)
    );
    this.skipSC();
    this.eat(RightParenthesis$1);
  }
  if (this.lookupNonWSType(0) === Ident$1) {
    this.skipSC();
    this.eatIdent("to");
    this.skipSC();
    this.eat(LeftParenthesis$1);
    this.skipSC();
    limit = this.parseWithFallback(
      this.SelectorList,
      () => this.Raw(false, true)
    );
    this.skipSC();
    this.eat(RightParenthesis$1);
  }
  return {
    type: "Scope",
    loc: this.getLocation(startOffset, this.tokenStart),
    root,
    limit
  };
}
function generate$T(node2) {
  if (node2.root) {
    this.token(LeftParenthesis$1, "(");
    this.node(node2.root);
    this.token(RightParenthesis$1, ")");
  }
  if (node2.limit) {
    this.token(Ident$1, "to");
    this.token(LeftParenthesis$1, "(");
    this.node(node2.limit);
    this.token(RightParenthesis$1, ")");
  }
}
const Scope = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$T,
  name: name$1A,
  parse: parse$T,
  structure: structure$O
}, Symbol.toStringTag, { value: "Module" }));
const name$1z = "Selector";
const structure$N = {
  children: [[
    "TypeSelector",
    "IdSelector",
    "ClassSelector",
    "AttributeSelector",
    "PseudoClassSelector",
    "PseudoElementSelector",
    "Combinator"
  ]]
};
function parse$S() {
  const children = this.readSequence(this.scope.Selector);
  if (this.getFirstListNode(children) === null) {
    this.error("Selector is expected");
  }
  return {
    type: "Selector",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate$S(node2) {
  this.children(node2);
}
const Selector$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$S,
  name: name$1z,
  parse: parse$S,
  structure: structure$N
}, Symbol.toStringTag, { value: "Module" }));
const name$1y = "SelectorList";
const walkContext$b = "selector";
const structure$M = {
  children: [[
    "Selector",
    "Raw"
  ]]
};
function parse$R() {
  const children = this.createList();
  while (!this.eof) {
    children.push(this.Selector());
    if (this.tokenType === Comma$1) {
      this.next();
      continue;
    }
    break;
  }
  return {
    type: "SelectorList",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate$R(node2) {
  this.children(node2, () => this.token(Comma$1, ","));
}
const SelectorList$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$R,
  name: name$1y,
  parse: parse$R,
  structure: structure$M,
  walkContext: walkContext$b
}, Symbol.toStringTag, { value: "Module" }));
const REVERSE_SOLIDUS$3 = 92;
const QUOTATION_MARK$3 = 34;
const APOSTROPHE$4 = 39;
function decode$3(str) {
  const len = str.length;
  const firstChar = str.charCodeAt(0);
  const start = firstChar === QUOTATION_MARK$3 || firstChar === APOSTROPHE$4 ? 1 : 0;
  const end = start === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar ? len - 2 : len - 1;
  let decoded = "";
  for (let i = start; i <= end; i++) {
    let code2 = str.charCodeAt(i);
    if (code2 === REVERSE_SOLIDUS$3) {
      if (i === end) {
        if (i !== len - 1) {
          decoded = str.substr(i + 1);
        }
        break;
      }
      code2 = str.charCodeAt(++i);
      if (isValidEscape$1(REVERSE_SOLIDUS$3, code2)) {
        const escapeStart = i - 1;
        const escapeEnd = consumeEscaped$1(str, escapeStart);
        i = escapeEnd - 1;
        decoded += decodeEscaped$1(str.substring(escapeStart + 1, escapeEnd));
      } else {
        if (code2 === 13 && str.charCodeAt(i + 1) === 10) {
          i++;
        }
      }
    } else {
      decoded += str[i];
    }
  }
  return decoded;
}
function encode$3(str, apostrophe) {
  const quote = '"';
  const quoteCode = QUOTATION_MARK$3;
  let encoded = "";
  let wsBeforeHexIsNeeded = false;
  for (let i = 0; i < str.length; i++) {
    const code2 = str.charCodeAt(i);
    if (code2 === 0) {
      encoded += "�";
      continue;
    }
    if (code2 <= 31 || code2 === 127) {
      encoded += "\\" + code2.toString(16);
      wsBeforeHexIsNeeded = true;
      continue;
    }
    if (code2 === quoteCode || code2 === REVERSE_SOLIDUS$3) {
      encoded += "\\" + str.charAt(i);
      wsBeforeHexIsNeeded = false;
    } else {
      if (wsBeforeHexIsNeeded && (isHexDigit$1(code2) || isWhiteSpace$2(code2))) {
        encoded += " ";
      }
      encoded += str.charAt(i);
      wsBeforeHexIsNeeded = false;
    }
  }
  return quote + encoded + quote;
}
const name$1x = "String";
const structure$L = {
  value: String
};
function parse$Q() {
  return {
    type: "String",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    value: decode$3(this.consume(String$4))
  };
}
function generate$Q(node2) {
  this.token(String$4, encode$3(node2.value));
}
const String$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$Q,
  name: name$1x,
  parse: parse$Q,
  structure: structure$L
}, Symbol.toStringTag, { value: "Module" }));
const EXCLAMATIONMARK$4 = 33;
function consumeRaw$6() {
  return this.Raw(null, false);
}
const name$1w = "StyleSheet";
const walkContext$a = "stylesheet";
const structure$K = {
  children: [[
    "Comment",
    "CDO",
    "CDC",
    "Atrule",
    "Rule",
    "Raw"
  ]]
};
function parse$P() {
  const start = this.tokenStart;
  const children = this.createList();
  let child;
  while (!this.eof) {
    switch (this.tokenType) {
      case WhiteSpace$3:
        this.next();
        continue;
      case Comment$3:
        if (this.charCodeAt(this.tokenStart + 2) !== EXCLAMATIONMARK$4) {
          this.next();
          continue;
        }
        child = this.Comment();
        break;
      case CDO$3:
        child = this.CDO();
        break;
      case CDC$3:
        child = this.CDC();
        break;
      // CSS Syntax Module Level 3
      // §2.2 Error handling
      // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
      case AtKeyword$1:
        child = this.parseWithFallback(this.Atrule, consumeRaw$6);
        break;
      // Anything else starts a qualified rule ...
      default:
        child = this.parseWithFallback(this.Rule, consumeRaw$6);
    }
    children.push(child);
  }
  return {
    type: "StyleSheet",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate$P(node2) {
  this.children(node2);
}
const StyleSheet$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$P,
  name: name$1w,
  parse: parse$P,
  structure: structure$K,
  walkContext: walkContext$a
}, Symbol.toStringTag, { value: "Module" }));
const name$1v = "SupportsDeclaration";
const structure$J = {
  declaration: "Declaration"
};
function parse$O() {
  const start = this.tokenStart;
  this.eat(LeftParenthesis$1);
  this.skipSC();
  const declaration = this.Declaration();
  if (!this.eof) {
    this.eat(RightParenthesis$1);
  }
  return {
    type: "SupportsDeclaration",
    loc: this.getLocation(start, this.tokenStart),
    declaration
  };
}
function generate$O(node2) {
  this.token(LeftParenthesis$1, "(");
  this.node(node2.declaration);
  this.token(RightParenthesis$1, ")");
}
const SupportsDeclaration = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$O,
  name: name$1v,
  parse: parse$O,
  structure: structure$J
}, Symbol.toStringTag, { value: "Module" }));
const ASTERISK$9 = 42;
const VERTICALLINE$5 = 124;
function eatIdentifierOrAsterisk$1() {
  if (this.tokenType !== Ident$1 && this.isDelim(ASTERISK$9) === false) {
    this.error("Identifier or asterisk is expected");
  }
  this.next();
}
const name$1u = "TypeSelector";
const structure$I = {
  name: String
};
function parse$N() {
  const start = this.tokenStart;
  if (this.isDelim(VERTICALLINE$5)) {
    this.next();
    eatIdentifierOrAsterisk$1.call(this);
  } else {
    eatIdentifierOrAsterisk$1.call(this);
    if (this.isDelim(VERTICALLINE$5)) {
      this.next();
      eatIdentifierOrAsterisk$1.call(this);
    }
  }
  return {
    type: "TypeSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: this.substrToCursor(start)
  };
}
function generate$N(node2) {
  this.tokenize(node2.name);
}
const TypeSelector$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$N,
  name: name$1u,
  parse: parse$N,
  structure: structure$I
}, Symbol.toStringTag, { value: "Module" }));
const PLUSSIGN$c = 43;
const HYPHENMINUS$8 = 45;
const QUESTIONMARK$3 = 63;
function eatHexSequence$1(offset, allowDash) {
  let len = 0;
  for (let pos = this.tokenStart + offset; pos < this.tokenEnd; pos++) {
    const code2 = this.charCodeAt(pos);
    if (code2 === HYPHENMINUS$8 && allowDash && len !== 0) {
      eatHexSequence$1.call(this, offset + len + 1, false);
      return -1;
    }
    if (!isHexDigit$1(code2)) {
      this.error(
        allowDash && len !== 0 ? "Hyphen minus" + (len < 6 ? " or hex digit" : "") + " is expected" : len < 6 ? "Hex digit is expected" : "Unexpected input",
        pos
      );
    }
    if (++len > 6) {
      this.error("Too many hex digits", pos);
    }
  }
  this.next();
  return len;
}
function eatQuestionMarkSequence$1(max) {
  let count = 0;
  while (this.isDelim(QUESTIONMARK$3)) {
    if (++count > max) {
      this.error("Too many question marks");
    }
    this.next();
  }
}
function startsWith$2(code2) {
  if (this.charCodeAt(this.tokenStart) !== code2) {
    this.error((code2 === PLUSSIGN$c ? "Plus sign" : "Hyphen minus") + " is expected");
  }
}
function scanUnicodeRange$1() {
  let hexLength = 0;
  switch (this.tokenType) {
    case Number$5:
      hexLength = eatHexSequence$1.call(this, 1, true);
      if (this.isDelim(QUESTIONMARK$3)) {
        eatQuestionMarkSequence$1.call(this, 6 - hexLength);
        break;
      }
      if (this.tokenType === Dimension$3 || this.tokenType === Number$5) {
        startsWith$2.call(this, HYPHENMINUS$8);
        eatHexSequence$1.call(this, 1, false);
        break;
      }
      break;
    case Dimension$3:
      hexLength = eatHexSequence$1.call(this, 1, true);
      if (hexLength > 0) {
        eatQuestionMarkSequence$1.call(this, 6 - hexLength);
      }
      break;
    default:
      this.eatDelim(PLUSSIGN$c);
      if (this.tokenType === Ident$1) {
        hexLength = eatHexSequence$1.call(this, 0, true);
        if (hexLength > 0) {
          eatQuestionMarkSequence$1.call(this, 6 - hexLength);
        }
        break;
      }
      if (this.isDelim(QUESTIONMARK$3)) {
        this.next();
        eatQuestionMarkSequence$1.call(this, 5);
        break;
      }
      this.error("Hex digit or question mark is expected");
  }
}
const name$1t = "UnicodeRange";
const structure$H = {
  value: String
};
function parse$M() {
  const start = this.tokenStart;
  this.eatIdent("u");
  scanUnicodeRange$1.call(this);
  return {
    type: "UnicodeRange",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substrToCursor(start)
  };
}
function generate$M(node2) {
  this.tokenize(node2.value);
}
const UnicodeRange$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$M,
  name: name$1t,
  parse: parse$M,
  structure: structure$H
}, Symbol.toStringTag, { value: "Module" }));
const SPACE$5 = 32;
const REVERSE_SOLIDUS$2 = 92;
const QUOTATION_MARK$2 = 34;
const APOSTROPHE$3 = 39;
const LEFTPARENTHESIS$3 = 40;
const RIGHTPARENTHESIS$3 = 41;
function decode$2(str) {
  const len = str.length;
  let start = 4;
  let end = str.charCodeAt(len - 1) === RIGHTPARENTHESIS$3 ? len - 2 : len - 1;
  let decoded = "";
  while (start < end && isWhiteSpace$2(str.charCodeAt(start))) {
    start++;
  }
  while (start < end && isWhiteSpace$2(str.charCodeAt(end))) {
    end--;
  }
  for (let i = start; i <= end; i++) {
    let code2 = str.charCodeAt(i);
    if (code2 === REVERSE_SOLIDUS$2) {
      if (i === end) {
        if (i !== len - 1) {
          decoded = str.substr(i + 1);
        }
        break;
      }
      code2 = str.charCodeAt(++i);
      if (isValidEscape$1(REVERSE_SOLIDUS$2, code2)) {
        const escapeStart = i - 1;
        const escapeEnd = consumeEscaped$1(str, escapeStart);
        i = escapeEnd - 1;
        decoded += decodeEscaped$1(str.substring(escapeStart + 1, escapeEnd));
      } else {
        if (code2 === 13 && str.charCodeAt(i + 1) === 10) {
          i++;
        }
      }
    } else {
      decoded += str[i];
    }
  }
  return decoded;
}
function encode$2(str) {
  let encoded = "";
  let wsBeforeHexIsNeeded = false;
  for (let i = 0; i < str.length; i++) {
    const code2 = str.charCodeAt(i);
    if (code2 === 0) {
      encoded += "�";
      continue;
    }
    if (code2 <= 31 || code2 === 127) {
      encoded += "\\" + code2.toString(16);
      wsBeforeHexIsNeeded = true;
      continue;
    }
    if (code2 === SPACE$5 || code2 === REVERSE_SOLIDUS$2 || code2 === QUOTATION_MARK$2 || code2 === APOSTROPHE$3 || code2 === LEFTPARENTHESIS$3 || code2 === RIGHTPARENTHESIS$3) {
      encoded += "\\" + str.charAt(i);
      wsBeforeHexIsNeeded = false;
    } else {
      if (wsBeforeHexIsNeeded && isHexDigit$1(code2)) {
        encoded += " ";
      }
      encoded += str.charAt(i);
      wsBeforeHexIsNeeded = false;
    }
  }
  return "url(" + encoded + ")";
}
const name$1s = "Url";
const structure$G = {
  value: String
};
function parse$L() {
  const start = this.tokenStart;
  let value2;
  switch (this.tokenType) {
    case Url$4:
      value2 = decode$2(this.consume(Url$4));
      break;
    case Function$3:
      if (!this.cmpStr(this.tokenStart, this.tokenEnd, "url(")) {
        this.error("Function name must be `url`");
      }
      this.eat(Function$3);
      this.skipSC();
      value2 = decode$3(this.consume(String$4));
      this.skipSC();
      if (!this.eof) {
        this.eat(RightParenthesis$1);
      }
      break;
    default:
      this.error("Url or Function is expected");
  }
  return {
    type: "Url",
    loc: this.getLocation(start, this.tokenStart),
    value: value2
  };
}
function generate$L(node2) {
  this.token(Url$4, encode$2(node2.value));
}
const Url$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$L,
  name: name$1s,
  parse: parse$L,
  structure: structure$G
}, Symbol.toStringTag, { value: "Module" }));
const name$1r = "Value";
const structure$F = {
  children: [[]]
};
function parse$K() {
  const start = this.tokenStart;
  const children = this.readSequence(this.scope.Value);
  return {
    type: "Value",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate$K(node2) {
  this.children(node2);
}
const Value$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$K,
  name: name$1r,
  parse: parse$K,
  structure: structure$F
}, Symbol.toStringTag, { value: "Module" }));
const SPACE$4 = Object.freeze({
  type: "WhiteSpace",
  loc: null,
  value: " "
});
const name$1q = "WhiteSpace";
const structure$E = {
  value: String
};
function parse$J() {
  this.eat(WhiteSpace$3);
  return SPACE$4;
}
function generate$J(node2) {
  this.token(WhiteSpace$3, node2.value);
}
const WhiteSpace$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$J,
  name: name$1q,
  parse: parse$J,
  structure: structure$E
}, Symbol.toStringTag, { value: "Module" }));
const node$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AnPlusB: AnPlusB$1,
  Atrule: Atrule$2,
  AtrulePrelude: AtrulePrelude$1,
  AttributeSelector: AttributeSelector$2,
  Block: Block$1,
  Brackets: Brackets$1,
  CDC: CDC$2,
  CDO: CDO$2,
  ClassSelector: ClassSelector$1,
  Combinator: Combinator$1,
  Comment: Comment$2,
  Condition,
  Declaration: Declaration$1,
  DeclarationList: DeclarationList$1,
  Dimension: Dimension$2,
  Feature,
  FeatureFunction,
  FeatureRange,
  Function: Function$2,
  GeneralEnclosed,
  Hash: Hash$2,
  IdSelector: IdSelector$1,
  Identifier: Identifier$1,
  Layer,
  LayerList,
  MediaQuery: MediaQuery$1,
  MediaQueryList: MediaQueryList$1,
  NestingSelector,
  Nth: Nth$1,
  Number: Number$4,
  Operator: Operator$1,
  Parentheses: Parentheses$1,
  Percentage: Percentage$2,
  PseudoClassSelector: PseudoClassSelector$1,
  PseudoElementSelector: PseudoElementSelector$1,
  Ratio: Ratio$1,
  Raw: Raw$1,
  Rule: Rule$1,
  Scope,
  Selector: Selector$1,
  SelectorList: SelectorList$1,
  String: String$3,
  StyleSheet: StyleSheet$1,
  SupportsDeclaration,
  TypeSelector: TypeSelector$1,
  UnicodeRange: UnicodeRange$1,
  Url: Url$3,
  Value: Value$1,
  WhiteSpace: WhiteSpace$2
}, Symbol.toStringTag, { value: "Module" }));
const lexerConfig$1 = {
  generic: true,
  cssWideKeywords: cssWideKeywords$1,
  ...definitions$1,
  node: node$3
};
const NUMBERSIGN$6 = 35;
const ASTERISK$8 = 42;
const PLUSSIGN$b = 43;
const HYPHENMINUS$7 = 45;
const SOLIDUS$7 = 47;
const U$2 = 117;
function defaultRecognizer$1(context) {
  switch (this.tokenType) {
    case Hash$3:
      return this.Hash();
    case Comma$1:
      return this.Operator();
    case LeftParenthesis$1:
      return this.Parentheses(this.readSequence, context.recognizer);
    case LeftSquareBracket$1:
      return this.Brackets(this.readSequence, context.recognizer);
    case String$4:
      return this.String();
    case Dimension$3:
      return this.Dimension();
    case Percentage$3:
      return this.Percentage();
    case Number$5:
      return this.Number();
    case Function$3:
      return this.cmpStr(this.tokenStart, this.tokenEnd, "url(") ? this.Url() : this.Function(this.readSequence, context.recognizer);
    case Url$4:
      return this.Url();
    case Ident$1:
      if (this.cmpChar(this.tokenStart, U$2) && this.cmpChar(this.tokenStart + 1, PLUSSIGN$b)) {
        return this.UnicodeRange();
      } else {
        return this.Identifier();
      }
    case Delim$1: {
      const code2 = this.charCodeAt(this.tokenStart);
      if (code2 === SOLIDUS$7 || code2 === ASTERISK$8 || code2 === PLUSSIGN$b || code2 === HYPHENMINUS$7) {
        return this.Operator();
      }
      if (code2 === NUMBERSIGN$6) {
        this.error("Hex or identifier is expected", this.tokenStart + 1);
      }
      break;
    }
  }
}
const atrulePrelude$1 = {
  getNode: defaultRecognizer$1
};
const NUMBERSIGN$5 = 35;
const AMPERSAND$2 = 38;
const ASTERISK$7 = 42;
const PLUSSIGN$a = 43;
const SOLIDUS$6 = 47;
const FULLSTOP$3 = 46;
const GREATERTHANSIGN$3 = 62;
const VERTICALLINE$4 = 124;
const TILDE$3 = 126;
function onWhiteSpace$1(next, children) {
  if (children.last !== null && children.last.type !== "Combinator" && next !== null && next.type !== "Combinator") {
    children.push({
      // FIXME: this.Combinator() should be used instead
      type: "Combinator",
      loc: null,
      name: " "
    });
  }
}
function getNode$1() {
  switch (this.tokenType) {
    case LeftSquareBracket$1:
      return this.AttributeSelector();
    case Hash$3:
      return this.IdSelector();
    case Colon$1:
      if (this.lookupType(1) === Colon$1) {
        return this.PseudoElementSelector();
      } else {
        return this.PseudoClassSelector();
      }
    case Ident$1:
      return this.TypeSelector();
    case Number$5:
    case Percentage$3:
      return this.Percentage();
    case Dimension$3:
      if (this.charCodeAt(this.tokenStart) === FULLSTOP$3) {
        this.error("Identifier is expected", this.tokenStart + 1);
      }
      break;
    case Delim$1: {
      const code2 = this.charCodeAt(this.tokenStart);
      switch (code2) {
        case PLUSSIGN$a:
        case GREATERTHANSIGN$3:
        case TILDE$3:
        case SOLIDUS$6:
          return this.Combinator();
        case FULLSTOP$3:
          return this.ClassSelector();
        case ASTERISK$7:
        case VERTICALLINE$4:
          return this.TypeSelector();
        case NUMBERSIGN$5:
          return this.IdSelector();
        case AMPERSAND$2:
          return this.NestingSelector();
      }
      break;
    }
  }
}
const selector$3 = {
  onWhiteSpace: onWhiteSpace$1,
  getNode: getNode$1
};
function expressionFn$1() {
  return this.createSingleNodeList(
    this.Raw(null, false)
  );
}
function varFn$1() {
  const children = this.createList();
  this.skipSC();
  children.push(this.Identifier());
  this.skipSC();
  if (this.tokenType === Comma$1) {
    children.push(this.Operator());
    const startIndex = this.tokenIndex;
    const value2 = this.parseCustomProperty ? this.Value(null) : this.Raw(this.consumeUntilExclamationMarkOrSemicolon, false);
    if (value2.type === "Value" && value2.children.isEmpty) {
      for (let offset = startIndex - this.tokenIndex; offset <= 0; offset++) {
        if (this.lookupType(offset) === WhiteSpace$3) {
          value2.children.appendData({
            type: "WhiteSpace",
            loc: null,
            value: " "
          });
          break;
        }
      }
    }
    children.push(value2);
  }
  return children;
}
function isPlusMinusOperator$1(node2) {
  return node2 !== null && node2.type === "Operator" && (node2.value[node2.value.length - 1] === "-" || node2.value[node2.value.length - 1] === "+");
}
const value$1 = {
  getNode: defaultRecognizer$1,
  onWhiteSpace(next, children) {
    if (isPlusMinusOperator$1(next)) {
      next.value = " " + next.value;
    }
    if (isPlusMinusOperator$1(children.last)) {
      children.last.value += " ";
    }
  },
  "expression": expressionFn$1,
  "var": varFn$1
};
const scope$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AtrulePrelude: atrulePrelude$1,
  Selector: selector$3,
  Value: value$1
}, Symbol.toStringTag, { value: "Module" }));
const nonContainerNameKeywords = /* @__PURE__ */ new Set(["none", "and", "not", "or"]);
const container = {
  parse: {
    prelude() {
      const children = this.createList();
      if (this.tokenType === Ident$1) {
        const name2 = this.substring(this.tokenStart, this.tokenEnd);
        if (!nonContainerNameKeywords.has(name2.toLowerCase())) {
          children.push(this.Identifier());
        }
      }
      children.push(this.Condition("container"));
      return children;
    },
    block(nested = false) {
      return this.Block(nested);
    }
  }
};
const fontFace$1 = {
  parse: {
    prelude: null,
    block() {
      return this.Block(true);
    }
  }
};
function parseWithFallback(parse2, fallback) {
  return this.parseWithFallback(
    () => {
      try {
        return parse2.call(this);
      } finally {
        this.skipSC();
        if (this.lookupNonWSType(0) !== RightParenthesis$1) {
          this.error();
        }
      }
    },
    fallback || (() => this.Raw(null, true))
  );
}
const parseFunctions = {
  layer() {
    this.skipSC();
    const children = this.createList();
    const node2 = parseWithFallback.call(this, this.Layer);
    if (node2.type !== "Raw" || node2.value !== "") {
      children.push(node2);
    }
    return children;
  },
  supports() {
    this.skipSC();
    const children = this.createList();
    const node2 = parseWithFallback.call(
      this,
      this.Declaration,
      () => parseWithFallback.call(this, () => this.Condition("supports"))
    );
    if (node2.type !== "Raw" || node2.value !== "") {
      children.push(node2);
    }
    return children;
  }
};
const importAtrule$1 = {
  parse: {
    prelude() {
      const children = this.createList();
      switch (this.tokenType) {
        case String$4:
          children.push(this.String());
          break;
        case Url$4:
        case Function$3:
          children.push(this.Url());
          break;
        default:
          this.error("String or url() is expected");
      }
      this.skipSC();
      if (this.tokenType === Ident$1 && this.cmpStr(this.tokenStart, this.tokenEnd, "layer")) {
        children.push(this.Identifier());
      } else if (this.tokenType === Function$3 && this.cmpStr(this.tokenStart, this.tokenEnd, "layer(")) {
        children.push(this.Function(null, parseFunctions));
      }
      this.skipSC();
      if (this.tokenType === Function$3 && this.cmpStr(this.tokenStart, this.tokenEnd, "supports(")) {
        children.push(this.Function(null, parseFunctions));
      }
      if (this.lookupNonWSType(0) === Ident$1 || this.lookupNonWSType(0) === LeftParenthesis$1) {
        children.push(this.MediaQueryList());
      }
      return children;
    },
    block: null
  }
};
const layer = {
  parse: {
    prelude() {
      return this.createSingleNodeList(
        this.LayerList()
      );
    },
    block() {
      return this.Block(false);
    }
  }
};
const media$1 = {
  parse: {
    prelude() {
      return this.createSingleNodeList(
        this.MediaQueryList()
      );
    },
    block(nested = false) {
      return this.Block(nested);
    }
  }
};
const nest = {
  parse: {
    prelude() {
      return this.createSingleNodeList(
        this.SelectorList()
      );
    },
    block() {
      return this.Block(true);
    }
  }
};
const page$1 = {
  parse: {
    prelude() {
      return this.createSingleNodeList(
        this.SelectorList()
      );
    },
    block() {
      return this.Block(true);
    }
  }
};
const scope$1 = {
  parse: {
    prelude() {
      return this.createSingleNodeList(
        this.Scope()
      );
    },
    block(nested = false) {
      return this.Block(nested);
    }
  }
};
const startingStyle = {
  parse: {
    prelude: null,
    block(nested = false) {
      return this.Block(nested);
    }
  }
};
const supports$1 = {
  parse: {
    prelude() {
      return this.createSingleNodeList(
        this.Condition("supports")
      );
    },
    block(nested = false) {
      return this.Block(nested);
    }
  }
};
const atrule$1 = {
  container,
  "font-face": fontFace$1,
  import: importAtrule$1,
  layer,
  media: media$1,
  nest,
  page: page$1,
  scope: scope$1,
  "starting-style": startingStyle,
  supports: supports$1
};
function parseLanguageRangeList() {
  const children = this.createList();
  this.skipSC();
  loop: while (!this.eof) {
    switch (this.tokenType) {
      case Ident$1:
        children.push(this.Identifier());
        break;
      case String$4:
        children.push(this.String());
        break;
      case Comma$1:
        children.push(this.Operator());
        break;
      case RightParenthesis$1:
        break loop;
      default:
        this.error("Identifier, string or comma is expected");
    }
    this.skipSC();
  }
  return children;
}
const selectorList$1 = {
  parse() {
    return this.createSingleNodeList(
      this.SelectorList()
    );
  }
};
const selector$2 = {
  parse() {
    return this.createSingleNodeList(
      this.Selector()
    );
  }
};
const identList$1 = {
  parse() {
    return this.createSingleNodeList(
      this.Identifier()
    );
  }
};
const langList = {
  parse: parseLanguageRangeList
};
const nth$1 = {
  parse() {
    return this.createSingleNodeList(
      this.Nth()
    );
  }
};
const pseudo$1 = {
  "dir": identList$1,
  "has": selectorList$1,
  "lang": langList,
  "matches": selectorList$1,
  "is": selectorList$1,
  "-moz-any": selectorList$1,
  "-webkit-any": selectorList$1,
  "where": selectorList$1,
  "not": selectorList$1,
  "nth-child": nth$1,
  "nth-last-child": nth$1,
  "nth-last-of-type": nth$1,
  "nth-of-type": nth$1,
  "slotted": selector$2,
  "host": selector$2,
  "host-context": selector$2
};
const node$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AnPlusB: parse$1t,
  Atrule: parse$1s,
  AtrulePrelude: parse$1r,
  AttributeSelector: parse$1q,
  Block: parse$1p,
  Brackets: parse$1o,
  CDC: parse$1n,
  CDO: parse$1m,
  ClassSelector: parse$1l,
  Combinator: parse$1k,
  Comment: parse$1j,
  Condition: parse$1i,
  Declaration: parse$1h,
  DeclarationList: parse$1g,
  Dimension: parse$1f,
  Feature: parse$1e,
  FeatureFunction: parse$1d,
  FeatureRange: parse$1c,
  Function: parse$1b,
  GeneralEnclosed: parse$1a,
  Hash: parse$19,
  IdSelector: parse$17,
  Identifier: parse$18,
  Layer: parse$16,
  LayerList: parse$15,
  MediaQuery: parse$14,
  MediaQueryList: parse$13,
  NestingSelector: parse$12,
  Nth: parse$11,
  Number: parse$10,
  Operator: parse$$,
  Parentheses: parse$_,
  Percentage: parse$Z,
  PseudoClassSelector: parse$Y,
  PseudoElementSelector: parse$X,
  Ratio: parse$W,
  Raw: parse$V,
  Rule: parse$U,
  Scope: parse$T,
  Selector: parse$S,
  SelectorList: parse$R,
  String: parse$Q,
  StyleSheet: parse$P,
  SupportsDeclaration: parse$O,
  TypeSelector: parse$N,
  UnicodeRange: parse$M,
  Url: parse$L,
  Value: parse$K,
  WhiteSpace: parse$J
}, Symbol.toStringTag, { value: "Module" }));
const parserConfig$1 = {
  parseContext: {
    default: "StyleSheet",
    stylesheet: "StyleSheet",
    atrule: "Atrule",
    atrulePrelude(options) {
      return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
    },
    mediaQueryList: "MediaQueryList",
    mediaQuery: "MediaQuery",
    condition(options) {
      return this.Condition(options.kind);
    },
    rule: "Rule",
    selectorList: "SelectorList",
    selector: "Selector",
    block() {
      return this.Block(true);
    },
    declarationList: "DeclarationList",
    declaration: "Declaration",
    value: "Value"
  },
  features: {
    supports: {
      selector() {
        return this.Selector();
      }
    },
    container: {
      style() {
        return this.Declaration();
      }
    }
  },
  scope: scope$2,
  atrule: atrule$1,
  pseudo: pseudo$1,
  node: node$2
};
const walkerConfig$1 = {
  node: node$3
};
const syntax$2 = createSyntax$3({
  ...lexerConfig$1,
  ...parserConfig$1,
  ...walkerConfig$1
});
function clone$1(node2) {
  const result = {};
  for (const key of Object.keys(node2)) {
    let value2 = node2[key];
    if (value2) {
      if (Array.isArray(value2) || value2 instanceof List$1) {
        value2 = value2.map(clone$1);
      } else if (value2.constructor === Object) {
        value2 = clone$1(value2);
      }
    }
    result[key] = value2;
  }
  return result;
}
const {
  tokenize: tokenize$3,
  parse: parse$I,
  generate: generate$I,
  lexer: lexer$2,
  createLexer: createLexer$1,
  walk: walk$3,
  find: find$2,
  findLast: findLast$2,
  findAll: findAll$2,
  toPlainObject: toPlainObject$2,
  fromPlainObject: fromPlainObject$2,
  fork: fork$1
} = syntax$2;
const EOF$1 = 0;
const Ident = 1;
const Function$1 = 2;
const AtKeyword = 3;
const Hash$1 = 4;
const String$2 = 5;
const BadString = 6;
const Url$2 = 7;
const BadUrl = 8;
const Delim = 9;
const Number$3 = 10;
const Percentage$1 = 11;
const Dimension$1 = 12;
const WhiteSpace$1 = 13;
const CDO$1 = 14;
const CDC$1 = 15;
const Colon = 16;
const Semicolon = 17;
const Comma = 18;
const LeftSquareBracket = 19;
const RightSquareBracket = 20;
const LeftParenthesis = 21;
const RightParenthesis = 22;
const LeftCurlyBracket = 23;
const RightCurlyBracket = 24;
const Comment$1 = 25;
const EOF = 0;
function isDigit$1(code2) {
  return code2 >= 48 && code2 <= 57;
}
function isHexDigit(code2) {
  return isDigit$1(code2) || // 0 .. 9
  code2 >= 65 && code2 <= 70 || // A .. F
  code2 >= 97 && code2 <= 102;
}
function isUppercaseLetter(code2) {
  return code2 >= 65 && code2 <= 90;
}
function isLowercaseLetter(code2) {
  return code2 >= 97 && code2 <= 122;
}
function isLetter(code2) {
  return isUppercaseLetter(code2) || isLowercaseLetter(code2);
}
function isNonAscii(code2) {
  return code2 >= 128;
}
function isNameStart(code2) {
  return isLetter(code2) || isNonAscii(code2) || code2 === 95;
}
function isName(code2) {
  return isNameStart(code2) || isDigit$1(code2) || code2 === 45;
}
function isNonPrintable(code2) {
  return code2 >= 0 && code2 <= 8 || code2 === 11 || code2 >= 14 && code2 <= 31 || code2 === 127;
}
function isNewline(code2) {
  return code2 === 10 || code2 === 13 || code2 === 12;
}
function isWhiteSpace$1(code2) {
  return isNewline(code2) || code2 === 32 || code2 === 9;
}
function isValidEscape(first, second) {
  if (first !== 92) {
    return false;
  }
  if (isNewline(second) || second === EOF) {
    return false;
  }
  return true;
}
function isIdentifierStart(first, second, third) {
  if (first === 45) {
    return isNameStart(second) || second === 45 || isValidEscape(second, third);
  }
  if (isNameStart(first)) {
    return true;
  }
  if (first === 92) {
    return isValidEscape(first, second);
  }
  return false;
}
function isNumberStart(first, second, third) {
  if (first === 43 || first === 45) {
    if (isDigit$1(second)) {
      return 2;
    }
    return second === 46 && isDigit$1(third) ? 3 : 0;
  }
  if (first === 46) {
    return isDigit$1(second) ? 2 : 0;
  }
  if (isDigit$1(first)) {
    return 1;
  }
  return 0;
}
function isBOM(code2) {
  if (code2 === 65279) {
    return 1;
  }
  if (code2 === 65534) {
    return 1;
  }
  return 0;
}
const CATEGORY = new Array(128);
const EofCategory = 128;
const WhiteSpaceCategory = 130;
const DigitCategory = 131;
const NameStartCategory = 132;
const NonPrintableCategory = 133;
for (let i = 0; i < CATEGORY.length; i++) {
  CATEGORY[i] = isWhiteSpace$1(i) && WhiteSpaceCategory || isDigit$1(i) && DigitCategory || isNameStart(i) && NameStartCategory || isNonPrintable(i) && NonPrintableCategory || i || EofCategory;
}
function charCodeCategory(code2) {
  return code2 < 128 ? CATEGORY[code2] : NameStartCategory;
}
function getCharCode(source, offset) {
  return offset < source.length ? source.charCodeAt(offset) : 0;
}
function getNewlineLength(source, offset, code2) {
  if (code2 === 13 && getCharCode(source, offset + 1) === 10) {
    return 2;
  }
  return 1;
}
function cmpChar(testStr, offset, referenceCode) {
  let code2 = testStr.charCodeAt(offset);
  if (isUppercaseLetter(code2)) {
    code2 = code2 | 32;
  }
  return code2 === referenceCode;
}
function cmpStr(testStr, start, end, referenceStr) {
  if (end - start !== referenceStr.length) {
    return false;
  }
  if (start < 0 || end > testStr.length) {
    return false;
  }
  for (let i = start; i < end; i++) {
    const referenceCode = referenceStr.charCodeAt(i - start);
    let testCode = testStr.charCodeAt(i);
    if (isUppercaseLetter(testCode)) {
      testCode = testCode | 32;
    }
    if (testCode !== referenceCode) {
      return false;
    }
  }
  return true;
}
function findWhiteSpaceStart(source, offset) {
  for (; offset >= 0; offset--) {
    if (!isWhiteSpace$1(source.charCodeAt(offset))) {
      break;
    }
  }
  return offset + 1;
}
function findWhiteSpaceEnd(source, offset) {
  for (; offset < source.length; offset++) {
    if (!isWhiteSpace$1(source.charCodeAt(offset))) {
      break;
    }
  }
  return offset;
}
function findDecimalNumberEnd(source, offset) {
  for (; offset < source.length; offset++) {
    if (!isDigit$1(source.charCodeAt(offset))) {
      break;
    }
  }
  return offset;
}
function consumeEscaped(source, offset) {
  offset += 2;
  if (isHexDigit(getCharCode(source, offset - 1))) {
    for (const maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
      if (!isHexDigit(getCharCode(source, offset))) {
        break;
      }
    }
    const code2 = getCharCode(source, offset);
    if (isWhiteSpace$1(code2)) {
      offset += getNewlineLength(source, offset, code2);
    }
  }
  return offset;
}
function consumeName(source, offset) {
  for (; offset < source.length; offset++) {
    const code2 = source.charCodeAt(offset);
    if (isName(code2)) {
      continue;
    }
    if (isValidEscape(code2, getCharCode(source, offset + 1))) {
      offset = consumeEscaped(source, offset) - 1;
      continue;
    }
    break;
  }
  return offset;
}
function consumeNumber$1(source, offset) {
  let code2 = source.charCodeAt(offset);
  if (code2 === 43 || code2 === 45) {
    code2 = source.charCodeAt(offset += 1);
  }
  if (isDigit$1(code2)) {
    offset = findDecimalNumberEnd(source, offset + 1);
    code2 = source.charCodeAt(offset);
  }
  if (code2 === 46 && isDigit$1(source.charCodeAt(offset + 1))) {
    offset += 2;
    offset = findDecimalNumberEnd(source, offset);
  }
  if (cmpChar(
    source,
    offset,
    101
    /* e */
  )) {
    let sign = 0;
    code2 = source.charCodeAt(offset + 1);
    if (code2 === 45 || code2 === 43) {
      sign = 1;
      code2 = source.charCodeAt(offset + 2);
    }
    if (isDigit$1(code2)) {
      offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
    }
  }
  return offset;
}
function consumeBadUrlRemnants(source, offset) {
  for (; offset < source.length; offset++) {
    const code2 = source.charCodeAt(offset);
    if (code2 === 41) {
      offset++;
      break;
    }
    if (isValidEscape(code2, getCharCode(source, offset + 1))) {
      offset = consumeEscaped(source, offset);
    }
  }
  return offset;
}
function decodeEscaped(escaped) {
  if (escaped.length === 1 && !isHexDigit(escaped.charCodeAt(0))) {
    return escaped[0];
  }
  let code2 = parseInt(escaped, 16);
  if (code2 === 0 || // If this number is zero,
  code2 >= 55296 && code2 <= 57343 || // or is for a surrogate,
  code2 > 1114111) {
    code2 = 65533;
  }
  return String.fromCodePoint(code2);
}
const tokenNames = [
  "EOF-token",
  "ident-token",
  "function-token",
  "at-keyword-token",
  "hash-token",
  "string-token",
  "bad-string-token",
  "url-token",
  "bad-url-token",
  "delim-token",
  "number-token",
  "percentage-token",
  "dimension-token",
  "whitespace-token",
  "CDO-token",
  "CDC-token",
  "colon-token",
  "semicolon-token",
  "comma-token",
  "[-token",
  "]-token",
  "(-token",
  ")-token",
  "{-token",
  "}-token"
];
const MIN_SIZE = 16 * 1024;
function adoptBuffer(buffer2 = null, size) {
  if (buffer2 === null || buffer2.length < size) {
    return new Uint32Array(Math.max(size + 1024, MIN_SIZE));
  }
  return buffer2;
}
const N$4 = 10;
const F$2 = 12;
const R$2 = 13;
function computeLinesAndColumns(host) {
  const source = host.source;
  const sourceLength = source.length;
  const startOffset = source.length > 0 ? isBOM(source.charCodeAt(0)) : 0;
  const lines = adoptBuffer(host.lines, sourceLength);
  const columns = adoptBuffer(host.columns, sourceLength);
  let line = host.startLine;
  let column = host.startColumn;
  for (let i = startOffset; i < sourceLength; i++) {
    const code2 = source.charCodeAt(i);
    lines[i] = line;
    columns[i] = column++;
    if (code2 === N$4 || code2 === R$2 || code2 === F$2) {
      if (code2 === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$4) {
        i++;
        lines[i] = line;
        columns[i] = column;
      }
      line++;
      column = 1;
    }
  }
  lines[sourceLength] = line;
  columns[sourceLength] = column;
  host.lines = lines;
  host.columns = columns;
  host.computed = true;
}
class OffsetToLocation2 {
  constructor() {
    this.lines = null;
    this.columns = null;
    this.computed = false;
  }
  setSource(source, startOffset = 0, startLine = 1, startColumn = 1) {
    this.source = source;
    this.startOffset = startOffset;
    this.startLine = startLine;
    this.startColumn = startColumn;
    this.computed = false;
  }
  getLocation(offset, filename) {
    if (!this.computed) {
      computeLinesAndColumns(this);
    }
    return {
      source: filename,
      offset: this.startOffset + offset,
      line: this.lines[offset],
      column: this.columns[offset]
    };
  }
  getLocationRange(start, end, filename) {
    if (!this.computed) {
      computeLinesAndColumns(this);
    }
    return {
      source: filename,
      start: {
        offset: this.startOffset + start,
        line: this.lines[start],
        column: this.columns[start]
      },
      end: {
        offset: this.startOffset + end,
        line: this.lines[end],
        column: this.columns[end]
      }
    };
  }
}
const OFFSET_MASK = 16777215;
const TYPE_SHIFT = 24;
const balancePair$1 = /* @__PURE__ */ new Map([
  [Function$1, RightParenthesis],
  [LeftParenthesis, RightParenthesis],
  [LeftSquareBracket, RightSquareBracket],
  [LeftCurlyBracket, RightCurlyBracket]
]);
class TokenStream2 {
  constructor(source, tokenize2) {
    this.setSource(source, tokenize2);
  }
  reset() {
    this.eof = false;
    this.tokenIndex = -1;
    this.tokenType = 0;
    this.tokenStart = this.firstCharOffset;
    this.tokenEnd = this.firstCharOffset;
  }
  setSource(source = "", tokenize2 = () => {
  }) {
    source = String(source || "");
    const sourceLength = source.length;
    const offsetAndType = adoptBuffer(this.offsetAndType, source.length + 1);
    const balance = adoptBuffer(this.balance, source.length + 1);
    let tokenCount = 0;
    let balanceCloseType = 0;
    let balanceStart = 0;
    let firstCharOffset = -1;
    this.offsetAndType = null;
    this.balance = null;
    tokenize2(source, (type, start, end) => {
      switch (type) {
        default:
          balance[tokenCount] = sourceLength;
          break;
        case balanceCloseType: {
          let balancePrev = balanceStart & OFFSET_MASK;
          balanceStart = balance[balancePrev];
          balanceCloseType = balanceStart >> TYPE_SHIFT;
          balance[tokenCount] = balancePrev;
          balance[balancePrev++] = tokenCount;
          for (; balancePrev < tokenCount; balancePrev++) {
            if (balance[balancePrev] === sourceLength) {
              balance[balancePrev] = tokenCount;
            }
          }
          break;
        }
        case LeftParenthesis:
        case Function$1:
        case LeftSquareBracket:
        case LeftCurlyBracket:
          balance[tokenCount] = balanceStart;
          balanceCloseType = balancePair$1.get(type);
          balanceStart = balanceCloseType << TYPE_SHIFT | tokenCount;
          break;
      }
      offsetAndType[tokenCount++] = type << TYPE_SHIFT | end;
      if (firstCharOffset === -1) {
        firstCharOffset = start;
      }
    });
    offsetAndType[tokenCount] = EOF$1 << TYPE_SHIFT | sourceLength;
    balance[tokenCount] = sourceLength;
    balance[sourceLength] = sourceLength;
    while (balanceStart !== 0) {
      const balancePrev = balanceStart & OFFSET_MASK;
      balanceStart = balance[balancePrev];
      balance[balancePrev] = sourceLength;
    }
    this.source = source;
    this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;
    this.tokenCount = tokenCount;
    this.offsetAndType = offsetAndType;
    this.balance = balance;
    this.reset();
    this.next();
  }
  lookupType(offset) {
    offset += this.tokenIndex;
    if (offset < this.tokenCount) {
      return this.offsetAndType[offset] >> TYPE_SHIFT;
    }
    return EOF$1;
  }
  lookupOffset(offset) {
    offset += this.tokenIndex;
    if (offset < this.tokenCount) {
      return this.offsetAndType[offset - 1] & OFFSET_MASK;
    }
    return this.source.length;
  }
  lookupValue(offset, referenceStr) {
    offset += this.tokenIndex;
    if (offset < this.tokenCount) {
      return cmpStr(
        this.source,
        this.offsetAndType[offset - 1] & OFFSET_MASK,
        this.offsetAndType[offset] & OFFSET_MASK,
        referenceStr
      );
    }
    return false;
  }
  getTokenStart(tokenIndex) {
    if (tokenIndex === this.tokenIndex) {
      return this.tokenStart;
    }
    if (tokenIndex > 0) {
      return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
    }
    return this.firstCharOffset;
  }
  substrToCursor(start) {
    return this.source.substring(start, this.tokenStart);
  }
  isBalanceEdge(pos) {
    return this.balance[this.tokenIndex] < pos;
  }
  isDelim(code2, offset) {
    if (offset) {
      return this.lookupType(offset) === Delim && this.source.charCodeAt(this.lookupOffset(offset)) === code2;
    }
    return this.tokenType === Delim && this.source.charCodeAt(this.tokenStart) === code2;
  }
  skip(tokenCount) {
    let next = this.tokenIndex + tokenCount;
    if (next < this.tokenCount) {
      this.tokenIndex = next;
      this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
      next = this.offsetAndType[next];
      this.tokenType = next >> TYPE_SHIFT;
      this.tokenEnd = next & OFFSET_MASK;
    } else {
      this.tokenIndex = this.tokenCount;
      this.next();
    }
  }
  next() {
    let next = this.tokenIndex + 1;
    if (next < this.tokenCount) {
      this.tokenIndex = next;
      this.tokenStart = this.tokenEnd;
      next = this.offsetAndType[next];
      this.tokenType = next >> TYPE_SHIFT;
      this.tokenEnd = next & OFFSET_MASK;
    } else {
      this.eof = true;
      this.tokenIndex = this.tokenCount;
      this.tokenType = EOF$1;
      this.tokenStart = this.tokenEnd = this.source.length;
    }
  }
  skipSC() {
    while (this.tokenType === WhiteSpace$1 || this.tokenType === Comment$1) {
      this.next();
    }
  }
  skipUntilBalanced(startToken, stopConsume) {
    let cursor = startToken;
    let balanceEnd;
    let offset;
    loop:
      for (; cursor < this.tokenCount; cursor++) {
        balanceEnd = this.balance[cursor];
        if (balanceEnd < startToken) {
          break loop;
        }
        offset = cursor > 0 ? this.offsetAndType[cursor - 1] & OFFSET_MASK : this.firstCharOffset;
        switch (stopConsume(this.source.charCodeAt(offset))) {
          case 1:
            break loop;
          case 2:
            cursor++;
            break loop;
          default:
            if (this.balance[balanceEnd] === cursor) {
              cursor = balanceEnd;
            }
        }
      }
    this.skip(cursor - this.tokenIndex);
  }
  forEachToken(fn2) {
    for (let i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {
      const start = offset;
      const item = this.offsetAndType[i];
      const end = item & OFFSET_MASK;
      const type = item >> TYPE_SHIFT;
      offset = end;
      fn2(type, start, end, i);
    }
  }
  dump() {
    const tokens = new Array(this.tokenCount);
    this.forEachToken((type, start, end, index) => {
      tokens[index] = {
        idx: index,
        type: tokenNames[type],
        chunk: this.source.substring(start, end),
        balance: this.balance[index]
      };
    });
    return tokens;
  }
}
function tokenize$2(source, onToken) {
  function getCharCode2(offset2) {
    return offset2 < sourceLength ? source.charCodeAt(offset2) : 0;
  }
  function consumeNumericToken() {
    offset = consumeNumber$1(source, offset);
    if (isIdentifierStart(getCharCode2(offset), getCharCode2(offset + 1), getCharCode2(offset + 2))) {
      type = Dimension$1;
      offset = consumeName(source, offset);
      return;
    }
    if (getCharCode2(offset) === 37) {
      type = Percentage$1;
      offset++;
      return;
    }
    type = Number$3;
  }
  function consumeIdentLikeToken() {
    const nameStartOffset = offset;
    offset = consumeName(source, offset);
    if (cmpStr(source, nameStartOffset, offset, "url") && getCharCode2(offset) === 40) {
      offset = findWhiteSpaceEnd(source, offset + 1);
      if (getCharCode2(offset) === 34 || getCharCode2(offset) === 39) {
        type = Function$1;
        offset = nameStartOffset + 4;
        return;
      }
      consumeUrlToken();
      return;
    }
    if (getCharCode2(offset) === 40) {
      type = Function$1;
      offset++;
      return;
    }
    type = Ident;
  }
  function consumeStringToken(endingCodePoint) {
    if (!endingCodePoint) {
      endingCodePoint = getCharCode2(offset++);
    }
    type = String$2;
    for (; offset < source.length; offset++) {
      const code2 = source.charCodeAt(offset);
      switch (charCodeCategory(code2)) {
        // ending code point
        case endingCodePoint:
          offset++;
          return;
        // EOF
        // case EofCategory:
        // This is a parse error. Return the <string-token>.
        // return;
        // newline
        case WhiteSpaceCategory:
          if (isNewline(code2)) {
            offset += getNewlineLength(source, offset, code2);
            type = BadString;
            return;
          }
          break;
        // U+005C REVERSE SOLIDUS (\)
        case 92:
          if (offset === source.length - 1) {
            break;
          }
          const nextCode = getCharCode2(offset + 1);
          if (isNewline(nextCode)) {
            offset += getNewlineLength(source, offset + 1, nextCode);
          } else if (isValidEscape(code2, nextCode)) {
            offset = consumeEscaped(source, offset) - 1;
          }
          break;
      }
    }
  }
  function consumeUrlToken() {
    type = Url$2;
    offset = findWhiteSpaceEnd(source, offset);
    for (; offset < source.length; offset++) {
      const code2 = source.charCodeAt(offset);
      switch (charCodeCategory(code2)) {
        // U+0029 RIGHT PARENTHESIS ())
        case 41:
          offset++;
          return;
        // EOF
        // case EofCategory:
        // This is a parse error. Return the <url-token>.
        // return;
        // whitespace
        case WhiteSpaceCategory:
          offset = findWhiteSpaceEnd(source, offset);
          if (getCharCode2(offset) === 41 || offset >= source.length) {
            if (offset < source.length) {
              offset++;
            }
            return;
          }
          offset = consumeBadUrlRemnants(source, offset);
          type = BadUrl;
          return;
        // U+0022 QUOTATION MARK (")
        // U+0027 APOSTROPHE (')
        // U+0028 LEFT PARENTHESIS (()
        // non-printable code point
        case 34:
        case 39:
        case 40:
        case NonPrintableCategory:
          offset = consumeBadUrlRemnants(source, offset);
          type = BadUrl;
          return;
        // U+005C REVERSE SOLIDUS (\)
        case 92:
          if (isValidEscape(code2, getCharCode2(offset + 1))) {
            offset = consumeEscaped(source, offset) - 1;
            break;
          }
          offset = consumeBadUrlRemnants(source, offset);
          type = BadUrl;
          return;
      }
    }
  }
  source = String(source || "");
  const sourceLength = source.length;
  let start = isBOM(getCharCode2(0));
  let offset = start;
  let type;
  while (offset < sourceLength) {
    const code2 = source.charCodeAt(offset);
    switch (charCodeCategory(code2)) {
      // whitespace
      case WhiteSpaceCategory:
        type = WhiteSpace$1;
        offset = findWhiteSpaceEnd(source, offset + 1);
        break;
      // U+0022 QUOTATION MARK (")
      case 34:
        consumeStringToken();
        break;
      // U+0023 NUMBER SIGN (#)
      case 35:
        if (isName(getCharCode2(offset + 1)) || isValidEscape(getCharCode2(offset + 1), getCharCode2(offset + 2))) {
          type = Hash$1;
          offset = consumeName(source, offset + 1);
        } else {
          type = Delim;
          offset++;
        }
        break;
      // U+0027 APOSTROPHE (')
      case 39:
        consumeStringToken();
        break;
      // U+0028 LEFT PARENTHESIS (()
      case 40:
        type = LeftParenthesis;
        offset++;
        break;
      // U+0029 RIGHT PARENTHESIS ())
      case 41:
        type = RightParenthesis;
        offset++;
        break;
      // U+002B PLUS SIGN (+)
      case 43:
        if (isNumberStart(code2, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
          consumeNumericToken();
        } else {
          type = Delim;
          offset++;
        }
        break;
      // U+002C COMMA (,)
      case 44:
        type = Comma;
        offset++;
        break;
      // U+002D HYPHEN-MINUS (-)
      case 45:
        if (isNumberStart(code2, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
          consumeNumericToken();
        } else {
          if (getCharCode2(offset + 1) === 45 && getCharCode2(offset + 2) === 62) {
            type = CDC$1;
            offset = offset + 3;
          } else {
            if (isIdentifierStart(code2, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
              consumeIdentLikeToken();
            } else {
              type = Delim;
              offset++;
            }
          }
        }
        break;
      // U+002E FULL STOP (.)
      case 46:
        if (isNumberStart(code2, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
          consumeNumericToken();
        } else {
          type = Delim;
          offset++;
        }
        break;
      // U+002F SOLIDUS (/)
      case 47:
        if (getCharCode2(offset + 1) === 42) {
          type = Comment$1;
          offset = source.indexOf("*/", offset + 2);
          offset = offset === -1 ? source.length : offset + 2;
        } else {
          type = Delim;
          offset++;
        }
        break;
      // U+003A COLON (:)
      case 58:
        type = Colon;
        offset++;
        break;
      // U+003B SEMICOLON (;)
      case 59:
        type = Semicolon;
        offset++;
        break;
      // U+003C LESS-THAN SIGN (<)
      case 60:
        if (getCharCode2(offset + 1) === 33 && getCharCode2(offset + 2) === 45 && getCharCode2(offset + 3) === 45) {
          type = CDO$1;
          offset = offset + 4;
        } else {
          type = Delim;
          offset++;
        }
        break;
      // U+0040 COMMERCIAL AT (@)
      case 64:
        if (isIdentifierStart(getCharCode2(offset + 1), getCharCode2(offset + 2), getCharCode2(offset + 3))) {
          type = AtKeyword;
          offset = consumeName(source, offset + 1);
        } else {
          type = Delim;
          offset++;
        }
        break;
      // U+005B LEFT SQUARE BRACKET ([)
      case 91:
        type = LeftSquareBracket;
        offset++;
        break;
      // U+005C REVERSE SOLIDUS (\)
      case 92:
        if (isValidEscape(code2, getCharCode2(offset + 1))) {
          consumeIdentLikeToken();
        } else {
          type = Delim;
          offset++;
        }
        break;
      // U+005D RIGHT SQUARE BRACKET (])
      case 93:
        type = RightSquareBracket;
        offset++;
        break;
      // U+007B LEFT CURLY BRACKET ({)
      case 123:
        type = LeftCurlyBracket;
        offset++;
        break;
      // U+007D RIGHT CURLY BRACKET (})
      case 125:
        type = RightCurlyBracket;
        offset++;
        break;
      // digit
      case DigitCategory:
        consumeNumericToken();
        break;
      // name-start code point
      case NameStartCategory:
        consumeIdentLikeToken();
        break;
      // EOF
      // case EofCategory:
      // Return an <EOF-token>.
      // break;
      // anything else
      default:
        type = Delim;
        offset++;
    }
    onToken(type, start, start = offset);
  }
}
let releasedCursors = null;
class List2 {
  static createItem(data) {
    return {
      prev: null,
      next: null,
      data
    };
  }
  constructor() {
    this.head = null;
    this.tail = null;
    this.cursor = null;
  }
  createItem(data) {
    return List2.createItem(data);
  }
  // cursor helpers
  allocateCursor(prev, next) {
    let cursor;
    if (releasedCursors !== null) {
      cursor = releasedCursors;
      releasedCursors = releasedCursors.cursor;
      cursor.prev = prev;
      cursor.next = next;
      cursor.cursor = this.cursor;
    } else {
      cursor = {
        prev,
        next,
        cursor: this.cursor
      };
    }
    this.cursor = cursor;
    return cursor;
  }
  releaseCursor() {
    const { cursor } = this;
    this.cursor = cursor.cursor;
    cursor.prev = null;
    cursor.next = null;
    cursor.cursor = releasedCursors;
    releasedCursors = cursor;
  }
  updateCursors(prevOld, prevNew, nextOld, nextNew) {
    let { cursor } = this;
    while (cursor !== null) {
      if (cursor.prev === prevOld) {
        cursor.prev = prevNew;
      }
      if (cursor.next === nextOld) {
        cursor.next = nextNew;
      }
      cursor = cursor.cursor;
    }
  }
  *[Symbol.iterator]() {
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      yield cursor.data;
    }
  }
  // getters
  get size() {
    let size = 0;
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      size++;
    }
    return size;
  }
  get isEmpty() {
    return this.head === null;
  }
  get first() {
    return this.head && this.head.data;
  }
  get last() {
    return this.tail && this.tail.data;
  }
  // convertors
  fromArray(array) {
    let cursor = null;
    this.head = null;
    for (let data of array) {
      const item = List2.createItem(data);
      if (cursor !== null) {
        cursor.next = item;
      } else {
        this.head = item;
      }
      item.prev = cursor;
      cursor = item;
    }
    this.tail = cursor;
    return this;
  }
  toArray() {
    return [...this];
  }
  toJSON() {
    return [...this];
  }
  // array-like methods
  forEach(fn2, thisArg = this) {
    const cursor = this.allocateCursor(null, this.head);
    while (cursor.next !== null) {
      const item = cursor.next;
      cursor.next = item.next;
      fn2.call(thisArg, item.data, item, this);
    }
    this.releaseCursor();
  }
  forEachRight(fn2, thisArg = this) {
    const cursor = this.allocateCursor(this.tail, null);
    while (cursor.prev !== null) {
      const item = cursor.prev;
      cursor.prev = item.prev;
      fn2.call(thisArg, item.data, item, this);
    }
    this.releaseCursor();
  }
  reduce(fn2, initialValue, thisArg = this) {
    let cursor = this.allocateCursor(null, this.head);
    let acc = initialValue;
    let item;
    while (cursor.next !== null) {
      item = cursor.next;
      cursor.next = item.next;
      acc = fn2.call(thisArg, acc, item.data, item, this);
    }
    this.releaseCursor();
    return acc;
  }
  reduceRight(fn2, initialValue, thisArg = this) {
    let cursor = this.allocateCursor(this.tail, null);
    let acc = initialValue;
    let item;
    while (cursor.prev !== null) {
      item = cursor.prev;
      cursor.prev = item.prev;
      acc = fn2.call(thisArg, acc, item.data, item, this);
    }
    this.releaseCursor();
    return acc;
  }
  some(fn2, thisArg = this) {
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      if (fn2.call(thisArg, cursor.data, cursor, this)) {
        return true;
      }
    }
    return false;
  }
  map(fn2, thisArg = this) {
    const result = new List2();
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      result.appendData(fn2.call(thisArg, cursor.data, cursor, this));
    }
    return result;
  }
  filter(fn2, thisArg = this) {
    const result = new List2();
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      if (fn2.call(thisArg, cursor.data, cursor, this)) {
        result.appendData(cursor.data);
      }
    }
    return result;
  }
  nextUntil(start, fn2, thisArg = this) {
    if (start === null) {
      return;
    }
    const cursor = this.allocateCursor(null, start);
    while (cursor.next !== null) {
      const item = cursor.next;
      cursor.next = item.next;
      if (fn2.call(thisArg, item.data, item, this)) {
        break;
      }
    }
    this.releaseCursor();
  }
  prevUntil(start, fn2, thisArg = this) {
    if (start === null) {
      return;
    }
    const cursor = this.allocateCursor(start, null);
    while (cursor.prev !== null) {
      const item = cursor.prev;
      cursor.prev = item.prev;
      if (fn2.call(thisArg, item.data, item, this)) {
        break;
      }
    }
    this.releaseCursor();
  }
  // mutation
  clear() {
    this.head = null;
    this.tail = null;
  }
  copy() {
    const result = new List2();
    for (let data of this) {
      result.appendData(data);
    }
    return result;
  }
  prepend(item) {
    this.updateCursors(null, item, this.head, item);
    if (this.head !== null) {
      this.head.prev = item;
      item.next = this.head;
    } else {
      this.tail = item;
    }
    this.head = item;
    return this;
  }
  prependData(data) {
    return this.prepend(List2.createItem(data));
  }
  append(item) {
    return this.insert(item);
  }
  appendData(data) {
    return this.insert(List2.createItem(data));
  }
  insert(item, before = null) {
    if (before !== null) {
      this.updateCursors(before.prev, item, before, item);
      if (before.prev === null) {
        if (this.head !== before) {
          throw new Error("before doesn't belong to list");
        }
        this.head = item;
        before.prev = item;
        item.next = before;
        this.updateCursors(null, item);
      } else {
        before.prev.next = item;
        item.prev = before.prev;
        before.prev = item;
        item.next = before;
      }
    } else {
      this.updateCursors(this.tail, item, null, item);
      if (this.tail !== null) {
        this.tail.next = item;
        item.prev = this.tail;
      } else {
        this.head = item;
      }
      this.tail = item;
    }
    return this;
  }
  insertData(data, before) {
    return this.insert(List2.createItem(data), before);
  }
  remove(item) {
    this.updateCursors(item, item.prev, item, item.next);
    if (item.prev !== null) {
      item.prev.next = item.next;
    } else {
      if (this.head !== item) {
        throw new Error("item doesn't belong to list");
      }
      this.head = item.next;
    }
    if (item.next !== null) {
      item.next.prev = item.prev;
    } else {
      if (this.tail !== item) {
        throw new Error("item doesn't belong to list");
      }
      this.tail = item.prev;
    }
    item.prev = null;
    item.next = null;
    return item;
  }
  push(data) {
    this.insert(List2.createItem(data));
  }
  pop() {
    return this.tail !== null ? this.remove(this.tail) : null;
  }
  unshift(data) {
    this.prepend(List2.createItem(data));
  }
  shift() {
    return this.head !== null ? this.remove(this.head) : null;
  }
  prependList(list) {
    return this.insertList(list, this.head);
  }
  appendList(list) {
    return this.insertList(list);
  }
  insertList(list, before) {
    if (list.head === null) {
      return this;
    }
    if (before !== void 0 && before !== null) {
      this.updateCursors(before.prev, list.tail, before, list.head);
      if (before.prev !== null) {
        before.prev.next = list.head;
        list.head.prev = before.prev;
      } else {
        this.head = list.head;
      }
      before.prev = list.tail;
      list.tail.next = before;
    } else {
      this.updateCursors(this.tail, list.tail, null, list.head);
      if (this.tail !== null) {
        this.tail.next = list.head;
        list.head.prev = this.tail;
      } else {
        this.head = list.head;
      }
      this.tail = list.tail;
    }
    list.head = null;
    list.tail = null;
    return this;
  }
  replace(oldItem, newItemOrList) {
    if ("head" in newItemOrList) {
      this.insertList(newItemOrList, oldItem);
    } else {
      this.insert(newItemOrList, oldItem);
    }
    this.remove(oldItem);
  }
}
function createCustomError(name2, message) {
  const error2 = Object.create(SyntaxError.prototype);
  const errorStack = new Error();
  return Object.assign(error2, {
    name: name2,
    message,
    get stack() {
      return (errorStack.stack || "").replace(/^(.+\n){1,3}/, `${name2}: ${message}
`);
    }
  });
}
const MAX_LINE_LENGTH = 100;
const OFFSET_CORRECTION = 60;
const TAB_REPLACEMENT = "    ";
function sourceFragment({ source, line, column }, extraLines) {
  function processLines(start, end) {
    return lines.slice(start, end).map(
      (line2, idx) => String(start + idx + 1).padStart(maxNumLength) + " |" + line2
    ).join("\n");
  }
  const lines = source.split(/\r\n?|\n|\f/);
  const startLine = Math.max(1, line - extraLines) - 1;
  const endLine = Math.min(line + extraLines, lines.length + 1);
  const maxNumLength = Math.max(4, String(endLine).length) + 1;
  let cutLeft = 0;
  column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;
  if (column > MAX_LINE_LENGTH) {
    cutLeft = column - OFFSET_CORRECTION + 3;
    column = OFFSET_CORRECTION - 2;
  }
  for (let i = startLine; i <= endLine; i++) {
    if (i >= 0 && i < lines.length) {
      lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
      lines[i] = (cutLeft > 0 && lines[i].length > cutLeft ? "…" : "") + lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) + (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? "…" : "");
    }
  }
  return [
    processLines(startLine, line),
    new Array(column + maxNumLength + 2).join("-") + "^",
    processLines(line, endLine)
  ].filter(Boolean).join("\n");
}
function SyntaxError$2(message, source, offset, line, column) {
  const error2 = Object.assign(createCustomError("SyntaxError", message), {
    source,
    offset,
    line,
    column,
    sourceFragment(extraLines) {
      return sourceFragment({ source, line, column }, isNaN(extraLines) ? 0 : extraLines);
    },
    get formattedMessage() {
      return `Parse error: ${message}
` + sourceFragment({ source, line, column }, 2);
    }
  });
  return error2;
}
function readSequence$1(recognizer) {
  const children = this.createList();
  let space = false;
  const context = {
    recognizer
  };
  while (!this.eof) {
    switch (this.tokenType) {
      case Comment$1:
        this.next();
        continue;
      case WhiteSpace$1:
        space = true;
        this.next();
        continue;
    }
    let child = recognizer.getNode.call(this, context);
    if (child === void 0) {
      break;
    }
    if (space) {
      if (recognizer.onWhiteSpace) {
        recognizer.onWhiteSpace.call(this, child, children, context);
      }
      space = false;
    }
    children.push(child);
  }
  if (space && recognizer.onWhiteSpace) {
    recognizer.onWhiteSpace.call(this, null, children, context);
  }
  return children;
}
const NOOP = () => {
};
const EXCLAMATIONMARK$3 = 33;
const NUMBERSIGN$4 = 35;
const SEMICOLON = 59;
const LEFTCURLYBRACKET$1 = 123;
const NULL = 0;
function createParseContext(name2) {
  return function() {
    return this[name2]();
  };
}
function fetchParseValues(dict) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const name2 in dict) {
    const item = dict[name2];
    const fn2 = item.parse || item;
    if (fn2) {
      result[name2] = fn2;
    }
  }
  return result;
}
function processConfig(config) {
  const parseConfig = {
    context: /* @__PURE__ */ Object.create(null),
    scope: Object.assign(/* @__PURE__ */ Object.create(null), config.scope),
    atrule: fetchParseValues(config.atrule),
    pseudo: fetchParseValues(config.pseudo),
    node: fetchParseValues(config.node)
  };
  for (const name2 in config.parseContext) {
    switch (typeof config.parseContext[name2]) {
      case "function":
        parseConfig.context[name2] = config.parseContext[name2];
        break;
      case "string":
        parseConfig.context[name2] = createParseContext(config.parseContext[name2]);
        break;
    }
  }
  return {
    config: parseConfig,
    ...parseConfig,
    ...parseConfig.node
  };
}
function createParser(config) {
  let source = "";
  let filename = "<unknown>";
  let needPositions = false;
  let onParseError = NOOP;
  let onParseErrorThrow = false;
  const locationMap = new OffsetToLocation2();
  const parser = Object.assign(new TokenStream2(), processConfig(config || {}), {
    parseAtrulePrelude: true,
    parseRulePrelude: true,
    parseValue: true,
    parseCustomProperty: false,
    readSequence: readSequence$1,
    consumeUntilBalanceEnd: () => 0,
    consumeUntilLeftCurlyBracket(code2) {
      return code2 === LEFTCURLYBRACKET$1 ? 1 : 0;
    },
    consumeUntilLeftCurlyBracketOrSemicolon(code2) {
      return code2 === LEFTCURLYBRACKET$1 || code2 === SEMICOLON ? 1 : 0;
    },
    consumeUntilExclamationMarkOrSemicolon(code2) {
      return code2 === EXCLAMATIONMARK$3 || code2 === SEMICOLON ? 1 : 0;
    },
    consumeUntilSemicolonIncluded(code2) {
      return code2 === SEMICOLON ? 2 : 0;
    },
    createList() {
      return new List2();
    },
    createSingleNodeList(node2) {
      return new List2().appendData(node2);
    },
    getFirstListNode(list) {
      return list && list.first;
    },
    getLastListNode(list) {
      return list && list.last;
    },
    parseWithFallback(consumer, fallback) {
      const startToken = this.tokenIndex;
      try {
        return consumer.call(this);
      } catch (e) {
        if (onParseErrorThrow) {
          throw e;
        }
        const fallbackNode = fallback.call(this, startToken);
        onParseErrorThrow = true;
        onParseError(e, fallbackNode);
        onParseErrorThrow = false;
        return fallbackNode;
      }
    },
    lookupNonWSType(offset) {
      let type;
      do {
        type = this.lookupType(offset++);
        if (type !== WhiteSpace$1) {
          return type;
        }
      } while (type !== NULL);
      return NULL;
    },
    charCodeAt(offset) {
      return offset >= 0 && offset < source.length ? source.charCodeAt(offset) : 0;
    },
    substring(offsetStart, offsetEnd) {
      return source.substring(offsetStart, offsetEnd);
    },
    substrToCursor(start) {
      return this.source.substring(start, this.tokenStart);
    },
    cmpChar(offset, charCode) {
      return cmpChar(source, offset, charCode);
    },
    cmpStr(offsetStart, offsetEnd, str) {
      return cmpStr(source, offsetStart, offsetEnd, str);
    },
    consume(tokenType2) {
      const start = this.tokenStart;
      this.eat(tokenType2);
      return this.substrToCursor(start);
    },
    consumeFunctionName() {
      const name2 = source.substring(this.tokenStart, this.tokenEnd - 1);
      this.eat(Function$1);
      return name2;
    },
    consumeNumber(type) {
      const number2 = source.substring(this.tokenStart, consumeNumber$1(source, this.tokenStart));
      this.eat(type);
      return number2;
    },
    eat(tokenType2) {
      if (this.tokenType !== tokenType2) {
        const tokenName = tokenNames[tokenType2].slice(0, -6).replace(/-/g, " ").replace(/^./, (m) => m.toUpperCase());
        let message = `${/[[\](){}]/.test(tokenName) ? `"${tokenName}"` : tokenName} is expected`;
        let offset = this.tokenStart;
        switch (tokenType2) {
          case Ident:
            if (this.tokenType === Function$1 || this.tokenType === Url$2) {
              offset = this.tokenEnd - 1;
              message = "Identifier is expected but function found";
            } else {
              message = "Identifier is expected";
            }
            break;
          case Hash$1:
            if (this.isDelim(NUMBERSIGN$4)) {
              this.next();
              offset++;
              message = "Name is expected";
            }
            break;
          case Percentage$1:
            if (this.tokenType === Number$3) {
              offset = this.tokenEnd;
              message = "Percent sign is expected";
            }
            break;
        }
        this.error(message, offset);
      }
      this.next();
    },
    eatIdent(name2) {
      if (this.tokenType !== Ident || this.lookupValue(0, name2) === false) {
        this.error(`Identifier "${name2}" is expected`);
      }
      this.next();
    },
    eatDelim(code2) {
      if (!this.isDelim(code2)) {
        this.error(`Delim "${String.fromCharCode(code2)}" is expected`);
      }
      this.next();
    },
    getLocation(start, end) {
      if (needPositions) {
        return locationMap.getLocationRange(
          start,
          end,
          filename
        );
      }
      return null;
    },
    getLocationFromList(list) {
      if (needPositions) {
        const head = this.getFirstListNode(list);
        const tail = this.getLastListNode(list);
        return locationMap.getLocationRange(
          head !== null ? head.loc.start.offset - locationMap.startOffset : this.tokenStart,
          tail !== null ? tail.loc.end.offset - locationMap.startOffset : this.tokenStart,
          filename
        );
      }
      return null;
    },
    error(message, offset) {
      const location = typeof offset !== "undefined" && offset < source.length ? locationMap.getLocation(offset) : this.eof ? locationMap.getLocation(findWhiteSpaceStart(source, source.length - 1)) : locationMap.getLocation(this.tokenStart);
      throw new SyntaxError$2(
        message || "Unexpected input",
        source,
        location.offset,
        location.line,
        location.column
      );
    }
  });
  const parse2 = function(source_, options) {
    source = source_;
    options = options || {};
    parser.setSource(source, tokenize$2);
    locationMap.setSource(
      source,
      options.offset,
      options.line,
      options.column
    );
    filename = options.filename || "<unknown>";
    needPositions = Boolean(options.positions);
    onParseError = typeof options.onParseError === "function" ? options.onParseError : NOOP;
    onParseErrorThrow = false;
    parser.parseAtrulePrelude = "parseAtrulePrelude" in options ? Boolean(options.parseAtrulePrelude) : true;
    parser.parseRulePrelude = "parseRulePrelude" in options ? Boolean(options.parseRulePrelude) : true;
    parser.parseValue = "parseValue" in options ? Boolean(options.parseValue) : true;
    parser.parseCustomProperty = "parseCustomProperty" in options ? Boolean(options.parseCustomProperty) : false;
    const { context = "default", onComment } = options;
    if (context in parser.context === false) {
      throw new Error("Unknown context `" + context + "`");
    }
    if (typeof onComment === "function") {
      parser.forEachToken((type, start, end) => {
        if (type === Comment$1) {
          const loc = parser.getLocation(start, end);
          const value2 = cmpStr(source, end - 2, end, "*/") ? source.slice(start + 2, end - 2) : source.slice(start + 2, end);
          onComment(value2, loc);
        }
      });
    }
    const ast = parser.context[context].call(parser, options);
    if (!parser.eof) {
      parser.error();
    }
    return ast;
  };
  return Object.assign(parse2, {
    SyntaxError: SyntaxError$2,
    config: parser.config
  });
}
const trackNodes = /* @__PURE__ */ new Set(["Atrule", "Selector", "Declaration"]);
function generateSourceMap(handlers2) {
  const map = new sourceMapGeneratorExports.SourceMapGenerator();
  const generated = {
    line: 1,
    column: 0
  };
  const original = {
    line: 0,
    // should be zero to add first mapping
    column: 0
  };
  const activatedGenerated = {
    line: 1,
    column: 0
  };
  const activatedMapping = {
    generated: activatedGenerated
  };
  let line = 1;
  let column = 0;
  let sourceMappingActive = false;
  const origHandlersNode = handlers2.node;
  handlers2.node = function(node2) {
    if (node2.loc && node2.loc.start && trackNodes.has(node2.type)) {
      const nodeLine = node2.loc.start.line;
      const nodeColumn = node2.loc.start.column - 1;
      if (original.line !== nodeLine || original.column !== nodeColumn) {
        original.line = nodeLine;
        original.column = nodeColumn;
        generated.line = line;
        generated.column = column;
        if (sourceMappingActive) {
          sourceMappingActive = false;
          if (generated.line !== activatedGenerated.line || generated.column !== activatedGenerated.column) {
            map.addMapping(activatedMapping);
          }
        }
        sourceMappingActive = true;
        map.addMapping({
          source: node2.loc.source,
          original,
          generated
        });
      }
    }
    origHandlersNode.call(this, node2);
    if (sourceMappingActive && trackNodes.has(node2.type)) {
      activatedGenerated.line = line;
      activatedGenerated.column = column;
    }
  };
  const origHandlersEmit = handlers2.emit;
  handlers2.emit = function(value2, type, auto) {
    for (let i = 0; i < value2.length; i++) {
      if (value2.charCodeAt(i) === 10) {
        line++;
        column = 0;
      } else {
        column++;
      }
    }
    origHandlersEmit(value2, type, auto);
  };
  const origHandlersResult = handlers2.result;
  handlers2.result = function() {
    if (sourceMappingActive) {
      map.addMapping(activatedMapping);
    }
    return {
      css: origHandlersResult(),
      map
    };
  };
  return handlers2;
}
const PLUSSIGN$9 = 43;
const HYPHENMINUS$6 = 45;
const code = (type, value2) => {
  if (type === Delim) {
    type = value2;
  }
  if (typeof type === "string") {
    const charCode = type.charCodeAt(0);
    return charCode > 127 ? 32768 : charCode << 8;
  }
  return type;
};
const specPairs = [
  [Ident, Ident],
  [Ident, Function$1],
  [Ident, Url$2],
  [Ident, BadUrl],
  [Ident, "-"],
  [Ident, Number$3],
  [Ident, Percentage$1],
  [Ident, Dimension$1],
  [Ident, CDC$1],
  [Ident, LeftParenthesis],
  [AtKeyword, Ident],
  [AtKeyword, Function$1],
  [AtKeyword, Url$2],
  [AtKeyword, BadUrl],
  [AtKeyword, "-"],
  [AtKeyword, Number$3],
  [AtKeyword, Percentage$1],
  [AtKeyword, Dimension$1],
  [AtKeyword, CDC$1],
  [Hash$1, Ident],
  [Hash$1, Function$1],
  [Hash$1, Url$2],
  [Hash$1, BadUrl],
  [Hash$1, "-"],
  [Hash$1, Number$3],
  [Hash$1, Percentage$1],
  [Hash$1, Dimension$1],
  [Hash$1, CDC$1],
  [Dimension$1, Ident],
  [Dimension$1, Function$1],
  [Dimension$1, Url$2],
  [Dimension$1, BadUrl],
  [Dimension$1, "-"],
  [Dimension$1, Number$3],
  [Dimension$1, Percentage$1],
  [Dimension$1, Dimension$1],
  [Dimension$1, CDC$1],
  ["#", Ident],
  ["#", Function$1],
  ["#", Url$2],
  ["#", BadUrl],
  ["#", "-"],
  ["#", Number$3],
  ["#", Percentage$1],
  ["#", Dimension$1],
  ["#", CDC$1],
  // https://github.com/w3c/csswg-drafts/pull/6874
  ["-", Ident],
  ["-", Function$1],
  ["-", Url$2],
  ["-", BadUrl],
  ["-", "-"],
  ["-", Number$3],
  ["-", Percentage$1],
  ["-", Dimension$1],
  ["-", CDC$1],
  // https://github.com/w3c/csswg-drafts/pull/6874
  [Number$3, Ident],
  [Number$3, Function$1],
  [Number$3, Url$2],
  [Number$3, BadUrl],
  [Number$3, Number$3],
  [Number$3, Percentage$1],
  [Number$3, Dimension$1],
  [Number$3, "%"],
  [Number$3, CDC$1],
  // https://github.com/w3c/csswg-drafts/pull/6874
  ["@", Ident],
  ["@", Function$1],
  ["@", Url$2],
  ["@", BadUrl],
  ["@", "-"],
  ["@", CDC$1],
  // https://github.com/w3c/csswg-drafts/pull/6874
  [".", Number$3],
  [".", Percentage$1],
  [".", Dimension$1],
  ["+", Number$3],
  ["+", Percentage$1],
  ["+", Dimension$1],
  ["/", "*"]
];
const safePairs = specPairs.concat([
  [Ident, Hash$1],
  [Dimension$1, Hash$1],
  [Hash$1, Hash$1],
  [AtKeyword, LeftParenthesis],
  [AtKeyword, String$2],
  [AtKeyword, Colon],
  [Percentage$1, Percentage$1],
  [Percentage$1, Dimension$1],
  [Percentage$1, Function$1],
  [Percentage$1, "-"],
  [RightParenthesis, Ident],
  [RightParenthesis, Function$1],
  [RightParenthesis, Percentage$1],
  [RightParenthesis, Dimension$1],
  [RightParenthesis, Hash$1],
  [RightParenthesis, "-"]
]);
function createMap(pairs) {
  const isWhiteSpaceRequired = new Set(
    pairs.map(([prev, next]) => code(prev) << 16 | code(next))
  );
  return function(prevCode, type, value2) {
    const nextCode = code(type, value2);
    const nextCharCode = value2.charCodeAt(0);
    const emitWs = nextCharCode === HYPHENMINUS$6 && type !== Ident && type !== Function$1 && type !== CDC$1 || nextCharCode === PLUSSIGN$9 ? isWhiteSpaceRequired.has(prevCode << 16 | nextCharCode << 8) : isWhiteSpaceRequired.has(prevCode << 16 | nextCode);
    if (emitWs) {
      this.emit(" ", WhiteSpace$1, true);
    }
    return nextCode;
  };
}
const spec = createMap(specPairs);
const safe = createMap(safePairs);
const tokenBefore = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  safe,
  spec
}, Symbol.toStringTag, { value: "Module" }));
const REVERSESOLIDUS = 92;
function processChildren(node2, delimeter) {
  if (typeof delimeter === "function") {
    let prev = null;
    node2.children.forEach((node3) => {
      if (prev !== null) {
        delimeter.call(this, prev);
      }
      this.node(node3);
      prev = node3;
    });
    return;
  }
  node2.children.forEach(this.node, this);
}
function processChunk(chunk) {
  tokenize$2(chunk, (type, start, end) => {
    this.token(type, chunk.slice(start, end));
  });
}
function createGenerator(config) {
  const types = /* @__PURE__ */ new Map();
  for (let name2 in config.node) {
    const item = config.node[name2];
    const fn2 = item.generate || item;
    if (typeof fn2 === "function") {
      types.set(name2, item.generate || item);
    }
  }
  return function(node2, options) {
    let buffer2 = "";
    let prevCode = 0;
    let handlers2 = {
      node(node3) {
        if (types.has(node3.type)) {
          types.get(node3.type).call(publicApi, node3);
        } else {
          throw new Error("Unknown node type: " + node3.type);
        }
      },
      tokenBefore: safe,
      token(type, value2) {
        prevCode = this.tokenBefore(prevCode, type, value2);
        this.emit(value2, type, false);
        if (type === Delim && value2.charCodeAt(0) === REVERSESOLIDUS) {
          this.emit("\n", WhiteSpace$1, true);
        }
      },
      emit(value2) {
        buffer2 += value2;
      },
      result() {
        return buffer2;
      }
    };
    if (options) {
      if (typeof options.decorator === "function") {
        handlers2 = options.decorator(handlers2);
      }
      if (options.sourceMap) {
        handlers2 = generateSourceMap(handlers2);
      }
      if (options.mode in tokenBefore) {
        handlers2.tokenBefore = tokenBefore[options.mode];
      }
    }
    const publicApi = {
      node: (node3) => handlers2.node(node3),
      children: processChildren,
      token: (type, value2) => handlers2.token(type, value2),
      tokenize: processChunk
    };
    handlers2.node(node2);
    return handlers2.result();
  };
}
function createConvertor(walk2) {
  return {
    fromPlainObject(ast) {
      walk2(ast, {
        enter(node2) {
          if (node2.children && node2.children instanceof List2 === false) {
            node2.children = new List2().fromArray(node2.children);
          }
        }
      });
      return ast;
    },
    toPlainObject(ast) {
      walk2(ast, {
        leave(node2) {
          if (node2.children && node2.children instanceof List2) {
            node2.children = node2.children.toArray();
          }
        }
      });
      return ast;
    }
  };
}
const { hasOwnProperty: hasOwnProperty$8 } = Object.prototype;
const noop$2 = function() {
};
function ensureFunction$1(value2) {
  return typeof value2 === "function" ? value2 : noop$2;
}
function invokeForType(fn2, type) {
  return function(node2, item, list) {
    if (node2.type === type) {
      fn2.call(this, node2, item, list);
    }
  };
}
function getWalkersFromStructure(name2, nodeType) {
  const structure2 = nodeType.structure;
  const walkers = [];
  for (const key in structure2) {
    if (hasOwnProperty$8.call(structure2, key) === false) {
      continue;
    }
    let fieldTypes = structure2[key];
    const walker = {
      name: key,
      type: false,
      nullable: false
    };
    if (!Array.isArray(fieldTypes)) {
      fieldTypes = [fieldTypes];
    }
    for (const fieldType of fieldTypes) {
      if (fieldType === null) {
        walker.nullable = true;
      } else if (typeof fieldType === "string") {
        walker.type = "node";
      } else if (Array.isArray(fieldType)) {
        walker.type = "list";
      }
    }
    if (walker.type) {
      walkers.push(walker);
    }
  }
  if (walkers.length) {
    return {
      context: nodeType.walkContext,
      fields: walkers
    };
  }
  return null;
}
function getTypesFromConfig(config) {
  const types = {};
  for (const name2 in config.node) {
    if (hasOwnProperty$8.call(config.node, name2)) {
      const nodeType = config.node[name2];
      if (!nodeType.structure) {
        throw new Error("Missed `structure` field in `" + name2 + "` node type definition");
      }
      types[name2] = getWalkersFromStructure(name2, nodeType);
    }
  }
  return types;
}
function createTypeIterator(config, reverse) {
  const fields = config.fields.slice();
  const contextName = config.context;
  const useContext = typeof contextName === "string";
  if (reverse) {
    fields.reverse();
  }
  return function(node2, context, walk2, walkReducer) {
    let prevContextValue;
    if (useContext) {
      prevContextValue = context[contextName];
      context[contextName] = node2;
    }
    for (const field of fields) {
      const ref = node2[field.name];
      if (!field.nullable || ref) {
        if (field.type === "list") {
          const breakWalk = reverse ? ref.reduceRight(walkReducer, false) : ref.reduce(walkReducer, false);
          if (breakWalk) {
            return true;
          }
        } else if (walk2(ref)) {
          return true;
        }
      }
    }
    if (useContext) {
      context[contextName] = prevContextValue;
    }
  };
}
function createFastTraveralMap({
  StyleSheet: StyleSheet2,
  Atrule: Atrule2,
  Rule: Rule2,
  Block: Block2,
  DeclarationList: DeclarationList2
}) {
  return {
    Atrule: {
      StyleSheet: StyleSheet2,
      Atrule: Atrule2,
      Rule: Rule2,
      Block: Block2
    },
    Rule: {
      StyleSheet: StyleSheet2,
      Atrule: Atrule2,
      Rule: Rule2,
      Block: Block2
    },
    Declaration: {
      StyleSheet: StyleSheet2,
      Atrule: Atrule2,
      Rule: Rule2,
      Block: Block2,
      DeclarationList: DeclarationList2
    }
  };
}
function createWalker(config) {
  const types = getTypesFromConfig(config);
  const iteratorsNatural = {};
  const iteratorsReverse = {};
  const breakWalk = Symbol("break-walk");
  const skipNode = Symbol("skip-node");
  for (const name2 in types) {
    if (hasOwnProperty$8.call(types, name2) && types[name2] !== null) {
      iteratorsNatural[name2] = createTypeIterator(types[name2], false);
      iteratorsReverse[name2] = createTypeIterator(types[name2], true);
    }
  }
  const fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
  const fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);
  const walk2 = function(root, options) {
    function walkNode(node2, item, list) {
      const enterRet = enter.call(context, node2, item, list);
      if (enterRet === breakWalk) {
        return true;
      }
      if (enterRet === skipNode) {
        return false;
      }
      if (iterators.hasOwnProperty(node2.type)) {
        if (iterators[node2.type](node2, context, walkNode, walkReducer)) {
          return true;
        }
      }
      if (leave.call(context, node2, item, list) === breakWalk) {
        return true;
      }
      return false;
    }
    let enter = noop$2;
    let leave = noop$2;
    let iterators = iteratorsNatural;
    let walkReducer = (ret, data, item, list) => ret || walkNode(data, item, list);
    const context = {
      break: breakWalk,
      skip: skipNode,
      root,
      stylesheet: null,
      atrule: null,
      atrulePrelude: null,
      rule: null,
      selector: null,
      block: null,
      declaration: null,
      function: null
    };
    if (typeof options === "function") {
      enter = options;
    } else if (options) {
      enter = ensureFunction$1(options.enter);
      leave = ensureFunction$1(options.leave);
      if (options.reverse) {
        iterators = iteratorsReverse;
      }
      if (options.visit) {
        if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
          iterators = options.reverse ? fastTraversalIteratorsReverse[options.visit] : fastTraversalIteratorsNatural[options.visit];
        } else if (!types.hasOwnProperty(options.visit)) {
          throw new Error("Bad value `" + options.visit + "` for `visit` option (should be: " + Object.keys(types).sort().join(", ") + ")");
        }
        enter = invokeForType(enter, options.visit);
        leave = invokeForType(leave, options.visit);
      }
    }
    if (enter === noop$2 && leave === noop$2) {
      throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
    }
    walkNode(root);
  };
  walk2.break = breakWalk;
  walk2.skip = skipNode;
  walk2.find = function(ast, fn2) {
    let found = null;
    walk2(ast, function(node2, item, list) {
      if (fn2.call(this, node2, item, list)) {
        found = node2;
        return breakWalk;
      }
    });
    return found;
  };
  walk2.findLast = function(ast, fn2) {
    let found = null;
    walk2(ast, {
      reverse: true,
      enter(node2, item, list) {
        if (fn2.call(this, node2, item, list)) {
          found = node2;
          return breakWalk;
        }
      }
    });
    return found;
  };
  walk2.findAll = function(ast, fn2) {
    const found = [];
    walk2(ast, function(node2, item, list) {
      if (fn2.call(this, node2, item, list)) {
        found.push(node2);
      }
    });
    return found;
  };
  return walk2;
}
function noop$1(value2) {
  return value2;
}
function generateMultiplier(multiplier) {
  const { min, max, comma } = multiplier;
  if (min === 0 && max === 0) {
    return comma ? "#?" : "*";
  }
  if (min === 0 && max === 1) {
    return "?";
  }
  if (min === 1 && max === 0) {
    return comma ? "#" : "+";
  }
  if (min === 1 && max === 1) {
    return "";
  }
  return (comma ? "#" : "") + (min === max ? "{" + min + "}" : "{" + min + "," + (max !== 0 ? max : "") + "}");
}
function generateTypeOpts(node2) {
  switch (node2.type) {
    case "Range":
      return " [" + (node2.min === null ? "-∞" : node2.min) + "," + (node2.max === null ? "∞" : node2.max) + "]";
    default:
      throw new Error("Unknown node type `" + node2.type + "`");
  }
}
function generateSequence(node2, decorate, forceBraces, compact) {
  const combinator = node2.combinator === " " || compact ? node2.combinator : " " + node2.combinator + " ";
  const result = node2.terms.map((term) => internalGenerate(term, decorate, forceBraces, compact)).join(combinator);
  if (node2.explicit || forceBraces) {
    return (compact || result[0] === "," ? "[" : "[ ") + result + (compact ? "]" : " ]");
  }
  return result;
}
function internalGenerate(node2, decorate, forceBraces, compact) {
  let result;
  switch (node2.type) {
    case "Group":
      result = generateSequence(node2, decorate, forceBraces, compact) + (node2.disallowEmpty ? "!" : "");
      break;
    case "Multiplier":
      return internalGenerate(node2.term, decorate, forceBraces, compact) + decorate(generateMultiplier(node2), node2);
    case "Type":
      result = "<" + node2.name + (node2.opts ? decorate(generateTypeOpts(node2.opts), node2.opts) : "") + ">";
      break;
    case "Property":
      result = "<'" + node2.name + "'>";
      break;
    case "Keyword":
      result = node2.name;
      break;
    case "AtKeyword":
      result = "@" + node2.name;
      break;
    case "Function":
      result = node2.name + "(";
      break;
    case "String":
    case "Token":
      result = node2.value;
      break;
    case "Comma":
      result = ",";
      break;
    default:
      throw new Error("Unknown node type `" + node2.type + "`");
  }
  return decorate(result, node2);
}
function generate$H(node2, options) {
  let decorate = noop$1;
  let forceBraces = false;
  let compact = false;
  if (typeof options === "function") {
    decorate = options;
  } else if (options) {
    forceBraces = Boolean(options.forceBraces);
    compact = Boolean(options.compact);
    if (typeof options.decorate === "function") {
      decorate = options.decorate;
    }
  }
  return internalGenerate(node2, decorate, forceBraces, compact);
}
const defaultLoc = { offset: 0, line: 1, column: 1 };
function locateMismatch(matchResult, node2) {
  const tokens = matchResult.tokens;
  const longestMatch = matchResult.longestMatch;
  const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
  const badNode = mismatchNode !== node2 ? mismatchNode : null;
  let mismatchOffset = 0;
  let mismatchLength = 0;
  let entries = 0;
  let css = "";
  let start;
  let end;
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i].value;
    if (i === longestMatch) {
      mismatchLength = token.length;
      mismatchOffset = css.length;
    }
    if (badNode !== null && tokens[i].node === badNode) {
      if (i <= longestMatch) {
        entries++;
      } else {
        entries = 0;
      }
    }
    css += token;
  }
  if (longestMatch === tokens.length || entries > 1) {
    start = fromLoc(badNode || node2, "end") || buildLoc(defaultLoc, css);
    end = buildLoc(start);
  } else {
    start = fromLoc(badNode, "start") || buildLoc(fromLoc(node2, "start") || defaultLoc, css.slice(0, mismatchOffset));
    end = fromLoc(badNode, "end") || buildLoc(start, css.substr(mismatchOffset, mismatchLength));
  }
  return {
    css,
    mismatchOffset,
    mismatchLength,
    start,
    end
  };
}
function fromLoc(node2, point) {
  const value2 = node2 && node2.loc && node2.loc[point];
  if (value2) {
    return "line" in value2 ? buildLoc(value2) : value2;
  }
  return null;
}
function buildLoc({ offset, line, column }, extra) {
  const loc = {
    offset,
    line,
    column
  };
  if (extra) {
    const lines = extra.split(/\n|\r\n?|\f/);
    loc.offset += extra.length;
    loc.line += lines.length - 1;
    loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
  }
  return loc;
}
const SyntaxReferenceError = function(type, referenceName) {
  const error2 = createCustomError(
    "SyntaxReferenceError",
    type + (referenceName ? " `" + referenceName + "`" : "")
  );
  error2.reference = referenceName;
  return error2;
};
const SyntaxMatchError = function(message, syntax2, node2, matchResult) {
  const error2 = createCustomError("SyntaxMatchError", message);
  const {
    css,
    mismatchOffset,
    mismatchLength,
    start,
    end
  } = locateMismatch(matchResult, node2);
  error2.rawMessage = message;
  error2.syntax = syntax2 ? generate$H(syntax2) : "<generic>";
  error2.css = css;
  error2.mismatchOffset = mismatchOffset;
  error2.mismatchLength = mismatchLength;
  error2.message = message + "\n  syntax: " + error2.syntax + "\n   value: " + (css || "<empty string>") + "\n  --------" + new Array(error2.mismatchOffset + 1).join("-") + "^";
  Object.assign(error2, start);
  error2.loc = {
    source: node2 && node2.loc && node2.loc.source || "<unknown>",
    start,
    end
  };
  return error2;
};
const keywords = /* @__PURE__ */ new Map();
const properties = /* @__PURE__ */ new Map();
const HYPHENMINUS$5 = 45;
const keyword = getKeywordDescriptor;
const property = getPropertyDescriptor;
function isCustomProperty(str, offset) {
  offset = offset || 0;
  return str.length - offset >= 2 && str.charCodeAt(offset) === HYPHENMINUS$5 && str.charCodeAt(offset + 1) === HYPHENMINUS$5;
}
function getVendorPrefix(str, offset) {
  offset = offset || 0;
  if (str.length - offset >= 3) {
    if (str.charCodeAt(offset) === HYPHENMINUS$5 && str.charCodeAt(offset + 1) !== HYPHENMINUS$5) {
      const secondDashIndex = str.indexOf("-", offset + 2);
      if (secondDashIndex !== -1) {
        return str.substring(offset, secondDashIndex + 1);
      }
    }
  }
  return "";
}
function getKeywordDescriptor(keyword2) {
  if (keywords.has(keyword2)) {
    return keywords.get(keyword2);
  }
  const name2 = keyword2.toLowerCase();
  let descriptor = keywords.get(name2);
  if (descriptor === void 0) {
    const custom = isCustomProperty(name2, 0);
    const vendor = !custom ? getVendorPrefix(name2, 0) : "";
    descriptor = Object.freeze({
      basename: name2.substr(vendor.length),
      name: name2,
      prefix: vendor,
      vendor,
      custom
    });
  }
  keywords.set(keyword2, descriptor);
  return descriptor;
}
function getPropertyDescriptor(property2) {
  if (properties.has(property2)) {
    return properties.get(property2);
  }
  let name2 = property2;
  let hack = property2[0];
  if (hack === "/") {
    hack = property2[1] === "/" ? "//" : "/";
  } else if (hack !== "_" && hack !== "*" && hack !== "$" && hack !== "#" && hack !== "+" && hack !== "&") {
    hack = "";
  }
  const custom = isCustomProperty(name2, hack.length);
  if (!custom) {
    name2 = name2.toLowerCase();
    if (properties.has(name2)) {
      const descriptor2 = properties.get(name2);
      properties.set(property2, descriptor2);
      return descriptor2;
    }
  }
  const vendor = !custom ? getVendorPrefix(name2, hack.length) : "";
  const prefix = name2.substr(0, hack.length + vendor.length);
  const descriptor = Object.freeze({
    basename: name2.substr(prefix.length),
    name: name2.substr(hack.length),
    hack,
    vendor,
    prefix,
    custom
  });
  properties.set(property2, descriptor);
  return descriptor;
}
const cssWideKeywords = [
  "initial",
  "inherit",
  "unset",
  "revert",
  "revert-layer"
];
const PLUSSIGN$8 = 43;
const HYPHENMINUS$4 = 45;
const N$3 = 110;
const DISALLOW_SIGN$1 = true;
const ALLOW_SIGN$1 = false;
function isDelim$1(token, code2) {
  return token !== null && token.type === Delim && token.value.charCodeAt(0) === code2;
}
function skipSC(token, offset, getNextToken) {
  while (token !== null && (token.type === WhiteSpace$1 || token.type === Comment$1)) {
    token = getNextToken(++offset);
  }
  return offset;
}
function checkInteger$1(token, valueOffset, disallowSign, offset) {
  if (!token) {
    return 0;
  }
  const code2 = token.value.charCodeAt(valueOffset);
  if (code2 === PLUSSIGN$8 || code2 === HYPHENMINUS$4) {
    if (disallowSign) {
      return 0;
    }
    valueOffset++;
  }
  for (; valueOffset < token.value.length; valueOffset++) {
    if (!isDigit$1(token.value.charCodeAt(valueOffset))) {
      return 0;
    }
  }
  return offset + 1;
}
function consumeB$1(token, offset_, getNextToken) {
  let sign = false;
  let offset = skipSC(token, offset_, getNextToken);
  token = getNextToken(offset);
  if (token === null) {
    return offset_;
  }
  if (token.type !== Number$3) {
    if (isDelim$1(token, PLUSSIGN$8) || isDelim$1(token, HYPHENMINUS$4)) {
      sign = true;
      offset = skipSC(getNextToken(++offset), offset, getNextToken);
      token = getNextToken(offset);
      if (token === null || token.type !== Number$3) {
        return 0;
      }
    } else {
      return offset_;
    }
  }
  if (!sign) {
    const code2 = token.value.charCodeAt(0);
    if (code2 !== PLUSSIGN$8 && code2 !== HYPHENMINUS$4) {
      return 0;
    }
  }
  return checkInteger$1(token, sign ? 0 : 1, sign, offset);
}
function anPlusB(token, getNextToken) {
  let offset = 0;
  if (!token) {
    return 0;
  }
  if (token.type === Number$3) {
    return checkInteger$1(token, 0, ALLOW_SIGN$1, offset);
  } else if (token.type === Ident && token.value.charCodeAt(0) === HYPHENMINUS$4) {
    if (!cmpChar(token.value, 1, N$3)) {
      return 0;
    }
    switch (token.value.length) {
      // -n
      // -n <signed-integer>
      // -n ['+' | '-'] <signless-integer>
      case 2:
        return consumeB$1(getNextToken(++offset), offset, getNextToken);
      // -n- <signless-integer>
      case 3:
        if (token.value.charCodeAt(2) !== HYPHENMINUS$4) {
          return 0;
        }
        offset = skipSC(getNextToken(++offset), offset, getNextToken);
        token = getNextToken(offset);
        return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset);
      // <dashndashdigit-ident>
      default:
        if (token.value.charCodeAt(2) !== HYPHENMINUS$4) {
          return 0;
        }
        return checkInteger$1(token, 3, DISALLOW_SIGN$1, offset);
    }
  } else if (token.type === Ident || isDelim$1(token, PLUSSIGN$8) && getNextToken(offset + 1).type === Ident) {
    if (token.type !== Ident) {
      token = getNextToken(++offset);
    }
    if (token === null || !cmpChar(token.value, 0, N$3)) {
      return 0;
    }
    switch (token.value.length) {
      // '+'? n
      // '+'? n <signed-integer>
      // '+'? n ['+' | '-'] <signless-integer>
      case 1:
        return consumeB$1(getNextToken(++offset), offset, getNextToken);
      // '+'? n- <signless-integer>
      case 2:
        if (token.value.charCodeAt(1) !== HYPHENMINUS$4) {
          return 0;
        }
        offset = skipSC(getNextToken(++offset), offset, getNextToken);
        token = getNextToken(offset);
        return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset);
      // '+'? <ndashdigit-ident>
      default:
        if (token.value.charCodeAt(1) !== HYPHENMINUS$4) {
          return 0;
        }
        return checkInteger$1(token, 2, DISALLOW_SIGN$1, offset);
    }
  } else if (token.type === Dimension$1) {
    let code2 = token.value.charCodeAt(0);
    let sign = code2 === PLUSSIGN$8 || code2 === HYPHENMINUS$4 ? 1 : 0;
    let i = sign;
    for (; i < token.value.length; i++) {
      if (!isDigit$1(token.value.charCodeAt(i))) {
        break;
      }
    }
    if (i === sign) {
      return 0;
    }
    if (!cmpChar(token.value, i, N$3)) {
      return 0;
    }
    if (i + 1 === token.value.length) {
      return consumeB$1(getNextToken(++offset), offset, getNextToken);
    } else {
      if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$4) {
        return 0;
      }
      if (i + 2 === token.value.length) {
        offset = skipSC(getNextToken(++offset), offset, getNextToken);
        token = getNextToken(offset);
        return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset);
      } else {
        return checkInteger$1(token, i + 2, DISALLOW_SIGN$1, offset);
      }
    }
  }
  return 0;
}
const PLUSSIGN$7 = 43;
const HYPHENMINUS$3 = 45;
const QUESTIONMARK$2 = 63;
const U$1 = 117;
function isDelim(token, code2) {
  return token !== null && token.type === Delim && token.value.charCodeAt(0) === code2;
}
function startsWith$1(token, code2) {
  return token.value.charCodeAt(0) === code2;
}
function hexSequence(token, offset, allowDash) {
  let hexlen = 0;
  for (let pos = offset; pos < token.value.length; pos++) {
    const code2 = token.value.charCodeAt(pos);
    if (code2 === HYPHENMINUS$3 && allowDash && hexlen !== 0) {
      hexSequence(token, offset + hexlen + 1, false);
      return 6;
    }
    if (!isHexDigit(code2)) {
      return 0;
    }
    if (++hexlen > 6) {
      return 0;
    }
  }
  return hexlen;
}
function withQuestionMarkSequence(consumed, length2, getNextToken) {
  if (!consumed) {
    return 0;
  }
  while (isDelim(getNextToken(length2), QUESTIONMARK$2)) {
    if (++consumed > 6) {
      return 0;
    }
    length2++;
  }
  return length2;
}
function urange(token, getNextToken) {
  let length2 = 0;
  if (token === null || token.type !== Ident || !cmpChar(token.value, 0, U$1)) {
    return 0;
  }
  token = getNextToken(++length2);
  if (token === null) {
    return 0;
  }
  if (isDelim(token, PLUSSIGN$7)) {
    token = getNextToken(++length2);
    if (token === null) {
      return 0;
    }
    if (token.type === Ident) {
      return withQuestionMarkSequence(hexSequence(token, 0, true), ++length2, getNextToken);
    }
    if (isDelim(token, QUESTIONMARK$2)) {
      return withQuestionMarkSequence(1, ++length2, getNextToken);
    }
    return 0;
  }
  if (token.type === Number$3) {
    const consumedHexLength = hexSequence(token, 1, true);
    if (consumedHexLength === 0) {
      return 0;
    }
    token = getNextToken(++length2);
    if (token === null) {
      return length2;
    }
    if (token.type === Dimension$1 || token.type === Number$3) {
      if (!startsWith$1(token, HYPHENMINUS$3) || !hexSequence(token, 1, false)) {
        return 0;
      }
      return length2 + 1;
    }
    return withQuestionMarkSequence(consumedHexLength, length2, getNextToken);
  }
  if (token.type === Dimension$1) {
    return withQuestionMarkSequence(hexSequence(token, 1, true), ++length2, getNextToken);
  }
  return 0;
}
const calcFunctionNames = ["calc(", "-moz-calc(", "-webkit-calc("];
const balancePair = /* @__PURE__ */ new Map([
  [Function$1, RightParenthesis],
  [LeftParenthesis, RightParenthesis],
  [LeftSquareBracket, RightSquareBracket],
  [LeftCurlyBracket, RightCurlyBracket]
]);
const LENGTH = [
  // absolute length units https://www.w3.org/TR/css-values-3/#lengths
  "cm",
  "mm",
  "q",
  "in",
  "pt",
  "pc",
  "px",
  // font-relative length units https://drafts.csswg.org/css-values-4/#font-relative-lengths
  "em",
  "rem",
  "ex",
  "rex",
  "cap",
  "rcap",
  "ch",
  "rch",
  "ic",
  "ric",
  "lh",
  "rlh",
  // viewport-percentage lengths https://drafts.csswg.org/css-values-4/#viewport-relative-lengths
  "vw",
  "svw",
  "lvw",
  "dvw",
  "vh",
  "svh",
  "lvh",
  "dvh",
  "vi",
  "svi",
  "lvi",
  "dvi",
  "vb",
  "svb",
  "lvb",
  "dvb",
  "vmin",
  "svmin",
  "lvmin",
  "dvmin",
  "vmax",
  "svmax",
  "lvmax",
  "dvmax",
  // container relative lengths https://drafts.csswg.org/css-contain-3/#container-lengths
  "cqw",
  "cqh",
  "cqi",
  "cqb",
  "cqmin",
  "cqmax"
];
const ANGLE = ["deg", "grad", "rad", "turn"];
const TIME = ["s", "ms"];
const FREQUENCY = ["hz", "khz"];
const RESOLUTION = ["dpi", "dpcm", "dppx", "x"];
const FLEX = ["fr"];
const DECIBEL = ["db"];
const SEMITONES = ["st"];
function charCodeAt(str, index) {
  return index < str.length ? str.charCodeAt(index) : 0;
}
function eqStr(actual, expected) {
  return cmpStr(actual, 0, actual.length, expected);
}
function eqStrAny(actual, expected) {
  for (let i = 0; i < expected.length; i++) {
    if (eqStr(actual, expected[i])) {
      return true;
    }
  }
  return false;
}
function isPostfixIeHack(str, offset) {
  if (offset !== str.length - 2) {
    return false;
  }
  return charCodeAt(str, offset) === 92 && // U+005C REVERSE SOLIDUS (\)
  isDigit$1(charCodeAt(str, offset + 1));
}
function outOfRange(opts, value2, numEnd) {
  if (opts && opts.type === "Range") {
    const num = Number(
      numEnd !== void 0 && numEnd !== value2.length ? value2.substr(0, numEnd) : value2
    );
    if (isNaN(num)) {
      return true;
    }
    if (opts.min !== null && num < opts.min && typeof opts.min !== "string") {
      return true;
    }
    if (opts.max !== null && num > opts.max && typeof opts.max !== "string") {
      return true;
    }
  }
  return false;
}
function consumeFunction(token, getNextToken) {
  let balanceCloseType = 0;
  let balanceStash = [];
  let length2 = 0;
  scan:
    do {
      switch (token.type) {
        case RightCurlyBracket:
        case RightParenthesis:
        case RightSquareBracket:
          if (token.type !== balanceCloseType) {
            break scan;
          }
          balanceCloseType = balanceStash.pop();
          if (balanceStash.length === 0) {
            length2++;
            break scan;
          }
          break;
        case Function$1:
        case LeftParenthesis:
        case LeftSquareBracket:
        case LeftCurlyBracket:
          balanceStash.push(balanceCloseType);
          balanceCloseType = balancePair.get(token.type);
          break;
      }
      length2++;
    } while (token = getNextToken(length2));
  return length2;
}
function calc(next) {
  return function(token, getNextToken, opts) {
    if (token === null) {
      return 0;
    }
    if (token.type === Function$1 && eqStrAny(token.value, calcFunctionNames)) {
      return consumeFunction(token, getNextToken);
    }
    return next(token, getNextToken, opts);
  };
}
function tokenType(expectedTokenType) {
  return function(token) {
    if (token === null || token.type !== expectedTokenType) {
      return 0;
    }
    return 1;
  };
}
function customIdent(token) {
  if (token === null || token.type !== Ident) {
    return 0;
  }
  const name2 = token.value.toLowerCase();
  if (eqStrAny(name2, cssWideKeywords)) {
    return 0;
  }
  if (eqStr(name2, "default")) {
    return 0;
  }
  return 1;
}
function customPropertyName(token) {
  if (token === null || token.type !== Ident) {
    return 0;
  }
  if (charCodeAt(token.value, 0) !== 45 || charCodeAt(token.value, 1) !== 45) {
    return 0;
  }
  return 1;
}
function hexColor(token) {
  if (token === null || token.type !== Hash$1) {
    return 0;
  }
  const length2 = token.value.length;
  if (length2 !== 4 && length2 !== 5 && length2 !== 7 && length2 !== 9) {
    return 0;
  }
  for (let i = 1; i < length2; i++) {
    if (!isHexDigit(charCodeAt(token.value, i))) {
      return 0;
    }
  }
  return 1;
}
function idSelector(token) {
  if (token === null || token.type !== Hash$1) {
    return 0;
  }
  if (!isIdentifierStart(charCodeAt(token.value, 1), charCodeAt(token.value, 2), charCodeAt(token.value, 3))) {
    return 0;
  }
  return 1;
}
function declarationValue(token, getNextToken) {
  if (!token) {
    return 0;
  }
  let balanceCloseType = 0;
  let balanceStash = [];
  let length2 = 0;
  scan:
    do {
      switch (token.type) {
        // ... <bad-string-token>, <bad-url-token>,
        case BadString:
        case BadUrl:
          break scan;
        // ... unmatched <)-token>, <]-token>, or <}-token>,
        case RightCurlyBracket:
        case RightParenthesis:
        case RightSquareBracket:
          if (token.type !== balanceCloseType) {
            break scan;
          }
          balanceCloseType = balanceStash.pop();
          break;
        // ... or top-level <semicolon-token> tokens
        case Semicolon:
          if (balanceCloseType === 0) {
            break scan;
          }
          break;
        // ... or <delim-token> tokens with a value of "!"
        case Delim:
          if (balanceCloseType === 0 && token.value === "!") {
            break scan;
          }
          break;
        case Function$1:
        case LeftParenthesis:
        case LeftSquareBracket:
        case LeftCurlyBracket:
          balanceStash.push(balanceCloseType);
          balanceCloseType = balancePair.get(token.type);
          break;
      }
      length2++;
    } while (token = getNextToken(length2));
  return length2;
}
function anyValue(token, getNextToken) {
  if (!token) {
    return 0;
  }
  let balanceCloseType = 0;
  let balanceStash = [];
  let length2 = 0;
  scan:
    do {
      switch (token.type) {
        // ... does not contain <bad-string-token>, <bad-url-token>,
        case BadString:
        case BadUrl:
          break scan;
        // ... unmatched <)-token>, <]-token>, or <}-token>,
        case RightCurlyBracket:
        case RightParenthesis:
        case RightSquareBracket:
          if (token.type !== balanceCloseType) {
            break scan;
          }
          balanceCloseType = balanceStash.pop();
          break;
        case Function$1:
        case LeftParenthesis:
        case LeftSquareBracket:
        case LeftCurlyBracket:
          balanceStash.push(balanceCloseType);
          balanceCloseType = balancePair.get(token.type);
          break;
      }
      length2++;
    } while (token = getNextToken(length2));
  return length2;
}
function dimension(type) {
  if (type) {
    type = new Set(type);
  }
  return function(token, getNextToken, opts) {
    if (token === null || token.type !== Dimension$1) {
      return 0;
    }
    const numberEnd = consumeNumber$1(token.value, 0);
    if (type !== null) {
      const reverseSolidusOffset = token.value.indexOf("\\", numberEnd);
      const unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset) ? token.value.substr(numberEnd) : token.value.substring(numberEnd, reverseSolidusOffset);
      if (type.has(unit.toLowerCase()) === false) {
        return 0;
      }
    }
    if (outOfRange(opts, token.value, numberEnd)) {
      return 0;
    }
    return 1;
  };
}
function percentage(token, getNextToken, opts) {
  if (token === null || token.type !== Percentage$1) {
    return 0;
  }
  if (outOfRange(opts, token.value, token.value.length - 1)) {
    return 0;
  }
  return 1;
}
function zero(next) {
  if (typeof next !== "function") {
    next = function() {
      return 0;
    };
  }
  return function(token, getNextToken, opts) {
    if (token !== null && token.type === Number$3) {
      if (Number(token.value) === 0) {
        return 1;
      }
    }
    return next(token, getNextToken, opts);
  };
}
function number(token, getNextToken, opts) {
  if (token === null) {
    return 0;
  }
  const numberEnd = consumeNumber$1(token.value, 0);
  const isNumber = numberEnd === token.value.length;
  if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
    return 0;
  }
  if (outOfRange(opts, token.value, numberEnd)) {
    return 0;
  }
  return 1;
}
function integer(token, getNextToken, opts) {
  if (token === null || token.type !== Number$3) {
    return 0;
  }
  let i = charCodeAt(token.value, 0) === 43 || // U+002B PLUS SIGN (+)
  charCodeAt(token.value, 0) === 45 ? 1 : 0;
  for (; i < token.value.length; i++) {
    if (!isDigit$1(charCodeAt(token.value, i))) {
      return 0;
    }
  }
  if (outOfRange(opts, token.value, i)) {
    return 0;
  }
  return 1;
}
const generic = {
  // token types
  "ident-token": tokenType(Ident),
  "function-token": tokenType(Function$1),
  "at-keyword-token": tokenType(AtKeyword),
  "hash-token": tokenType(Hash$1),
  "string-token": tokenType(String$2),
  "bad-string-token": tokenType(BadString),
  "url-token": tokenType(Url$2),
  "bad-url-token": tokenType(BadUrl),
  "delim-token": tokenType(Delim),
  "number-token": tokenType(Number$3),
  "percentage-token": tokenType(Percentage$1),
  "dimension-token": tokenType(Dimension$1),
  "whitespace-token": tokenType(WhiteSpace$1),
  "CDO-token": tokenType(CDO$1),
  "CDC-token": tokenType(CDC$1),
  "colon-token": tokenType(Colon),
  "semicolon-token": tokenType(Semicolon),
  "comma-token": tokenType(Comma),
  "[-token": tokenType(LeftSquareBracket),
  "]-token": tokenType(RightSquareBracket),
  "(-token": tokenType(LeftParenthesis),
  ")-token": tokenType(RightParenthesis),
  "{-token": tokenType(LeftCurlyBracket),
  "}-token": tokenType(RightCurlyBracket),
  // token type aliases
  "string": tokenType(String$2),
  "ident": tokenType(Ident),
  // complex types
  "custom-ident": customIdent,
  "custom-property-name": customPropertyName,
  "hex-color": hexColor,
  "id-selector": idSelector,
  // element( <id-selector> )
  "an-plus-b": anPlusB,
  "urange": urange,
  "declaration-value": declarationValue,
  "any-value": anyValue,
  // dimensions
  "dimension": calc(dimension(null)),
  "angle": calc(dimension(ANGLE)),
  "decibel": calc(dimension(DECIBEL)),
  "frequency": calc(dimension(FREQUENCY)),
  "flex": calc(dimension(FLEX)),
  "length": calc(zero(dimension(LENGTH))),
  "resolution": calc(dimension(RESOLUTION)),
  "semitones": calc(dimension(SEMITONES)),
  "time": calc(dimension(TIME)),
  // percentage
  "percentage": calc(percentage),
  // numeric
  "zero": zero(),
  "number": calc(number),
  "integer": calc(integer)
};
function SyntaxError$1(message, input, offset) {
  return Object.assign(createCustomError("SyntaxError", message), {
    input,
    offset,
    rawMessage: message,
    message: message + "\n  " + input + "\n--" + new Array((offset || input.length) + 1).join("-") + "^"
  });
}
const TAB$1 = 9;
const N$2 = 10;
const F$1 = 12;
const R$1 = 13;
const SPACE$3 = 32;
class Tokenizer {
  constructor(str) {
    this.str = str;
    this.pos = 0;
  }
  charCodeAt(pos) {
    return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
  }
  charCode() {
    return this.charCodeAt(this.pos);
  }
  nextCharCode() {
    return this.charCodeAt(this.pos + 1);
  }
  nextNonWsCode(pos) {
    return this.charCodeAt(this.findWsEnd(pos));
  }
  findWsEnd(pos) {
    for (; pos < this.str.length; pos++) {
      const code2 = this.str.charCodeAt(pos);
      if (code2 !== R$1 && code2 !== N$2 && code2 !== F$1 && code2 !== SPACE$3 && code2 !== TAB$1) {
        break;
      }
    }
    return pos;
  }
  substringToPos(end) {
    return this.str.substring(this.pos, this.pos = end);
  }
  eat(code2) {
    if (this.charCode() !== code2) {
      this.error("Expect `" + String.fromCharCode(code2) + "`");
    }
    this.pos++;
  }
  peek() {
    return this.pos < this.str.length ? this.str.charAt(this.pos++) : "";
  }
  error(message) {
    throw new SyntaxError$1(message, this.str, this.pos);
  }
}
const TAB = 9;
const N$1 = 10;
const F = 12;
const R = 13;
const SPACE$2 = 32;
const EXCLAMATIONMARK$2 = 33;
const NUMBERSIGN$3 = 35;
const AMPERSAND$1 = 38;
const APOSTROPHE$2 = 39;
const LEFTPARENTHESIS$2 = 40;
const RIGHTPARENTHESIS$2 = 41;
const ASTERISK$6 = 42;
const PLUSSIGN$6 = 43;
const COMMA = 44;
const HYPERMINUS = 45;
const LESSTHANSIGN = 60;
const GREATERTHANSIGN$2 = 62;
const QUESTIONMARK$1 = 63;
const COMMERCIALAT = 64;
const LEFTSQUAREBRACKET = 91;
const RIGHTSQUAREBRACKET = 93;
const LEFTCURLYBRACKET = 123;
const VERTICALLINE$3 = 124;
const RIGHTCURLYBRACKET = 125;
const INFINITY = 8734;
const NAME_CHAR = new Uint8Array(128).map(
  (_, idx) => /[a-zA-Z0-9\-]/.test(String.fromCharCode(idx)) ? 1 : 0
);
const COMBINATOR_PRECEDENCE = {
  " ": 1,
  "&&": 2,
  "||": 3,
  "|": 4
};
function scanSpaces(tokenizer) {
  return tokenizer.substringToPos(
    tokenizer.findWsEnd(tokenizer.pos)
  );
}
function scanWord(tokenizer) {
  let end = tokenizer.pos;
  for (; end < tokenizer.str.length; end++) {
    const code2 = tokenizer.str.charCodeAt(end);
    if (code2 >= 128 || NAME_CHAR[code2] === 0) {
      break;
    }
  }
  if (tokenizer.pos === end) {
    tokenizer.error("Expect a keyword");
  }
  return tokenizer.substringToPos(end);
}
function scanNumber(tokenizer) {
  let end = tokenizer.pos;
  for (; end < tokenizer.str.length; end++) {
    const code2 = tokenizer.str.charCodeAt(end);
    if (code2 < 48 || code2 > 57) {
      break;
    }
  }
  if (tokenizer.pos === end) {
    tokenizer.error("Expect a number");
  }
  return tokenizer.substringToPos(end);
}
function scanString(tokenizer) {
  const end = tokenizer.str.indexOf("'", tokenizer.pos + 1);
  if (end === -1) {
    tokenizer.pos = tokenizer.str.length;
    tokenizer.error("Expect an apostrophe");
  }
  return tokenizer.substringToPos(end + 1);
}
function readMultiplierRange(tokenizer) {
  let min = null;
  let max = null;
  tokenizer.eat(LEFTCURLYBRACKET);
  min = scanNumber(tokenizer);
  if (tokenizer.charCode() === COMMA) {
    tokenizer.pos++;
    if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
      max = scanNumber(tokenizer);
    }
  } else {
    max = min;
  }
  tokenizer.eat(RIGHTCURLYBRACKET);
  return {
    min: Number(min),
    max: max ? Number(max) : 0
  };
}
function readMultiplier(tokenizer) {
  let range = null;
  let comma = false;
  switch (tokenizer.charCode()) {
    case ASTERISK$6:
      tokenizer.pos++;
      range = {
        min: 0,
        max: 0
      };
      break;
    case PLUSSIGN$6:
      tokenizer.pos++;
      range = {
        min: 1,
        max: 0
      };
      break;
    case QUESTIONMARK$1:
      tokenizer.pos++;
      range = {
        min: 0,
        max: 1
      };
      break;
    case NUMBERSIGN$3:
      tokenizer.pos++;
      comma = true;
      if (tokenizer.charCode() === LEFTCURLYBRACKET) {
        range = readMultiplierRange(tokenizer);
      } else if (tokenizer.charCode() === QUESTIONMARK$1) {
        tokenizer.pos++;
        range = {
          min: 0,
          max: 0
        };
      } else {
        range = {
          min: 1,
          max: 0
        };
      }
      break;
    case LEFTCURLYBRACKET:
      range = readMultiplierRange(tokenizer);
      break;
    default:
      return null;
  }
  return {
    type: "Multiplier",
    comma,
    min: range.min,
    max: range.max,
    term: null
  };
}
function maybeMultiplied(tokenizer, node2) {
  const multiplier = readMultiplier(tokenizer);
  if (multiplier !== null) {
    multiplier.term = node2;
    if (tokenizer.charCode() === NUMBERSIGN$3 && tokenizer.charCodeAt(tokenizer.pos - 1) === PLUSSIGN$6) {
      return maybeMultiplied(tokenizer, multiplier);
    }
    return multiplier;
  }
  return node2;
}
function maybeToken(tokenizer) {
  const ch = tokenizer.peek();
  if (ch === "") {
    return null;
  }
  return {
    type: "Token",
    value: ch
  };
}
function readProperty$1(tokenizer) {
  let name2;
  tokenizer.eat(LESSTHANSIGN);
  tokenizer.eat(APOSTROPHE$2);
  name2 = scanWord(tokenizer);
  tokenizer.eat(APOSTROPHE$2);
  tokenizer.eat(GREATERTHANSIGN$2);
  return maybeMultiplied(tokenizer, {
    type: "Property",
    name: name2
  });
}
function readTypeRange(tokenizer) {
  let min = null;
  let max = null;
  let sign = 1;
  tokenizer.eat(LEFTSQUAREBRACKET);
  if (tokenizer.charCode() === HYPERMINUS) {
    tokenizer.peek();
    sign = -1;
  }
  if (sign == -1 && tokenizer.charCode() === INFINITY) {
    tokenizer.peek();
  } else {
    min = sign * Number(scanNumber(tokenizer));
    if (NAME_CHAR[tokenizer.charCode()] !== 0) {
      min += scanWord(tokenizer);
    }
  }
  scanSpaces(tokenizer);
  tokenizer.eat(COMMA);
  scanSpaces(tokenizer);
  if (tokenizer.charCode() === INFINITY) {
    tokenizer.peek();
  } else {
    sign = 1;
    if (tokenizer.charCode() === HYPERMINUS) {
      tokenizer.peek();
      sign = -1;
    }
    max = sign * Number(scanNumber(tokenizer));
    if (NAME_CHAR[tokenizer.charCode()] !== 0) {
      max += scanWord(tokenizer);
    }
  }
  tokenizer.eat(RIGHTSQUAREBRACKET);
  return {
    type: "Range",
    min,
    max
  };
}
function readType(tokenizer) {
  let name2;
  let opts = null;
  tokenizer.eat(LESSTHANSIGN);
  name2 = scanWord(tokenizer);
  if (tokenizer.charCode() === LEFTPARENTHESIS$2 && tokenizer.nextCharCode() === RIGHTPARENTHESIS$2) {
    tokenizer.pos += 2;
    name2 += "()";
  }
  if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
    scanSpaces(tokenizer);
    opts = readTypeRange(tokenizer);
  }
  tokenizer.eat(GREATERTHANSIGN$2);
  return maybeMultiplied(tokenizer, {
    type: "Type",
    name: name2,
    opts
  });
}
function readKeywordOrFunction(tokenizer) {
  const name2 = scanWord(tokenizer);
  if (tokenizer.charCode() === LEFTPARENTHESIS$2) {
    tokenizer.pos++;
    return {
      type: "Function",
      name: name2
    };
  }
  return maybeMultiplied(tokenizer, {
    type: "Keyword",
    name: name2
  });
}
function regroupTerms(terms, combinators) {
  function createGroup(terms2, combinator2) {
    return {
      type: "Group",
      terms: terms2,
      combinator: combinator2,
      disallowEmpty: false,
      explicit: false
    };
  }
  let combinator;
  combinators = Object.keys(combinators).sort((a, b) => COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b]);
  while (combinators.length > 0) {
    combinator = combinators.shift();
    let i = 0;
    let subgroupStart = 0;
    for (; i < terms.length; i++) {
      const term = terms[i];
      if (term.type === "Combinator") {
        if (term.value === combinator) {
          if (subgroupStart === -1) {
            subgroupStart = i - 1;
          }
          terms.splice(i, 1);
          i--;
        } else {
          if (subgroupStart !== -1 && i - subgroupStart > 1) {
            terms.splice(
              subgroupStart,
              i - subgroupStart,
              createGroup(terms.slice(subgroupStart, i), combinator)
            );
            i = subgroupStart + 1;
          }
          subgroupStart = -1;
        }
      }
    }
    if (subgroupStart !== -1 && combinators.length) {
      terms.splice(
        subgroupStart,
        i - subgroupStart,
        createGroup(terms.slice(subgroupStart, i), combinator)
      );
    }
  }
  return combinator;
}
function readImplicitGroup(tokenizer) {
  const terms = [];
  const combinators = {};
  let token;
  let prevToken = null;
  let prevTokenPos = tokenizer.pos;
  while (token = peek(tokenizer)) {
    if (token.type !== "Spaces") {
      if (token.type === "Combinator") {
        if (prevToken === null || prevToken.type === "Combinator") {
          tokenizer.pos = prevTokenPos;
          tokenizer.error("Unexpected combinator");
        }
        combinators[token.value] = true;
      } else if (prevToken !== null && prevToken.type !== "Combinator") {
        combinators[" "] = true;
        terms.push({
          type: "Combinator",
          value: " "
        });
      }
      terms.push(token);
      prevToken = token;
      prevTokenPos = tokenizer.pos;
    }
  }
  if (prevToken !== null && prevToken.type === "Combinator") {
    tokenizer.pos -= prevTokenPos;
    tokenizer.error("Unexpected combinator");
  }
  return {
    type: "Group",
    terms,
    combinator: regroupTerms(terms, combinators) || " ",
    disallowEmpty: false,
    explicit: false
  };
}
function readGroup(tokenizer) {
  let result;
  tokenizer.eat(LEFTSQUAREBRACKET);
  result = readImplicitGroup(tokenizer);
  tokenizer.eat(RIGHTSQUAREBRACKET);
  result.explicit = true;
  if (tokenizer.charCode() === EXCLAMATIONMARK$2) {
    tokenizer.pos++;
    result.disallowEmpty = true;
  }
  return result;
}
function peek(tokenizer) {
  let code2 = tokenizer.charCode();
  if (code2 < 128 && NAME_CHAR[code2] === 1) {
    return readKeywordOrFunction(tokenizer);
  }
  switch (code2) {
    case RIGHTSQUAREBRACKET:
      break;
    case LEFTSQUAREBRACKET:
      return maybeMultiplied(tokenizer, readGroup(tokenizer));
    case LESSTHANSIGN:
      return tokenizer.nextCharCode() === APOSTROPHE$2 ? readProperty$1(tokenizer) : readType(tokenizer);
    case VERTICALLINE$3:
      return {
        type: "Combinator",
        value: tokenizer.substringToPos(
          tokenizer.pos + (tokenizer.nextCharCode() === VERTICALLINE$3 ? 2 : 1)
        )
      };
    case AMPERSAND$1:
      tokenizer.pos++;
      tokenizer.eat(AMPERSAND$1);
      return {
        type: "Combinator",
        value: "&&"
      };
    case COMMA:
      tokenizer.pos++;
      return {
        type: "Comma"
      };
    case APOSTROPHE$2:
      return maybeMultiplied(tokenizer, {
        type: "String",
        value: scanString(tokenizer)
      });
    case SPACE$2:
    case TAB:
    case N$1:
    case R:
    case F:
      return {
        type: "Spaces",
        value: scanSpaces(tokenizer)
      };
    case COMMERCIALAT:
      code2 = tokenizer.nextCharCode();
      if (code2 < 128 && NAME_CHAR[code2] === 1) {
        tokenizer.pos++;
        return {
          type: "AtKeyword",
          name: scanWord(tokenizer)
        };
      }
      return maybeToken(tokenizer);
    case ASTERISK$6:
    case PLUSSIGN$6:
    case QUESTIONMARK$1:
    case NUMBERSIGN$3:
    case EXCLAMATIONMARK$2:
      break;
    case LEFTCURLYBRACKET:
      code2 = tokenizer.nextCharCode();
      if (code2 < 48 || code2 > 57) {
        return maybeToken(tokenizer);
      }
      break;
    default:
      return maybeToken(tokenizer);
  }
}
function parse$H(source) {
  const tokenizer = new Tokenizer(source);
  const result = readImplicitGroup(tokenizer);
  if (tokenizer.pos !== source.length) {
    tokenizer.error("Unexpected input");
  }
  if (result.terms.length === 1 && result.terms[0].type === "Group") {
    return result.terms[0];
  }
  return result;
}
const noop = function() {
};
function ensureFunction(value2) {
  return typeof value2 === "function" ? value2 : noop;
}
function walk$2(node2, options, context) {
  function walk2(node3) {
    enter.call(context, node3);
    switch (node3.type) {
      case "Group":
        node3.terms.forEach(walk2);
        break;
      case "Multiplier":
        walk2(node3.term);
        break;
      case "Type":
      case "Property":
      case "Keyword":
      case "AtKeyword":
      case "Function":
      case "String":
      case "Token":
      case "Comma":
        break;
      default:
        throw new Error("Unknown type: " + node3.type);
    }
    leave.call(context, node3);
  }
  let enter = noop;
  let leave = noop;
  if (typeof options === "function") {
    enter = options;
  } else if (options) {
    enter = ensureFunction(options.enter);
    leave = ensureFunction(options.leave);
  }
  if (enter === noop && leave === noop) {
    throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
  }
  walk2(node2);
}
const astToTokens = {
  decorator(handlers2) {
    const tokens = [];
    let curNode = null;
    return {
      ...handlers2,
      node(node2) {
        const tmp = curNode;
        curNode = node2;
        handlers2.node.call(this, node2);
        curNode = tmp;
      },
      emit(value2, type, auto) {
        tokens.push({
          type,
          value: value2,
          node: auto ? null : curNode
        });
      },
      result() {
        return tokens;
      }
    };
  }
};
function stringToTokens(str) {
  const tokens = [];
  tokenize$2(
    str,
    (type, start, end) => tokens.push({
      type,
      value: str.slice(start, end),
      node: null
    })
  );
  return tokens;
}
function prepareTokens(value2, syntax2) {
  if (typeof value2 === "string") {
    return stringToTokens(value2);
  }
  return syntax2.generate(value2, astToTokens);
}
const MATCH = { type: "Match" };
const MISMATCH = { type: "Mismatch" };
const DISALLOW_EMPTY = { type: "DisallowEmpty" };
const LEFTPARENTHESIS$1 = 40;
const RIGHTPARENTHESIS$1 = 41;
function createCondition(match, thenBranch, elseBranch) {
  if (thenBranch === MATCH && elseBranch === MISMATCH) {
    return match;
  }
  if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
    return match;
  }
  if (match.type === "If" && match.else === MISMATCH && thenBranch === MATCH) {
    thenBranch = match.then;
    match = match.match;
  }
  return {
    type: "If",
    match,
    then: thenBranch,
    else: elseBranch
  };
}
function isFunctionType(name2) {
  return name2.length > 2 && name2.charCodeAt(name2.length - 2) === LEFTPARENTHESIS$1 && name2.charCodeAt(name2.length - 1) === RIGHTPARENTHESIS$1;
}
function isEnumCapatible(term) {
  return term.type === "Keyword" || term.type === "AtKeyword" || term.type === "Function" || term.type === "Type" && isFunctionType(term.name);
}
function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
  switch (combinator) {
    case " ": {
      let result = MATCH;
      for (let i = terms.length - 1; i >= 0; i--) {
        const term = terms[i];
        result = createCondition(
          term,
          result,
          MISMATCH
        );
      }
      return result;
    }
    case "|": {
      let result = MISMATCH;
      let map = null;
      for (let i = terms.length - 1; i >= 0; i--) {
        let term = terms[i];
        if (isEnumCapatible(term)) {
          if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
            map = /* @__PURE__ */ Object.create(null);
            result = createCondition(
              {
                type: "Enum",
                map
              },
              MATCH,
              result
            );
          }
          if (map !== null) {
            const key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
            if (key in map === false) {
              map[key] = term;
              continue;
            }
          }
        }
        map = null;
        result = createCondition(
          term,
          MATCH,
          result
        );
      }
      return result;
    }
    case "&&": {
      if (terms.length > 5) {
        return {
          type: "MatchOnce",
          terms,
          all: true
        };
      }
      let result = MISMATCH;
      for (let i = terms.length - 1; i >= 0; i--) {
        const term = terms[i];
        let thenClause;
        if (terms.length > 1) {
          thenClause = buildGroupMatchGraph(
            combinator,
            terms.filter(function(newGroupTerm) {
              return newGroupTerm !== term;
            }),
            false
          );
        } else {
          thenClause = MATCH;
        }
        result = createCondition(
          term,
          thenClause,
          result
        );
      }
      return result;
    }
    case "||": {
      if (terms.length > 5) {
        return {
          type: "MatchOnce",
          terms,
          all: false
        };
      }
      let result = atLeastOneTermMatched ? MATCH : MISMATCH;
      for (let i = terms.length - 1; i >= 0; i--) {
        const term = terms[i];
        let thenClause;
        if (terms.length > 1) {
          thenClause = buildGroupMatchGraph(
            combinator,
            terms.filter(function(newGroupTerm) {
              return newGroupTerm !== term;
            }),
            true
          );
        } else {
          thenClause = MATCH;
        }
        result = createCondition(
          term,
          thenClause,
          result
        );
      }
      return result;
    }
  }
}
function buildMultiplierMatchGraph(node2) {
  let result = MATCH;
  let matchTerm = buildMatchGraphInternal(node2.term);
  if (node2.max === 0) {
    matchTerm = createCondition(
      matchTerm,
      DISALLOW_EMPTY,
      MISMATCH
    );
    result = createCondition(
      matchTerm,
      null,
      // will be a loop
      MISMATCH
    );
    result.then = createCondition(
      MATCH,
      MATCH,
      result
      // make a loop
    );
    if (node2.comma) {
      result.then.else = createCondition(
        { type: "Comma", syntax: node2 },
        result,
        MISMATCH
      );
    }
  } else {
    for (let i = node2.min || 1; i <= node2.max; i++) {
      if (node2.comma && result !== MATCH) {
        result = createCondition(
          { type: "Comma", syntax: node2 },
          result,
          MISMATCH
        );
      }
      result = createCondition(
        matchTerm,
        createCondition(
          MATCH,
          MATCH,
          result
        ),
        MISMATCH
      );
    }
  }
  if (node2.min === 0) {
    result = createCondition(
      MATCH,
      MATCH,
      result
    );
  } else {
    for (let i = 0; i < node2.min - 1; i++) {
      if (node2.comma && result !== MATCH) {
        result = createCondition(
          { type: "Comma", syntax: node2 },
          result,
          MISMATCH
        );
      }
      result = createCondition(
        matchTerm,
        result,
        MISMATCH
      );
    }
  }
  return result;
}
function buildMatchGraphInternal(node2) {
  if (typeof node2 === "function") {
    return {
      type: "Generic",
      fn: node2
    };
  }
  switch (node2.type) {
    case "Group": {
      let result = buildGroupMatchGraph(
        node2.combinator,
        node2.terms.map(buildMatchGraphInternal),
        false
      );
      if (node2.disallowEmpty) {
        result = createCondition(
          result,
          DISALLOW_EMPTY,
          MISMATCH
        );
      }
      return result;
    }
    case "Multiplier":
      return buildMultiplierMatchGraph(node2);
    case "Type":
    case "Property":
      return {
        type: node2.type,
        name: node2.name,
        syntax: node2
      };
    case "Keyword":
      return {
        type: node2.type,
        name: node2.name.toLowerCase(),
        syntax: node2
      };
    case "AtKeyword":
      return {
        type: node2.type,
        name: "@" + node2.name.toLowerCase(),
        syntax: node2
      };
    case "Function":
      return {
        type: node2.type,
        name: node2.name.toLowerCase() + "(",
        syntax: node2
      };
    case "String":
      if (node2.value.length === 3) {
        return {
          type: "Token",
          value: node2.value.charAt(1),
          syntax: node2
        };
      }
      return {
        type: node2.type,
        value: node2.value.substr(1, node2.value.length - 2).replace(/\\'/g, "'"),
        syntax: node2
      };
    case "Token":
      return {
        type: node2.type,
        value: node2.value,
        syntax: node2
      };
    case "Comma":
      return {
        type: node2.type,
        syntax: node2
      };
    default:
      throw new Error("Unknown node type:", node2.type);
  }
}
function buildMatchGraph(syntaxTree, ref) {
  if (typeof syntaxTree === "string") {
    syntaxTree = parse$H(syntaxTree);
  }
  return {
    type: "MatchGraph",
    match: buildMatchGraphInternal(syntaxTree),
    syntax: ref || null,
    source: syntaxTree
  };
}
const { hasOwnProperty: hasOwnProperty$7 } = Object.prototype;
const STUB = 0;
const TOKEN = 1;
const OPEN_SYNTAX = 2;
const CLOSE_SYNTAX = 3;
const EXIT_REASON_MATCH = "Match";
const EXIT_REASON_MISMATCH = "Mismatch";
const EXIT_REASON_ITERATION_LIMIT = "Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)";
const ITERATION_LIMIT = 15e3;
function reverseList(list) {
  let prev = null;
  let next = null;
  let item = list;
  while (item !== null) {
    next = item.prev;
    item.prev = prev;
    prev = item;
    item = next;
  }
  return prev;
}
function areStringsEqualCaseInsensitive(testStr, referenceStr) {
  if (testStr.length !== referenceStr.length) {
    return false;
  }
  for (let i = 0; i < testStr.length; i++) {
    const referenceCode = referenceStr.charCodeAt(i);
    let testCode = testStr.charCodeAt(i);
    if (testCode >= 65 && testCode <= 90) {
      testCode = testCode | 32;
    }
    if (testCode !== referenceCode) {
      return false;
    }
  }
  return true;
}
function isContextEdgeDelim(token) {
  if (token.type !== Delim) {
    return false;
  }
  return token.value !== "?";
}
function isCommaContextStart(token) {
  if (token === null) {
    return true;
  }
  return token.type === Comma || token.type === Function$1 || token.type === LeftParenthesis || token.type === LeftSquareBracket || token.type === LeftCurlyBracket || isContextEdgeDelim(token);
}
function isCommaContextEnd(token) {
  if (token === null) {
    return true;
  }
  return token.type === RightParenthesis || token.type === RightSquareBracket || token.type === RightCurlyBracket || token.type === Delim && token.value === "/";
}
function internalMatch(tokens, state, syntaxes) {
  function moveToNextToken() {
    do {
      tokenIndex++;
      token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
    } while (token !== null && (token.type === WhiteSpace$1 || token.type === Comment$1));
  }
  function getNextToken(offset) {
    const nextIndex = tokenIndex + offset;
    return nextIndex < tokens.length ? tokens[nextIndex] : null;
  }
  function stateSnapshotFromSyntax(nextState, prev) {
    return {
      nextState,
      matchStack,
      syntaxStack,
      thenStack,
      tokenIndex,
      prev
    };
  }
  function pushThenStack(nextState) {
    thenStack = {
      nextState,
      matchStack,
      syntaxStack,
      prev: thenStack
    };
  }
  function pushElseStack(nextState) {
    elseStack = stateSnapshotFromSyntax(nextState, elseStack);
  }
  function addTokenToMatch() {
    matchStack = {
      type: TOKEN,
      syntax: state.syntax,
      token,
      prev: matchStack
    };
    moveToNextToken();
    syntaxStash = null;
    if (tokenIndex > longestMatch) {
      longestMatch = tokenIndex;
    }
  }
  function openSyntax() {
    syntaxStack = {
      syntax: state.syntax,
      opts: state.syntax.opts || syntaxStack !== null && syntaxStack.opts || null,
      prev: syntaxStack
    };
    matchStack = {
      type: OPEN_SYNTAX,
      syntax: state.syntax,
      token: matchStack.token,
      prev: matchStack
    };
  }
  function closeSyntax() {
    if (matchStack.type === OPEN_SYNTAX) {
      matchStack = matchStack.prev;
    } else {
      matchStack = {
        type: CLOSE_SYNTAX,
        syntax: syntaxStack.syntax,
        token: matchStack.token,
        prev: matchStack
      };
    }
    syntaxStack = syntaxStack.prev;
  }
  let syntaxStack = null;
  let thenStack = null;
  let elseStack = null;
  let syntaxStash = null;
  let iterationCount = 0;
  let exitReason = null;
  let token = null;
  let tokenIndex = -1;
  let longestMatch = 0;
  let matchStack = {
    type: STUB,
    syntax: null,
    token: null,
    prev: null
  };
  moveToNextToken();
  while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
    switch (state.type) {
      case "Match":
        if (thenStack === null) {
          if (token !== null) {
            if (tokenIndex !== tokens.length - 1 || token.value !== "\\0" && token.value !== "\\9") {
              state = MISMATCH;
              break;
            }
          }
          exitReason = EXIT_REASON_MATCH;
          break;
        }
        state = thenStack.nextState;
        if (state === DISALLOW_EMPTY) {
          if (thenStack.matchStack === matchStack) {
            state = MISMATCH;
            break;
          } else {
            state = MATCH;
          }
        }
        while (thenStack.syntaxStack !== syntaxStack) {
          closeSyntax();
        }
        thenStack = thenStack.prev;
        break;
      case "Mismatch":
        if (syntaxStash !== null && syntaxStash !== false) {
          if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
            elseStack = syntaxStash;
            syntaxStash = false;
          }
        } else if (elseStack === null) {
          exitReason = EXIT_REASON_MISMATCH;
          break;
        }
        state = elseStack.nextState;
        thenStack = elseStack.thenStack;
        syntaxStack = elseStack.syntaxStack;
        matchStack = elseStack.matchStack;
        tokenIndex = elseStack.tokenIndex;
        token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
        elseStack = elseStack.prev;
        break;
      case "MatchGraph":
        state = state.match;
        break;
      case "If":
        if (state.else !== MISMATCH) {
          pushElseStack(state.else);
        }
        if (state.then !== MATCH) {
          pushThenStack(state.then);
        }
        state = state.match;
        break;
      case "MatchOnce":
        state = {
          type: "MatchOnceBuffer",
          syntax: state,
          index: 0,
          mask: 0
        };
        break;
      case "MatchOnceBuffer": {
        const terms = state.syntax.terms;
        if (state.index === terms.length) {
          if (state.mask === 0 || state.syntax.all) {
            state = MISMATCH;
            break;
          }
          state = MATCH;
          break;
        }
        if (state.mask === (1 << terms.length) - 1) {
          state = MATCH;
          break;
        }
        for (; state.index < terms.length; state.index++) {
          const matchFlag = 1 << state.index;
          if ((state.mask & matchFlag) === 0) {
            pushElseStack(state);
            pushThenStack({
              type: "AddMatchOnce",
              syntax: state.syntax,
              mask: state.mask | matchFlag
            });
            state = terms[state.index++];
            break;
          }
        }
        break;
      }
      case "AddMatchOnce":
        state = {
          type: "MatchOnceBuffer",
          syntax: state.syntax,
          index: 0,
          mask: state.mask
        };
        break;
      case "Enum":
        if (token !== null) {
          let name2 = token.value.toLowerCase();
          if (name2.indexOf("\\") !== -1) {
            name2 = name2.replace(/\\[09].*$/, "");
          }
          if (hasOwnProperty$7.call(state.map, name2)) {
            state = state.map[name2];
            break;
          }
        }
        state = MISMATCH;
        break;
      case "Generic": {
        const opts = syntaxStack !== null ? syntaxStack.opts : null;
        const lastTokenIndex2 = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));
        if (!isNaN(lastTokenIndex2) && lastTokenIndex2 > tokenIndex) {
          while (tokenIndex < lastTokenIndex2) {
            addTokenToMatch();
          }
          state = MATCH;
        } else {
          state = MISMATCH;
        }
        break;
      }
      case "Type":
      case "Property": {
        const syntaxDict = state.type === "Type" ? "types" : "properties";
        const dictSyntax = hasOwnProperty$7.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;
        if (!dictSyntax || !dictSyntax.match) {
          throw new Error(
            "Bad syntax reference: " + (state.type === "Type" ? "<" + state.name + ">" : "<'" + state.name + "'>")
          );
        }
        if (syntaxStash !== false && token !== null && state.type === "Type") {
          const lowPriorityMatching = (
            // https://drafts.csswg.org/css-values-4/#custom-idents
            // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
            // can only claim the keyword if no other unfulfilled production can claim it.
            state.name === "custom-ident" && token.type === Ident || // https://drafts.csswg.org/css-values-4/#lengths
            // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
            // it must parse as a <number>
            state.name === "length" && token.value === "0"
          );
          if (lowPriorityMatching) {
            if (syntaxStash === null) {
              syntaxStash = stateSnapshotFromSyntax(state, elseStack);
            }
            state = MISMATCH;
            break;
          }
        }
        openSyntax();
        state = dictSyntax.match;
        break;
      }
      case "Keyword": {
        const name2 = state.name;
        if (token !== null) {
          let keywordName = token.value;
          if (keywordName.indexOf("\\") !== -1) {
            keywordName = keywordName.replace(/\\[09].*$/, "");
          }
          if (areStringsEqualCaseInsensitive(keywordName, name2)) {
            addTokenToMatch();
            state = MATCH;
            break;
          }
        }
        state = MISMATCH;
        break;
      }
      case "AtKeyword":
      case "Function":
        if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
          addTokenToMatch();
          state = MATCH;
          break;
        }
        state = MISMATCH;
        break;
      case "Token":
        if (token !== null && token.value === state.value) {
          addTokenToMatch();
          state = MATCH;
          break;
        }
        state = MISMATCH;
        break;
      case "Comma":
        if (token !== null && token.type === Comma) {
          if (isCommaContextStart(matchStack.token)) {
            state = MISMATCH;
          } else {
            addTokenToMatch();
            state = isCommaContextEnd(token) ? MISMATCH : MATCH;
          }
        } else {
          state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;
        }
        break;
      case "String":
        let string = "";
        let lastTokenIndex = tokenIndex;
        for (; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
          string += tokens[lastTokenIndex].value;
        }
        if (areStringsEqualCaseInsensitive(string, state.value)) {
          while (tokenIndex < lastTokenIndex) {
            addTokenToMatch();
          }
          state = MATCH;
        } else {
          state = MISMATCH;
        }
        break;
      default:
        throw new Error("Unknown node type: " + state.type);
    }
  }
  switch (exitReason) {
    case null:
      console.warn("[csstree-match] BREAK after " + ITERATION_LIMIT + " iterations");
      exitReason = EXIT_REASON_ITERATION_LIMIT;
      matchStack = null;
      break;
    case EXIT_REASON_MATCH:
      while (syntaxStack !== null) {
        closeSyntax();
      }
      break;
    default:
      matchStack = null;
  }
  return {
    tokens,
    reason: exitReason,
    iterations: iterationCount,
    match: matchStack,
    longestMatch
  };
}
function matchAsTree(tokens, matchGraph, syntaxes) {
  const matchResult = internalMatch(tokens, matchGraph, syntaxes || {});
  if (matchResult.match === null) {
    return matchResult;
  }
  let item = matchResult.match;
  let host = matchResult.match = {
    syntax: matchGraph.syntax || null,
    match: []
  };
  const hostStack = [host];
  item = reverseList(item).prev;
  while (item !== null) {
    switch (item.type) {
      case OPEN_SYNTAX:
        host.match.push(host = {
          syntax: item.syntax,
          match: []
        });
        hostStack.push(host);
        break;
      case CLOSE_SYNTAX:
        hostStack.pop();
        host = hostStack[hostStack.length - 1];
        break;
      default:
        host.match.push({
          syntax: item.syntax || null,
          token: item.token.value,
          node: item.token.node
        });
    }
    item = item.prev;
  }
  return matchResult;
}
function getTrace(node2) {
  function shouldPutToTrace(syntax2) {
    if (syntax2 === null) {
      return false;
    }
    return syntax2.type === "Type" || syntax2.type === "Property" || syntax2.type === "Keyword";
  }
  function hasMatch(matchNode) {
    if (Array.isArray(matchNode.match)) {
      for (let i = 0; i < matchNode.match.length; i++) {
        if (hasMatch(matchNode.match[i])) {
          if (shouldPutToTrace(matchNode.syntax)) {
            result.unshift(matchNode.syntax);
          }
          return true;
        }
      }
    } else if (matchNode.node === node2) {
      result = shouldPutToTrace(matchNode.syntax) ? [matchNode.syntax] : [];
      return true;
    }
    return false;
  }
  let result = null;
  if (this.matched !== null) {
    hasMatch(this.matched);
  }
  return result;
}
function isType(node2, type) {
  return testNode(this, node2, (match) => match.type === "Type" && match.name === type);
}
function isProperty(node2, property2) {
  return testNode(this, node2, (match) => match.type === "Property" && match.name === property2);
}
function isKeyword(node2) {
  return testNode(this, node2, (match) => match.type === "Keyword");
}
function testNode(match, node2, fn2) {
  const trace2 = getTrace.call(match, node2);
  if (trace2 === null) {
    return false;
  }
  return trace2.some(fn2);
}
const trace = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getTrace,
  isKeyword,
  isProperty,
  isType
}, Symbol.toStringTag, { value: "Module" }));
function getFirstMatchNode(matchNode) {
  if ("node" in matchNode) {
    return matchNode.node;
  }
  return getFirstMatchNode(matchNode.match[0]);
}
function getLastMatchNode(matchNode) {
  if ("node" in matchNode) {
    return matchNode.node;
  }
  return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
}
function matchFragments(lexer2, ast, match, type, name2) {
  function findFragments(matchNode) {
    if (matchNode.syntax !== null && matchNode.syntax.type === type && matchNode.syntax.name === name2) {
      const start = getFirstMatchNode(matchNode);
      const end = getLastMatchNode(matchNode);
      lexer2.syntax.walk(ast, function(node2, item, list) {
        if (node2 === start) {
          const nodes = new List2();
          do {
            nodes.appendData(item.data);
            if (item.data === end) {
              break;
            }
            item = item.next;
          } while (item !== null);
          fragments.push({
            parent: list,
            nodes
          });
        }
      });
    }
    if (Array.isArray(matchNode.match)) {
      matchNode.match.forEach(findFragments);
    }
  }
  const fragments = [];
  if (match.matched !== null) {
    findFragments(match.matched);
  }
  return fragments;
}
const { hasOwnProperty: hasOwnProperty$6 } = Object.prototype;
function isValidNumber(value2) {
  return typeof value2 === "number" && isFinite(value2) && Math.floor(value2) === value2 && value2 >= 0;
}
function isValidLocation(loc) {
  return Boolean(loc) && isValidNumber(loc.offset) && isValidNumber(loc.line) && isValidNumber(loc.column);
}
function createNodeStructureChecker(type, fields) {
  return function checkNode(node2, warn) {
    if (!node2 || node2.constructor !== Object) {
      return warn(node2, "Type of node should be an Object");
    }
    for (let key in node2) {
      let valid = true;
      if (hasOwnProperty$6.call(node2, key) === false) {
        continue;
      }
      if (key === "type") {
        if (node2.type !== type) {
          warn(node2, "Wrong node type `" + node2.type + "`, expected `" + type + "`");
        }
      } else if (key === "loc") {
        if (node2.loc === null) {
          continue;
        } else if (node2.loc && node2.loc.constructor === Object) {
          if (typeof node2.loc.source !== "string") {
            key += ".source";
          } else if (!isValidLocation(node2.loc.start)) {
            key += ".start";
          } else if (!isValidLocation(node2.loc.end)) {
            key += ".end";
          } else {
            continue;
          }
        }
        valid = false;
      } else if (fields.hasOwnProperty(key)) {
        valid = false;
        for (let i = 0; !valid && i < fields[key].length; i++) {
          const fieldType = fields[key][i];
          switch (fieldType) {
            case String:
              valid = typeof node2[key] === "string";
              break;
            case Boolean:
              valid = typeof node2[key] === "boolean";
              break;
            case null:
              valid = node2[key] === null;
              break;
            default:
              if (typeof fieldType === "string") {
                valid = node2[key] && node2[key].type === fieldType;
              } else if (Array.isArray(fieldType)) {
                valid = node2[key] instanceof List2;
              }
          }
        }
      } else {
        warn(node2, "Unknown field `" + key + "` for " + type + " node type");
      }
      if (!valid) {
        warn(node2, "Bad value for `" + type + "." + key + "`");
      }
    }
    for (const key in fields) {
      if (hasOwnProperty$6.call(fields, key) && hasOwnProperty$6.call(node2, key) === false) {
        warn(node2, "Field `" + type + "." + key + "` is missed");
      }
    }
  };
}
function processStructure(name2, nodeType) {
  const structure2 = nodeType.structure;
  const fields = {
    type: String,
    loc: true
  };
  const docs = {
    type: '"' + name2 + '"'
  };
  for (const key in structure2) {
    if (hasOwnProperty$6.call(structure2, key) === false) {
      continue;
    }
    const docsTypes = [];
    const fieldTypes = fields[key] = Array.isArray(structure2[key]) ? structure2[key].slice() : [structure2[key]];
    for (let i = 0; i < fieldTypes.length; i++) {
      const fieldType = fieldTypes[i];
      if (fieldType === String || fieldType === Boolean) {
        docsTypes.push(fieldType.name);
      } else if (fieldType === null) {
        docsTypes.push("null");
      } else if (typeof fieldType === "string") {
        docsTypes.push("<" + fieldType + ">");
      } else if (Array.isArray(fieldType)) {
        docsTypes.push("List");
      } else {
        throw new Error("Wrong value `" + fieldType + "` in `" + name2 + "." + key + "` structure definition");
      }
    }
    docs[key] = docsTypes.join(" | ");
  }
  return {
    docs,
    check: createNodeStructureChecker(name2, fields)
  };
}
function getStructureFromConfig(config) {
  const structure2 = {};
  if (config.node) {
    for (const name2 in config.node) {
      if (hasOwnProperty$6.call(config.node, name2)) {
        const nodeType = config.node[name2];
        if (nodeType.structure) {
          structure2[name2] = processStructure(name2, nodeType);
        } else {
          throw new Error("Missed `structure` field in `" + name2 + "` node type definition");
        }
      }
    }
  }
  return structure2;
}
const cssWideKeywordsSyntax = buildMatchGraph(cssWideKeywords.join(" | "));
function dumpMapSyntax(map, compact, syntaxAsAst) {
  const result = {};
  for (const name2 in map) {
    if (map[name2].syntax) {
      result[name2] = syntaxAsAst ? map[name2].syntax : generate$H(map[name2].syntax, { compact });
    }
  }
  return result;
}
function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
  const result = {};
  for (const [name2, atrule2] of Object.entries(map)) {
    result[name2] = {
      prelude: atrule2.prelude && (syntaxAsAst ? atrule2.prelude.syntax : generate$H(atrule2.prelude.syntax, { compact })),
      descriptors: atrule2.descriptors && dumpMapSyntax(atrule2.descriptors, compact, syntaxAsAst)
    };
  }
  return result;
}
function valueHasVar(tokens) {
  for (let i = 0; i < tokens.length; i++) {
    if (tokens[i].value.toLowerCase() === "var(") {
      return true;
    }
  }
  return false;
}
function buildMatchResult(matched, error2, iterations) {
  return {
    matched,
    iterations,
    error: error2,
    ...trace
  };
}
function matchSyntax(lexer2, syntax2, value2, useCssWideKeywords) {
  const tokens = prepareTokens(value2, lexer2.syntax);
  let result;
  if (valueHasVar(tokens)) {
    return buildMatchResult(null, new Error("Matching for a tree with var() is not supported"));
  }
  if (useCssWideKeywords) {
    result = matchAsTree(tokens, lexer2.cssWideKeywordsSyntax, lexer2);
  }
  if (!useCssWideKeywords || !result.match) {
    result = matchAsTree(tokens, syntax2.match, lexer2);
    if (!result.match) {
      return buildMatchResult(
        null,
        new SyntaxMatchError(result.reason, syntax2.syntax, value2, result),
        result.iterations
      );
    }
  }
  return buildMatchResult(result.match, null, result.iterations);
}
class Lexer2 {
  constructor(config, syntax2, structure2) {
    this.cssWideKeywordsSyntax = cssWideKeywordsSyntax;
    this.syntax = syntax2;
    this.generic = false;
    this.atrules = /* @__PURE__ */ Object.create(null);
    this.properties = /* @__PURE__ */ Object.create(null);
    this.types = /* @__PURE__ */ Object.create(null);
    this.structure = structure2 || getStructureFromConfig(config);
    if (config) {
      if (config.types) {
        for (const name2 in config.types) {
          this.addType_(name2, config.types[name2]);
        }
      }
      if (config.generic) {
        this.generic = true;
        for (const name2 in generic) {
          this.addType_(name2, generic[name2]);
        }
      }
      if (config.atrules) {
        for (const name2 in config.atrules) {
          this.addAtrule_(name2, config.atrules[name2]);
        }
      }
      if (config.properties) {
        for (const name2 in config.properties) {
          this.addProperty_(name2, config.properties[name2]);
        }
      }
    }
  }
  checkStructure(ast) {
    function collectWarning(node2, message) {
      warns.push({ node: node2, message });
    }
    const structure2 = this.structure;
    const warns = [];
    this.syntax.walk(ast, function(node2) {
      if (structure2.hasOwnProperty(node2.type)) {
        structure2[node2.type].check(node2, collectWarning);
      } else {
        collectWarning(node2, "Unknown node type `" + node2.type + "`");
      }
    });
    return warns.length ? warns : false;
  }
  createDescriptor(syntax2, type, name2, parent = null) {
    const ref = {
      type,
      name: name2
    };
    const descriptor = {
      type,
      name: name2,
      parent,
      serializable: typeof syntax2 === "string" || syntax2 && typeof syntax2.type === "string",
      syntax: null,
      match: null
    };
    if (typeof syntax2 === "function") {
      descriptor.match = buildMatchGraph(syntax2, ref);
    } else {
      if (typeof syntax2 === "string") {
        Object.defineProperty(descriptor, "syntax", {
          get() {
            Object.defineProperty(descriptor, "syntax", {
              value: parse$H(syntax2)
            });
            return descriptor.syntax;
          }
        });
      } else {
        descriptor.syntax = syntax2;
      }
      Object.defineProperty(descriptor, "match", {
        get() {
          Object.defineProperty(descriptor, "match", {
            value: buildMatchGraph(descriptor.syntax, ref)
          });
          return descriptor.match;
        }
      });
    }
    return descriptor;
  }
  addAtrule_(name2, syntax2) {
    if (!syntax2) {
      return;
    }
    this.atrules[name2] = {
      type: "Atrule",
      name: name2,
      prelude: syntax2.prelude ? this.createDescriptor(syntax2.prelude, "AtrulePrelude", name2) : null,
      descriptors: syntax2.descriptors ? Object.keys(syntax2.descriptors).reduce(
        (map, descName) => {
          map[descName] = this.createDescriptor(syntax2.descriptors[descName], "AtruleDescriptor", descName, name2);
          return map;
        },
        /* @__PURE__ */ Object.create(null)
      ) : null
    };
  }
  addProperty_(name2, syntax2) {
    if (!syntax2) {
      return;
    }
    this.properties[name2] = this.createDescriptor(syntax2, "Property", name2);
  }
  addType_(name2, syntax2) {
    if (!syntax2) {
      return;
    }
    this.types[name2] = this.createDescriptor(syntax2, "Type", name2);
  }
  checkAtruleName(atruleName) {
    if (!this.getAtrule(atruleName)) {
      return new SyntaxReferenceError("Unknown at-rule", "@" + atruleName);
    }
  }
  checkAtrulePrelude(atruleName, prelude) {
    const error2 = this.checkAtruleName(atruleName);
    if (error2) {
      return error2;
    }
    const atrule2 = this.getAtrule(atruleName);
    if (!atrule2.prelude && prelude) {
      return new SyntaxError("At-rule `@" + atruleName + "` should not contain a prelude");
    }
    if (atrule2.prelude && !prelude) {
      if (!matchSyntax(this, atrule2.prelude, "", false).matched) {
        return new SyntaxError("At-rule `@" + atruleName + "` should contain a prelude");
      }
    }
  }
  checkAtruleDescriptorName(atruleName, descriptorName) {
    const error2 = this.checkAtruleName(atruleName);
    if (error2) {
      return error2;
    }
    const atrule2 = this.getAtrule(atruleName);
    const descriptor = keyword(descriptorName);
    if (!atrule2.descriptors) {
      return new SyntaxError("At-rule `@" + atruleName + "` has no known descriptors");
    }
    if (!atrule2.descriptors[descriptor.name] && !atrule2.descriptors[descriptor.basename]) {
      return new SyntaxReferenceError("Unknown at-rule descriptor", descriptorName);
    }
  }
  checkPropertyName(propertyName) {
    if (!this.getProperty(propertyName)) {
      return new SyntaxReferenceError("Unknown property", propertyName);
    }
  }
  matchAtrulePrelude(atruleName, prelude) {
    const error2 = this.checkAtrulePrelude(atruleName, prelude);
    if (error2) {
      return buildMatchResult(null, error2);
    }
    const atrule2 = this.getAtrule(atruleName);
    if (!atrule2.prelude) {
      return buildMatchResult(null, null);
    }
    return matchSyntax(this, atrule2.prelude, prelude || "", false);
  }
  matchAtruleDescriptor(atruleName, descriptorName, value2) {
    const error2 = this.checkAtruleDescriptorName(atruleName, descriptorName);
    if (error2) {
      return buildMatchResult(null, error2);
    }
    const atrule2 = this.getAtrule(atruleName);
    const descriptor = keyword(descriptorName);
    return matchSyntax(this, atrule2.descriptors[descriptor.name] || atrule2.descriptors[descriptor.basename], value2, false);
  }
  matchDeclaration(node2) {
    if (node2.type !== "Declaration") {
      return buildMatchResult(null, new Error("Not a Declaration node"));
    }
    return this.matchProperty(node2.property, node2.value);
  }
  matchProperty(propertyName, value2) {
    if (property(propertyName).custom) {
      return buildMatchResult(null, new Error("Lexer matching doesn't applicable for custom properties"));
    }
    const error2 = this.checkPropertyName(propertyName);
    if (error2) {
      return buildMatchResult(null, error2);
    }
    return matchSyntax(this, this.getProperty(propertyName), value2, true);
  }
  matchType(typeName, value2) {
    const typeSyntax = this.getType(typeName);
    if (!typeSyntax) {
      return buildMatchResult(null, new SyntaxReferenceError("Unknown type", typeName));
    }
    return matchSyntax(this, typeSyntax, value2, false);
  }
  match(syntax2, value2) {
    if (typeof syntax2 !== "string" && (!syntax2 || !syntax2.type)) {
      return buildMatchResult(null, new SyntaxReferenceError("Bad syntax"));
    }
    if (typeof syntax2 === "string" || !syntax2.match) {
      syntax2 = this.createDescriptor(syntax2, "Type", "anonymous");
    }
    return matchSyntax(this, syntax2, value2, false);
  }
  findValueFragments(propertyName, value2, type, name2) {
    return matchFragments(this, value2, this.matchProperty(propertyName, value2), type, name2);
  }
  findDeclarationValueFragments(declaration, type, name2) {
    return matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name2);
  }
  findAllFragments(ast, type, name2) {
    const result = [];
    this.syntax.walk(ast, {
      visit: "Declaration",
      enter: (declaration) => {
        result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name2));
      }
    });
    return result;
  }
  getAtrule(atruleName, fallbackBasename = true) {
    const atrule2 = keyword(atruleName);
    const atruleEntry = atrule2.vendor && fallbackBasename ? this.atrules[atrule2.name] || this.atrules[atrule2.basename] : this.atrules[atrule2.name];
    return atruleEntry || null;
  }
  getAtrulePrelude(atruleName, fallbackBasename = true) {
    const atrule2 = this.getAtrule(atruleName, fallbackBasename);
    return atrule2 && atrule2.prelude || null;
  }
  getAtruleDescriptor(atruleName, name2) {
    return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators ? this.atrules[atruleName].declarators[name2] || null : null;
  }
  getProperty(propertyName, fallbackBasename = true) {
    const property$12 = property(propertyName);
    const propertyEntry = property$12.vendor && fallbackBasename ? this.properties[property$12.name] || this.properties[property$12.basename] : this.properties[property$12.name];
    return propertyEntry || null;
  }
  getType(name2) {
    return hasOwnProperty.call(this.types, name2) ? this.types[name2] : null;
  }
  validate() {
    function validate(syntax2, name2, broken, descriptor) {
      if (broken.has(name2)) {
        return broken.get(name2);
      }
      broken.set(name2, false);
      if (descriptor.syntax !== null) {
        walk$2(descriptor.syntax, function(node2) {
          if (node2.type !== "Type" && node2.type !== "Property") {
            return;
          }
          const map = node2.type === "Type" ? syntax2.types : syntax2.properties;
          const brokenMap = node2.type === "Type" ? brokenTypes : brokenProperties;
          if (!hasOwnProperty.call(map, node2.name) || validate(syntax2, node2.name, brokenMap, map[node2.name])) {
            broken.set(name2, true);
          }
        }, this);
      }
    }
    let brokenTypes = /* @__PURE__ */ new Map();
    let brokenProperties = /* @__PURE__ */ new Map();
    for (const key in this.types) {
      validate(this, key, brokenTypes, this.types[key]);
    }
    for (const key in this.properties) {
      validate(this, key, brokenProperties, this.properties[key]);
    }
    brokenTypes = [...brokenTypes.keys()].filter((name2) => brokenTypes.get(name2));
    brokenProperties = [...brokenProperties.keys()].filter((name2) => brokenProperties.get(name2));
    if (brokenTypes.length || brokenProperties.length) {
      return {
        types: brokenTypes,
        properties: brokenProperties
      };
    }
    return null;
  }
  dump(syntaxAsAst, pretty) {
    return {
      generic: this.generic,
      types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
      properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
      atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)
    };
  }
  toString() {
    return JSON.stringify(this.dump());
  }
}
const { hasOwnProperty: hasOwnProperty$5 } = Object.prototype;
const shape = {
  generic: true,
  types: appendOrAssign,
  atrules: {
    prelude: appendOrAssignOrNull,
    descriptors: appendOrAssignOrNull
  },
  properties: appendOrAssign,
  parseContext: assign,
  scope: deepAssign,
  atrule: ["parse"],
  pseudo: ["parse"],
  node: ["name", "structure", "parse", "generate", "walkContext"]
};
function isObject(value2) {
  return value2 && value2.constructor === Object;
}
function copy(value2) {
  return isObject(value2) ? { ...value2 } : value2;
}
function assign(dest, src) {
  return Object.assign(dest, src);
}
function deepAssign(dest, src) {
  for (const key in src) {
    if (hasOwnProperty$5.call(src, key)) {
      if (isObject(dest[key])) {
        deepAssign(dest[key], src[key]);
      } else {
        dest[key] = copy(src[key]);
      }
    }
  }
  return dest;
}
function append(a, b) {
  if (typeof b === "string" && /^\s*\|/.test(b)) {
    return typeof a === "string" ? a + b : b.replace(/^\s*\|\s*/, "");
  }
  return b || null;
}
function appendOrAssign(a, b) {
  if (typeof b === "string") {
    return append(a, b);
  }
  const result = { ...a };
  for (let key in b) {
    if (hasOwnProperty$5.call(b, key)) {
      result[key] = append(hasOwnProperty$5.call(a, key) ? a[key] : void 0, b[key]);
    }
  }
  return result;
}
function appendOrAssignOrNull(a, b) {
  const result = appendOrAssign(a, b);
  return !isObject(result) || Object.keys(result).length ? result : null;
}
function mix(dest, src, shape2) {
  for (const key in shape2) {
    if (hasOwnProperty$5.call(shape2, key) === false) {
      continue;
    }
    if (shape2[key] === true) {
      if (hasOwnProperty$5.call(src, key)) {
        dest[key] = copy(src[key]);
      }
    } else if (shape2[key]) {
      if (typeof shape2[key] === "function") {
        const fn2 = shape2[key];
        dest[key] = fn2({}, dest[key]);
        dest[key] = fn2(dest[key] || {}, src[key]);
      } else if (isObject(shape2[key])) {
        const result = {};
        for (let name2 in dest[key]) {
          result[name2] = mix({}, dest[key][name2], shape2[key]);
        }
        for (let name2 in src[key]) {
          result[name2] = mix(result[name2] || {}, src[key][name2], shape2[key]);
        }
        dest[key] = result;
      } else if (Array.isArray(shape2[key])) {
        const res = {};
        const innerShape = shape2[key].reduce(function(s, k) {
          s[k] = true;
          return s;
        }, {});
        for (const [name2, value2] of Object.entries(dest[key] || {})) {
          res[name2] = {};
          if (value2) {
            mix(res[name2], value2, innerShape);
          }
        }
        for (const name2 in src[key]) {
          if (hasOwnProperty$5.call(src[key], name2)) {
            if (!res[name2]) {
              res[name2] = {};
            }
            if (src[key] && src[key][name2]) {
              mix(res[name2], src[key][name2], innerShape);
            }
          }
        }
        dest[key] = res;
      }
    }
  }
  return dest;
}
const mix$1 = (dest, src) => mix(dest, src, shape);
function createSyntax(config) {
  const parse2 = createParser(config);
  const walk2 = createWalker(config);
  const generate2 = createGenerator(config);
  const { fromPlainObject: fromPlainObject2, toPlainObject: toPlainObject2 } = createConvertor(walk2);
  const syntax2 = {
    lexer: null,
    createLexer: (config2) => new Lexer2(config2, syntax2, syntax2.lexer.structure),
    tokenize: tokenize$2,
    parse: parse2,
    generate: generate2,
    walk: walk2,
    find: walk2.find,
    findLast: walk2.findLast,
    findAll: walk2.findAll,
    fromPlainObject: fromPlainObject2,
    toPlainObject: toPlainObject2,
    fork(extension) {
      const base = mix$1({}, config);
      return createSyntax(
        typeof extension === "function" ? extension(base, Object.assign) : mix$1(base, extension)
      );
    }
  };
  syntax2.lexer = new Lexer2({
    generic: true,
    types: config.types,
    atrules: config.atrules,
    properties: config.properties,
    node: config.node
  }, syntax2);
  return syntax2;
}
const createSyntax$1 = (config) => createSyntax(mix$1({}, config));
const definitions = {
  "generic": true,
  "types": {
    "absolute-size": "xx-small|x-small|small|medium|large|x-large|xx-large|xxx-large",
    "alpha-value": "<number>|<percentage>",
    "angle-percentage": "<angle>|<percentage>",
    "angular-color-hint": "<angle-percentage>",
    "angular-color-stop": "<color>&&<color-stop-angle>?",
    "angular-color-stop-list": "[<angular-color-stop> [, <angular-color-hint>]?]# , <angular-color-stop>",
    "animateable-feature": "scroll-position|contents|<custom-ident>",
    "attachment": "scroll|fixed|local",
    "attr()": "attr( <attr-name> <type-or-unit>? [, <attr-fallback>]? )",
    "attr-matcher": "['~'|'|'|'^'|'$'|'*']? '='",
    "attr-modifier": "i|s",
    "attribute-selector": "'[' <wq-name> ']'|'[' <wq-name> <attr-matcher> [<string-token>|<ident-token>] <attr-modifier>? ']'",
    "auto-repeat": "repeat( [auto-fill|auto-fit] , [<line-names>? <fixed-size>]+ <line-names>? )",
    "auto-track-list": "[<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>? <auto-repeat> [<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>?",
    "baseline-position": "[first|last]? baseline",
    "basic-shape": "<inset()>|<circle()>|<ellipse()>|<polygon()>|<path()>",
    "bg-image": "none|<image>",
    "bg-layer": "<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>",
    "bg-position": "[[left|center|right|top|bottom|<length-percentage>]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]|[center|[left|right] <length-percentage>?]&&[center|[top|bottom] <length-percentage>?]]",
    "bg-size": "[<length-percentage>|auto]{1,2}|cover|contain",
    "blur()": "blur( <length> )",
    "blend-mode": "normal|multiply|screen|overlay|darken|lighten|color-dodge|color-burn|hard-light|soft-light|difference|exclusion|hue|saturation|color|luminosity",
    "box": "border-box|padding-box|content-box",
    "brightness()": "brightness( <number-percentage> )",
    "calc()": "calc( <calc-sum> )",
    "calc-sum": "<calc-product> [['+'|'-'] <calc-product>]*",
    "calc-product": "<calc-value> ['*' <calc-value>|'/' <number>]*",
    "calc-value": "<number>|<dimension>|<percentage>|( <calc-sum> )",
    "cf-final-image": "<image>|<color>",
    "cf-mixing-image": "<percentage>?&&<image>",
    "circle()": "circle( [<shape-radius>]? [at <position>]? )",
    "clamp()": "clamp( <calc-sum>#{3} )",
    "class-selector": "'.' <ident-token>",
    "clip-source": "<url>",
    "color": "<rgb()>|<rgba()>|<hsl()>|<hsla()>|<hwb()>|<lab()>|<lch()>|<hex-color>|<named-color>|currentcolor|<deprecated-system-color>",
    "color-stop": "<color-stop-length>|<color-stop-angle>",
    "color-stop-angle": "<angle-percentage>{1,2}",
    "color-stop-length": "<length-percentage>{1,2}",
    "color-stop-list": "[<linear-color-stop> [, <linear-color-hint>]?]# , <linear-color-stop>",
    "combinator": "'>'|'+'|'~'|['||']",
    "common-lig-values": "[common-ligatures|no-common-ligatures]",
    "compat-auto": "searchfield|textarea|push-button|slider-horizontal|checkbox|radio|square-button|menulist|listbox|meter|progress-bar|button",
    "composite-style": "clear|copy|source-over|source-in|source-out|source-atop|destination-over|destination-in|destination-out|destination-atop|xor",
    "compositing-operator": "add|subtract|intersect|exclude",
    "compound-selector": "[<type-selector>? <subclass-selector>* [<pseudo-element-selector> <pseudo-class-selector>*]*]!",
    "compound-selector-list": "<compound-selector>#",
    "complex-selector": "<compound-selector> [<combinator>? <compound-selector>]*",
    "complex-selector-list": "<complex-selector>#",
    "conic-gradient()": "conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )",
    "contextual-alt-values": "[contextual|no-contextual]",
    "content-distribution": "space-between|space-around|space-evenly|stretch",
    "content-list": "[<string>|contents|<image>|<counter>|<quote>|<target>|<leader()>|<attr()>]+",
    "content-position": "center|start|end|flex-start|flex-end",
    "content-replacement": "<image>",
    "contrast()": "contrast( [<number-percentage>] )",
    "counter": "<counter()>|<counters()>",
    "counter()": "counter( <counter-name> , <counter-style>? )",
    "counter-name": "<custom-ident>",
    "counter-style": "<counter-style-name>|symbols( )",
    "counter-style-name": "<custom-ident>",
    "counters()": "counters( <counter-name> , <string> , <counter-style>? )",
    "cross-fade()": "cross-fade( <cf-mixing-image> , <cf-final-image>? )",
    "cubic-bezier-timing-function": "ease|ease-in|ease-out|ease-in-out|cubic-bezier( <number [0,1]> , <number> , <number [0,1]> , <number> )",
    "deprecated-system-color": "ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText",
    "discretionary-lig-values": "[discretionary-ligatures|no-discretionary-ligatures]",
    "display-box": "contents|none",
    "display-inside": "flow|flow-root|table|flex|grid|ruby",
    "display-internal": "table-row-group|table-header-group|table-footer-group|table-row|table-cell|table-column-group|table-column|table-caption|ruby-base|ruby-text|ruby-base-container|ruby-text-container",
    "display-legacy": "inline-block|inline-list-item|inline-table|inline-flex|inline-grid",
    "display-listitem": "<display-outside>?&&[flow|flow-root]?&&list-item",
    "display-outside": "block|inline|run-in",
    "drop-shadow()": "drop-shadow( <length>{2,3} <color>? )",
    "east-asian-variant-values": "[jis78|jis83|jis90|jis04|simplified|traditional]",
    "east-asian-width-values": "[full-width|proportional-width]",
    "element()": "element( <custom-ident> , [first|start|last|first-except]? )|element( <id-selector> )",
    "ellipse()": "ellipse( [<shape-radius>{2}]? [at <position>]? )",
    "ending-shape": "circle|ellipse",
    "env()": "env( <custom-ident> , <declaration-value>? )",
    "explicit-track-list": "[<line-names>? <track-size>]+ <line-names>?",
    "family-name": "<string>|<custom-ident>+",
    "feature-tag-value": "<string> [<integer>|on|off]?",
    "feature-type": "@stylistic|@historical-forms|/styleset|@character-variant|@swash|@ornaments|@annotation",
    "feature-value-block": "<feature-type> '{' <feature-value-declaration-list> '}'",
    "feature-value-block-list": "<feature-value-block>+",
    "feature-value-declaration": "<custom-ident> : <integer>+ ;",
    "feature-value-declaration-list": "<feature-value-declaration>",
    "feature-value-name": "<custom-ident>",
    "fill-rule": "nonzero|evenodd",
    "filter-function": "<blur()>|<brightness()>|<contrast()>|<drop-shadow()>|<grayscale()>|<hue-rotate()>|<invert()>|<opacity()>|<saturate()>|<sepia()>",
    "filter-function-list": "[<filter-function>|<url>]+",
    "final-bg-layer": "<'background-color'>||<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>",
    "fit-content()": "fit-content( [<length>|<percentage>] )",
    "fixed-breadth": "<length-percentage>",
    "fixed-repeat": "repeat( [<integer [1,∞]>] , [<line-names>? <fixed-size>]+ <line-names>? )",
    "fixed-size": "<fixed-breadth>|minmax( <fixed-breadth> , <track-breadth> )|minmax( <inflexible-breadth> , <fixed-breadth> )",
    "font-stretch-absolute": "normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded|<percentage>",
    "font-variant-css21": "[normal|small-caps]",
    "font-weight-absolute": "normal|bold|<number [1,1000]>",
    "frequency-percentage": "<frequency>|<percentage>",
    "general-enclosed": "[<function-token> <any-value> )]|( <ident> <any-value> )",
    "generic-family": "serif|sans-serif|cursive|fantasy|monospace|-apple-system",
    "generic-name": "serif|sans-serif|cursive|fantasy|monospace",
    "geometry-box": "<shape-box>|fill-box|stroke-box|view-box",
    "gradient": "<linear-gradient()>|<repeating-linear-gradient()>|<radial-gradient()>|<repeating-radial-gradient()>|<conic-gradient()>|<repeating-conic-gradient()>|<-legacy-gradient>",
    "grayscale()": "grayscale( <number-percentage> )",
    "grid-line": "auto|<custom-ident>|[<integer>&&<custom-ident>?]|[span&&[<integer>||<custom-ident>]]",
    "historical-lig-values": "[historical-ligatures|no-historical-ligatures]",
    "hsl()": "hsl( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsl( <hue> , <percentage> , <percentage> , <alpha-value>? )",
    "hsla()": "hsla( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsla( <hue> , <percentage> , <percentage> , <alpha-value>? )",
    "hue": "<number>|<angle>",
    "hue-rotate()": "hue-rotate( <angle> )",
    "hwb()": "hwb( [<hue>|none] [<percentage>|none] [<percentage>|none] [/ [<alpha-value>|none]]? )",
    "image": "<url>|<image()>|<image-set()>|<element()>|<paint()>|<cross-fade()>|<gradient>",
    "image()": "image( <image-tags>? [<image-src>? , <color>?]! )",
    "image-set()": "image-set( <image-set-option># )",
    "image-set-option": "[<image>|<string>] [<resolution>||type( <string> )]",
    "image-src": "<url>|<string>",
    "image-tags": "ltr|rtl",
    "inflexible-breadth": "<length>|<percentage>|min-content|max-content|auto",
    "inset()": "inset( <length-percentage>{1,4} [round <'border-radius'>]? )",
    "invert()": "invert( <number-percentage> )",
    "keyframes-name": "<custom-ident>|<string>",
    "keyframe-block": "<keyframe-selector># { <declaration-list> }",
    "keyframe-block-list": "<keyframe-block>+",
    "keyframe-selector": "from|to|<percentage>",
    "layer()": "layer( <layer-name> )",
    "layer-name": "<ident> ['.' <ident>]*",
    "leader()": "leader( <leader-type> )",
    "leader-type": "dotted|solid|space|<string>",
    "length-percentage": "<length>|<percentage>",
    "line-names": "'[' <custom-ident>* ']'",
    "line-name-list": "[<line-names>|<name-repeat>]+",
    "line-style": "none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset",
    "line-width": "<length>|thin|medium|thick",
    "linear-color-hint": "<length-percentage>",
    "linear-color-stop": "<color> <color-stop-length>?",
    "linear-gradient()": "linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )",
    "mask-layer": "<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||<geometry-box>||[<geometry-box>|no-clip]||<compositing-operator>||<masking-mode>",
    "mask-position": "[<length-percentage>|left|center|right] [<length-percentage>|top|center|bottom]?",
    "mask-reference": "none|<image>|<mask-source>",
    "mask-source": "<url>",
    "masking-mode": "alpha|luminance|match-source",
    "matrix()": "matrix( <number>#{6} )",
    "matrix3d()": "matrix3d( <number>#{16} )",
    "max()": "max( <calc-sum># )",
    "media-and": "<media-in-parens> [and <media-in-parens>]+",
    "media-condition": "<media-not>|<media-and>|<media-or>|<media-in-parens>",
    "media-condition-without-or": "<media-not>|<media-and>|<media-in-parens>",
    "media-feature": "( [<mf-plain>|<mf-boolean>|<mf-range>] )",
    "media-in-parens": "( <media-condition> )|<media-feature>|<general-enclosed>",
    "media-not": "not <media-in-parens>",
    "media-or": "<media-in-parens> [or <media-in-parens>]+",
    "media-query": "<media-condition>|[not|only]? <media-type> [and <media-condition-without-or>]?",
    "media-query-list": "<media-query>#",
    "media-type": "<ident>",
    "mf-boolean": "<mf-name>",
    "mf-name": "<ident>",
    "mf-plain": "<mf-name> : <mf-value>",
    "mf-range": "<mf-name> ['<'|'>']? '='? <mf-value>|<mf-value> ['<'|'>']? '='? <mf-name>|<mf-value> '<' '='? <mf-name> '<' '='? <mf-value>|<mf-value> '>' '='? <mf-name> '>' '='? <mf-value>",
    "mf-value": "<number>|<dimension>|<ident>|<ratio>",
    "min()": "min( <calc-sum># )",
    "minmax()": "minmax( [<length>|<percentage>|min-content|max-content|auto] , [<length>|<percentage>|<flex>|min-content|max-content|auto] )",
    "name-repeat": "repeat( [<integer [1,∞]>|auto-fill] , <line-names>+ )",
    "named-color": "transparent|aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|rebeccapurple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|violet|wheat|white|whitesmoke|yellow|yellowgreen|<-non-standard-color>",
    "namespace-prefix": "<ident>",
    "ns-prefix": "[<ident-token>|'*']? '|'",
    "number-percentage": "<number>|<percentage>",
    "numeric-figure-values": "[lining-nums|oldstyle-nums]",
    "numeric-fraction-values": "[diagonal-fractions|stacked-fractions]",
    "numeric-spacing-values": "[proportional-nums|tabular-nums]",
    "nth": "<an-plus-b>|even|odd",
    "opacity()": "opacity( [<number-percentage>] )",
    "overflow-position": "unsafe|safe",
    "outline-radius": "<length>|<percentage>",
    "page-body": "<declaration>? [; <page-body>]?|<page-margin-box> <page-body>",
    "page-margin-box": "<page-margin-box-type> '{' <declaration-list> '}'",
    "page-margin-box-type": "@top-left-corner|@top-left|@top-center|@top-right|@top-right-corner|@bottom-left-corner|@bottom-left|@bottom-center|@bottom-right|@bottom-right-corner|@left-top|@left-middle|@left-bottom|@right-top|@right-middle|@right-bottom",
    "page-selector-list": "[<page-selector>#]?",
    "page-selector": "<pseudo-page>+|<ident> <pseudo-page>*",
    "page-size": "A5|A4|A3|B5|B4|JIS-B5|JIS-B4|letter|legal|ledger",
    "path()": "path( [<fill-rule> ,]? <string> )",
    "paint()": "paint( <ident> , <declaration-value>? )",
    "perspective()": "perspective( <length> )",
    "polygon()": "polygon( <fill-rule>? , [<length-percentage> <length-percentage>]# )",
    "position": "[[left|center|right]||[top|center|bottom]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]?|[[left|right] <length-percentage>]&&[[top|bottom] <length-percentage>]]",
    "pseudo-class-selector": "':' <ident-token>|':' <function-token> <any-value> ')'",
    "pseudo-element-selector": "':' <pseudo-class-selector>",
    "pseudo-page": ": [left|right|first|blank]",
    "quote": "open-quote|close-quote|no-open-quote|no-close-quote",
    "radial-gradient()": "radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )",
    "relative-selector": "<combinator>? <complex-selector>",
    "relative-selector-list": "<relative-selector>#",
    "relative-size": "larger|smaller",
    "repeat-style": "repeat-x|repeat-y|[repeat|space|round|no-repeat]{1,2}",
    "repeating-conic-gradient()": "repeating-conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )",
    "repeating-linear-gradient()": "repeating-linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )",
    "repeating-radial-gradient()": "repeating-radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )",
    "rgb()": "rgb( <percentage>{3} [/ <alpha-value>]? )|rgb( <number>{3} [/ <alpha-value>]? )|rgb( <percentage>#{3} , <alpha-value>? )|rgb( <number>#{3} , <alpha-value>? )",
    "rgba()": "rgba( <percentage>{3} [/ <alpha-value>]? )|rgba( <number>{3} [/ <alpha-value>]? )|rgba( <percentage>#{3} , <alpha-value>? )|rgba( <number>#{3} , <alpha-value>? )",
    "rotate()": "rotate( [<angle>|<zero>] )",
    "rotate3d()": "rotate3d( <number> , <number> , <number> , [<angle>|<zero>] )",
    "rotateX()": "rotateX( [<angle>|<zero>] )",
    "rotateY()": "rotateY( [<angle>|<zero>] )",
    "rotateZ()": "rotateZ( [<angle>|<zero>] )",
    "saturate()": "saturate( <number-percentage> )",
    "scale()": "scale( <number> , <number>? )",
    "scale3d()": "scale3d( <number> , <number> , <number> )",
    "scaleX()": "scaleX( <number> )",
    "scaleY()": "scaleY( <number> )",
    "scaleZ()": "scaleZ( <number> )",
    "self-position": "center|start|end|self-start|self-end|flex-start|flex-end",
    "shape-radius": "<length-percentage>|closest-side|farthest-side",
    "skew()": "skew( [<angle>|<zero>] , [<angle>|<zero>]? )",
    "skewX()": "skewX( [<angle>|<zero>] )",
    "skewY()": "skewY( [<angle>|<zero>] )",
    "sepia()": "sepia( <number-percentage> )",
    "shadow": "inset?&&<length>{2,4}&&<color>?",
    "shadow-t": "[<length>{2,3}&&<color>?]",
    "shape": "rect( <top> , <right> , <bottom> , <left> )|rect( <top> <right> <bottom> <left> )",
    "shape-box": "<box>|margin-box",
    "side-or-corner": "[left|right]||[top|bottom]",
    "single-animation": "<time>||<easing-function>||<time>||<single-animation-iteration-count>||<single-animation-direction>||<single-animation-fill-mode>||<single-animation-play-state>||[none|<keyframes-name>]",
    "single-animation-direction": "normal|reverse|alternate|alternate-reverse",
    "single-animation-fill-mode": "none|forwards|backwards|both",
    "single-animation-iteration-count": "infinite|<number>",
    "single-animation-play-state": "running|paused",
    "single-animation-timeline": "auto|none|<timeline-name>",
    "single-transition": "[none|<single-transition-property>]||<time>||<easing-function>||<time>",
    "single-transition-property": "all|<custom-ident>",
    "size": "closest-side|farthest-side|closest-corner|farthest-corner|<length>|<length-percentage>{2}",
    "step-position": "jump-start|jump-end|jump-none|jump-both|start|end",
    "step-timing-function": "step-start|step-end|steps( <integer> [, <step-position>]? )",
    "subclass-selector": "<id-selector>|<class-selector>|<attribute-selector>|<pseudo-class-selector>",
    "supports-condition": "not <supports-in-parens>|<supports-in-parens> [and <supports-in-parens>]*|<supports-in-parens> [or <supports-in-parens>]*",
    "supports-in-parens": "( <supports-condition> )|<supports-feature>|<general-enclosed>",
    "supports-feature": "<supports-decl>|<supports-selector-fn>",
    "supports-decl": "( <declaration> )",
    "supports-selector-fn": "selector( <complex-selector> )",
    "symbol": "<string>|<image>|<custom-ident>",
    "target": "<target-counter()>|<target-counters()>|<target-text()>",
    "target-counter()": "target-counter( [<string>|<url>] , <custom-ident> , <counter-style>? )",
    "target-counters()": "target-counters( [<string>|<url>] , <custom-ident> , <string> , <counter-style>? )",
    "target-text()": "target-text( [<string>|<url>] , [content|before|after|first-letter]? )",
    "time-percentage": "<time>|<percentage>",
    "timeline-name": "<custom-ident>|<string>",
    "easing-function": "linear|<cubic-bezier-timing-function>|<step-timing-function>",
    "track-breadth": "<length-percentage>|<flex>|min-content|max-content|auto",
    "track-list": "[<line-names>? [<track-size>|<track-repeat>]]+ <line-names>?",
    "track-repeat": "repeat( [<integer [1,∞]>] , [<line-names>? <track-size>]+ <line-names>? )",
    "track-size": "<track-breadth>|minmax( <inflexible-breadth> , <track-breadth> )|fit-content( [<length>|<percentage>] )",
    "transform-function": "<matrix()>|<translate()>|<translateX()>|<translateY()>|<scale()>|<scaleX()>|<scaleY()>|<rotate()>|<skew()>|<skewX()>|<skewY()>|<matrix3d()>|<translate3d()>|<translateZ()>|<scale3d()>|<scaleZ()>|<rotate3d()>|<rotateX()>|<rotateY()>|<rotateZ()>|<perspective()>",
    "transform-list": "<transform-function>+",
    "translate()": "translate( <length-percentage> , <length-percentage>? )",
    "translate3d()": "translate3d( <length-percentage> , <length-percentage> , <length> )",
    "translateX()": "translateX( <length-percentage> )",
    "translateY()": "translateY( <length-percentage> )",
    "translateZ()": "translateZ( <length> )",
    "type-or-unit": "string|color|url|integer|number|length|angle|time|frequency|cap|ch|em|ex|ic|lh|rlh|rem|vb|vi|vw|vh|vmin|vmax|mm|Q|cm|in|pt|pc|px|deg|grad|rad|turn|ms|s|Hz|kHz|%",
    "type-selector": "<wq-name>|<ns-prefix>? '*'",
    "var()": "var( <custom-property-name> , <declaration-value>? )",
    "viewport-length": "auto|<length-percentage>",
    "visual-box": "content-box|padding-box|border-box",
    "wq-name": "<ns-prefix>? <ident-token>",
    "-legacy-gradient": "<-webkit-gradient()>|<-legacy-linear-gradient>|<-legacy-repeating-linear-gradient>|<-legacy-radial-gradient>|<-legacy-repeating-radial-gradient>",
    "-legacy-linear-gradient": "-moz-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-linear-gradient( <-legacy-linear-gradient-arguments> )",
    "-legacy-repeating-linear-gradient": "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )",
    "-legacy-linear-gradient-arguments": "[<angle>|<side-or-corner>]? , <color-stop-list>",
    "-legacy-radial-gradient": "-moz-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-radial-gradient( <-legacy-radial-gradient-arguments> )",
    "-legacy-repeating-radial-gradient": "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )",
    "-legacy-radial-gradient-arguments": "[<position> ,]? [[[<-legacy-radial-gradient-shape>||<-legacy-radial-gradient-size>]|[<length>|<percentage>]{2}] ,]? <color-stop-list>",
    "-legacy-radial-gradient-size": "closest-side|closest-corner|farthest-side|farthest-corner|contain|cover",
    "-legacy-radial-gradient-shape": "circle|ellipse",
    "-non-standard-font": "-apple-system-body|-apple-system-headline|-apple-system-subheadline|-apple-system-caption1|-apple-system-caption2|-apple-system-footnote|-apple-system-short-body|-apple-system-short-headline|-apple-system-short-subheadline|-apple-system-short-caption1|-apple-system-short-footnote|-apple-system-tall-body",
    "-non-standard-color": "-moz-ButtonDefault|-moz-ButtonHoverFace|-moz-ButtonHoverText|-moz-CellHighlight|-moz-CellHighlightText|-moz-Combobox|-moz-ComboboxText|-moz-Dialog|-moz-DialogText|-moz-dragtargetzone|-moz-EvenTreeRow|-moz-Field|-moz-FieldText|-moz-html-CellHighlight|-moz-html-CellHighlightText|-moz-mac-accentdarkestshadow|-moz-mac-accentdarkshadow|-moz-mac-accentface|-moz-mac-accentlightesthighlight|-moz-mac-accentlightshadow|-moz-mac-accentregularhighlight|-moz-mac-accentregularshadow|-moz-mac-chrome-active|-moz-mac-chrome-inactive|-moz-mac-focusring|-moz-mac-menuselect|-moz-mac-menushadow|-moz-mac-menutextselect|-moz-MenuHover|-moz-MenuHoverText|-moz-MenuBarText|-moz-MenuBarHoverText|-moz-nativehyperlinktext|-moz-OddTreeRow|-moz-win-communicationstext|-moz-win-mediatext|-moz-activehyperlinktext|-moz-default-background-color|-moz-default-color|-moz-hyperlinktext|-moz-visitedhyperlinktext|-webkit-activelink|-webkit-focus-ring-color|-webkit-link|-webkit-text",
    "-non-standard-image-rendering": "optimize-contrast|-moz-crisp-edges|-o-crisp-edges|-webkit-optimize-contrast",
    "-non-standard-overflow": "-moz-scrollbars-none|-moz-scrollbars-horizontal|-moz-scrollbars-vertical|-moz-hidden-unscrollable",
    "-non-standard-width": "fill-available|min-intrinsic|intrinsic|-moz-available|-moz-fit-content|-moz-min-content|-moz-max-content|-webkit-min-content|-webkit-max-content",
    "-webkit-gradient()": "-webkit-gradient( <-webkit-gradient-type> , <-webkit-gradient-point> [, <-webkit-gradient-point>|, <-webkit-gradient-radius> , <-webkit-gradient-point>] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )",
    "-webkit-gradient-color-stop": "from( <color> )|color-stop( [<number-zero-one>|<percentage>] , <color> )|to( <color> )",
    "-webkit-gradient-point": "[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]",
    "-webkit-gradient-radius": "<length>|<percentage>",
    "-webkit-gradient-type": "linear|radial",
    "-webkit-mask-box-repeat": "repeat|stretch|round",
    "-webkit-mask-clip-style": "border|border-box|padding|padding-box|content|content-box|text",
    "-ms-filter-function-list": "<-ms-filter-function>+",
    "-ms-filter-function": "<-ms-filter-function-progid>|<-ms-filter-function-legacy>",
    "-ms-filter-function-progid": "'progid:' [<ident-token> '.']* [<ident-token>|<function-token> <any-value>? )]",
    "-ms-filter-function-legacy": "<ident-token>|<function-token> <any-value>? )",
    "-ms-filter": "<string>",
    "age": "child|young|old",
    "attr-name": "<wq-name>",
    "attr-fallback": "<any-value>",
    "bg-clip": "<box>|border|text",
    "border-radius": "<length-percentage>{1,2}",
    "bottom": "<length>|auto",
    "generic-voice": "[<age>? <gender> <integer>?]",
    "gender": "male|female|neutral",
    "lab()": "lab( [<percentage>|<number>|none] [<percentage>|<number>|none] [<percentage>|<number>|none] [/ [<alpha-value>|none]]? )",
    "lch()": "lch( [<percentage>|<number>|none] [<percentage>|<number>|none] [<hue>|none] [/ [<alpha-value>|none]]? )",
    "left": "<length>|auto",
    "mask-image": "<mask-reference>#",
    "paint": "none|<color>|<url> [none|<color>]?|context-fill|context-stroke",
    "ratio": "<number [0,∞]> [/ <number [0,∞]>]?",
    "reversed-counter-name": "reversed( <counter-name> )",
    "right": "<length>|auto",
    "svg-length": "<percentage>|<length>|<number>",
    "svg-writing-mode": "lr-tb|rl-tb|tb-rl|lr|rl|tb",
    "top": "<length>|auto",
    "track-group": "'(' [<string>* <track-minmax> <string>*]+ ')' ['[' <positive-integer> ']']?|<track-minmax>",
    "track-list-v0": "[<string>* <track-group> <string>*]+|none",
    "track-minmax": "minmax( <track-breadth> , <track-breadth> )|auto|<track-breadth>|fit-content",
    "x": "<number>",
    "y": "<number>",
    "declaration": "<ident-token> : <declaration-value>? ['!' important]?",
    "declaration-list": "[<declaration>? ';']* <declaration>?",
    "url": "url( <string> <url-modifier>* )|<url-token>",
    "url-modifier": "<ident>|<function-token> <any-value> )",
    "number-zero-one": "<number [0,1]>",
    "number-one-or-greater": "<number [1,∞]>",
    "positive-integer": "<integer [0,∞]>",
    "-non-standard-display": "-ms-inline-flexbox|-ms-grid|-ms-inline-grid|-webkit-flex|-webkit-inline-flex|-webkit-box|-webkit-inline-box|-moz-inline-stack|-moz-box|-moz-inline-box"
  },
  "properties": {
    "--*": "<declaration-value>",
    "-ms-accelerator": "false|true",
    "-ms-block-progression": "tb|rl|bt|lr",
    "-ms-content-zoom-chaining": "none|chained",
    "-ms-content-zooming": "none|zoom",
    "-ms-content-zoom-limit": "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
    "-ms-content-zoom-limit-max": "<percentage>",
    "-ms-content-zoom-limit-min": "<percentage>",
    "-ms-content-zoom-snap": "<'-ms-content-zoom-snap-type'>||<'-ms-content-zoom-snap-points'>",
    "-ms-content-zoom-snap-points": "snapInterval( <percentage> , <percentage> )|snapList( <percentage># )",
    "-ms-content-zoom-snap-type": "none|proximity|mandatory",
    "-ms-filter": "<string>",
    "-ms-flow-from": "[none|<custom-ident>]#",
    "-ms-flow-into": "[none|<custom-ident>]#",
    "-ms-grid-columns": "none|<track-list>|<auto-track-list>",
    "-ms-grid-rows": "none|<track-list>|<auto-track-list>",
    "-ms-high-contrast-adjust": "auto|none",
    "-ms-hyphenate-limit-chars": "auto|<integer>{1,3}",
    "-ms-hyphenate-limit-lines": "no-limit|<integer>",
    "-ms-hyphenate-limit-zone": "<percentage>|<length>",
    "-ms-ime-align": "auto|after",
    "-ms-overflow-style": "auto|none|scrollbar|-ms-autohiding-scrollbar",
    "-ms-scrollbar-3dlight-color": "<color>",
    "-ms-scrollbar-arrow-color": "<color>",
    "-ms-scrollbar-base-color": "<color>",
    "-ms-scrollbar-darkshadow-color": "<color>",
    "-ms-scrollbar-face-color": "<color>",
    "-ms-scrollbar-highlight-color": "<color>",
    "-ms-scrollbar-shadow-color": "<color>",
    "-ms-scrollbar-track-color": "<color>",
    "-ms-scroll-chaining": "chained|none",
    "-ms-scroll-limit": "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
    "-ms-scroll-limit-x-max": "auto|<length>",
    "-ms-scroll-limit-x-min": "<length>",
    "-ms-scroll-limit-y-max": "auto|<length>",
    "-ms-scroll-limit-y-min": "<length>",
    "-ms-scroll-rails": "none|railed",
    "-ms-scroll-snap-points-x": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )",
    "-ms-scroll-snap-points-y": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )",
    "-ms-scroll-snap-type": "none|proximity|mandatory",
    "-ms-scroll-snap-x": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
    "-ms-scroll-snap-y": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
    "-ms-scroll-translation": "none|vertical-to-horizontal",
    "-ms-text-autospace": "none|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space",
    "-ms-touch-select": "grippers|none",
    "-ms-user-select": "none|element|text",
    "-ms-wrap-flow": "auto|both|start|end|maximum|clear",
    "-ms-wrap-margin": "<length>",
    "-ms-wrap-through": "wrap|none",
    "-moz-appearance": "none|button|button-arrow-down|button-arrow-next|button-arrow-previous|button-arrow-up|button-bevel|button-focus|caret|checkbox|checkbox-container|checkbox-label|checkmenuitem|dualbutton|groupbox|listbox|listitem|menuarrow|menubar|menucheckbox|menuimage|menuitem|menuitemtext|menulist|menulist-button|menulist-text|menulist-textfield|menupopup|menuradio|menuseparator|meterbar|meterchunk|progressbar|progressbar-vertical|progresschunk|progresschunk-vertical|radio|radio-container|radio-label|radiomenuitem|range|range-thumb|resizer|resizerpanel|scale-horizontal|scalethumbend|scalethumb-horizontal|scalethumbstart|scalethumbtick|scalethumb-vertical|scale-vertical|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|separator|sheet|spinner|spinner-downbutton|spinner-textfield|spinner-upbutton|splitter|statusbar|statusbarpanel|tab|tabpanel|tabpanels|tab-scroll-arrow-back|tab-scroll-arrow-forward|textfield|textfield-multiline|toolbar|toolbarbutton|toolbarbutton-dropdown|toolbargripper|toolbox|tooltip|treeheader|treeheadercell|treeheadersortarrow|treeitem|treeline|treetwisty|treetwistyopen|treeview|-moz-mac-unified-toolbar|-moz-win-borderless-glass|-moz-win-browsertabbar-toolbox|-moz-win-communicationstext|-moz-win-communications-toolbox|-moz-win-exclude-glass|-moz-win-glass|-moz-win-mediatext|-moz-win-media-toolbox|-moz-window-button-box|-moz-window-button-box-maximized|-moz-window-button-close|-moz-window-button-maximize|-moz-window-button-minimize|-moz-window-button-restore|-moz-window-frame-bottom|-moz-window-frame-left|-moz-window-frame-right|-moz-window-titlebar|-moz-window-titlebar-maximized",
    "-moz-binding": "<url>|none",
    "-moz-border-bottom-colors": "<color>+|none",
    "-moz-border-left-colors": "<color>+|none",
    "-moz-border-right-colors": "<color>+|none",
    "-moz-border-top-colors": "<color>+|none",
    "-moz-context-properties": "none|[fill|fill-opacity|stroke|stroke-opacity]#",
    "-moz-float-edge": "border-box|content-box|margin-box|padding-box",
    "-moz-force-broken-image-icon": "0|1",
    "-moz-image-region": "<shape>|auto",
    "-moz-orient": "inline|block|horizontal|vertical",
    "-moz-outline-radius": "<outline-radius>{1,4} [/ <outline-radius>{1,4}]?",
    "-moz-outline-radius-bottomleft": "<outline-radius>",
    "-moz-outline-radius-bottomright": "<outline-radius>",
    "-moz-outline-radius-topleft": "<outline-radius>",
    "-moz-outline-radius-topright": "<outline-radius>",
    "-moz-stack-sizing": "ignore|stretch-to-fit",
    "-moz-text-blink": "none|blink",
    "-moz-user-focus": "ignore|normal|select-after|select-before|select-menu|select-same|select-all|none",
    "-moz-user-input": "auto|none|enabled|disabled",
    "-moz-user-modify": "read-only|read-write|write-only",
    "-moz-window-dragging": "drag|no-drag",
    "-moz-window-shadow": "default|menu|tooltip|sheet|none",
    "-webkit-appearance": "none|button|button-bevel|caps-lock-indicator|caret|checkbox|default-button|inner-spin-button|listbox|listitem|media-controls-background|media-controls-fullscreen-background|media-current-time-display|media-enter-fullscreen-button|media-exit-fullscreen-button|media-fullscreen-button|media-mute-button|media-overlay-play-button|media-play-button|media-seek-back-button|media-seek-forward-button|media-slider|media-sliderthumb|media-time-remaining-display|media-toggle-closed-captions-button|media-volume-slider|media-volume-slider-container|media-volume-sliderthumb|menulist|menulist-button|menulist-text|menulist-textfield|meter|progress-bar|progress-bar-value|push-button|radio|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbargripper-horizontal|scrollbargripper-vertical|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|searchfield-cancel-button|searchfield-decoration|searchfield-results-button|searchfield-results-decoration|slider-horizontal|slider-vertical|sliderthumb-horizontal|sliderthumb-vertical|square-button|textarea|textfield|-apple-pay-button",
    "-webkit-border-before": "<'border-width'>||<'border-style'>||<color>",
    "-webkit-border-before-color": "<color>",
    "-webkit-border-before-style": "<'border-style'>",
    "-webkit-border-before-width": "<'border-width'>",
    "-webkit-box-reflect": "[above|below|right|left]? <length>? <image>?",
    "-webkit-line-clamp": "none|<integer>",
    "-webkit-mask": "[<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||[<box>|border|padding|content|text]||[<box>|border|padding|content]]#",
    "-webkit-mask-attachment": "<attachment>#",
    "-webkit-mask-clip": "[<box>|border|padding|content|text]#",
    "-webkit-mask-composite": "<composite-style>#",
    "-webkit-mask-image": "<mask-reference>#",
    "-webkit-mask-origin": "[<box>|border|padding|content]#",
    "-webkit-mask-position": "<position>#",
    "-webkit-mask-position-x": "[<length-percentage>|left|center|right]#",
    "-webkit-mask-position-y": "[<length-percentage>|top|center|bottom]#",
    "-webkit-mask-repeat": "<repeat-style>#",
    "-webkit-mask-repeat-x": "repeat|no-repeat|space|round",
    "-webkit-mask-repeat-y": "repeat|no-repeat|space|round",
    "-webkit-mask-size": "<bg-size>#",
    "-webkit-overflow-scrolling": "auto|touch",
    "-webkit-tap-highlight-color": "<color>",
    "-webkit-text-fill-color": "<color>",
    "-webkit-text-stroke": "<length>||<color>",
    "-webkit-text-stroke-color": "<color>",
    "-webkit-text-stroke-width": "<length>",
    "-webkit-touch-callout": "default|none",
    "-webkit-user-modify": "read-only|read-write|read-write-plaintext-only",
    "accent-color": "auto|<color>",
    "align-content": "normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>",
    "align-items": "normal|stretch|<baseline-position>|[<overflow-position>? <self-position>]",
    "align-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? <self-position>",
    "align-tracks": "[normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>]#",
    "all": "initial|inherit|unset|revert|revert-layer",
    "animation": "<single-animation>#",
    "animation-delay": "<time>#",
    "animation-direction": "<single-animation-direction>#",
    "animation-duration": "<time>#",
    "animation-fill-mode": "<single-animation-fill-mode>#",
    "animation-iteration-count": "<single-animation-iteration-count>#",
    "animation-name": "[none|<keyframes-name>]#",
    "animation-play-state": "<single-animation-play-state>#",
    "animation-timing-function": "<easing-function>#",
    "animation-timeline": "<single-animation-timeline>#",
    "appearance": "none|auto|textfield|menulist-button|<compat-auto>",
    "aspect-ratio": "auto|<ratio>",
    "azimuth": "<angle>|[[left-side|far-left|left|center-left|center|center-right|right|far-right|right-side]||behind]|leftwards|rightwards",
    "backdrop-filter": "none|<filter-function-list>",
    "backface-visibility": "visible|hidden",
    "background": "[<bg-layer> ,]* <final-bg-layer>",
    "background-attachment": "<attachment>#",
    "background-blend-mode": "<blend-mode>#",
    "background-clip": "<bg-clip>#",
    "background-color": "<color>",
    "background-image": "<bg-image>#",
    "background-origin": "<box>#",
    "background-position": "<bg-position>#",
    "background-position-x": "[center|[[left|right|x-start|x-end]? <length-percentage>?]!]#",
    "background-position-y": "[center|[[top|bottom|y-start|y-end]? <length-percentage>?]!]#",
    "background-repeat": "<repeat-style>#",
    "background-size": "<bg-size>#",
    "block-overflow": "clip|ellipsis|<string>",
    "block-size": "<'width'>",
    "border": "<line-width>||<line-style>||<color>",
    "border-block": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-block-color": "<'border-top-color'>{1,2}",
    "border-block-style": "<'border-top-style'>",
    "border-block-width": "<'border-top-width'>",
    "border-block-end": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-block-end-color": "<'border-top-color'>",
    "border-block-end-style": "<'border-top-style'>",
    "border-block-end-width": "<'border-top-width'>",
    "border-block-start": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-block-start-color": "<'border-top-color'>",
    "border-block-start-style": "<'border-top-style'>",
    "border-block-start-width": "<'border-top-width'>",
    "border-bottom": "<line-width>||<line-style>||<color>",
    "border-bottom-color": "<'border-top-color'>",
    "border-bottom-left-radius": "<length-percentage>{1,2}",
    "border-bottom-right-radius": "<length-percentage>{1,2}",
    "border-bottom-style": "<line-style>",
    "border-bottom-width": "<line-width>",
    "border-collapse": "collapse|separate",
    "border-color": "<color>{1,4}",
    "border-end-end-radius": "<length-percentage>{1,2}",
    "border-end-start-radius": "<length-percentage>{1,2}",
    "border-image": "<'border-image-source'>||<'border-image-slice'> [/ <'border-image-width'>|/ <'border-image-width'>? / <'border-image-outset'>]?||<'border-image-repeat'>",
    "border-image-outset": "[<length>|<number>]{1,4}",
    "border-image-repeat": "[stretch|repeat|round|space]{1,2}",
    "border-image-slice": "<number-percentage>{1,4}&&fill?",
    "border-image-source": "none|<image>",
    "border-image-width": "[<length-percentage>|<number>|auto]{1,4}",
    "border-inline": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-inline-end": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-inline-color": "<'border-top-color'>{1,2}",
    "border-inline-style": "<'border-top-style'>",
    "border-inline-width": "<'border-top-width'>",
    "border-inline-end-color": "<'border-top-color'>",
    "border-inline-end-style": "<'border-top-style'>",
    "border-inline-end-width": "<'border-top-width'>",
    "border-inline-start": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-inline-start-color": "<'border-top-color'>",
    "border-inline-start-style": "<'border-top-style'>",
    "border-inline-start-width": "<'border-top-width'>",
    "border-left": "<line-width>||<line-style>||<color>",
    "border-left-color": "<color>",
    "border-left-style": "<line-style>",
    "border-left-width": "<line-width>",
    "border-radius": "<length-percentage>{1,4} [/ <length-percentage>{1,4}]?",
    "border-right": "<line-width>||<line-style>||<color>",
    "border-right-color": "<color>",
    "border-right-style": "<line-style>",
    "border-right-width": "<line-width>",
    "border-spacing": "<length> <length>?",
    "border-start-end-radius": "<length-percentage>{1,2}",
    "border-start-start-radius": "<length-percentage>{1,2}",
    "border-style": "<line-style>{1,4}",
    "border-top": "<line-width>||<line-style>||<color>",
    "border-top-color": "<color>",
    "border-top-left-radius": "<length-percentage>{1,2}",
    "border-top-right-radius": "<length-percentage>{1,2}",
    "border-top-style": "<line-style>",
    "border-top-width": "<line-width>",
    "border-width": "<line-width>{1,4}",
    "bottom": "<length>|<percentage>|auto",
    "box-align": "start|center|end|baseline|stretch",
    "box-decoration-break": "slice|clone",
    "box-direction": "normal|reverse|inherit",
    "box-flex": "<number>",
    "box-flex-group": "<integer>",
    "box-lines": "single|multiple",
    "box-ordinal-group": "<integer>",
    "box-orient": "horizontal|vertical|inline-axis|block-axis|inherit",
    "box-pack": "start|center|end|justify",
    "box-shadow": "none|<shadow>#",
    "box-sizing": "content-box|border-box",
    "break-after": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region",
    "break-before": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region",
    "break-inside": "auto|avoid|avoid-page|avoid-column|avoid-region",
    "caption-side": "top|bottom|block-start|block-end|inline-start|inline-end",
    "caret-color": "auto|<color>",
    "clear": "none|left|right|both|inline-start|inline-end",
    "clip": "<shape>|auto",
    "clip-path": "<clip-source>|[<basic-shape>||<geometry-box>]|none",
    "color": "<color>",
    "print-color-adjust": "economy|exact",
    "color-scheme": "normal|[light|dark|<custom-ident>]+&&only?",
    "column-count": "<integer>|auto",
    "column-fill": "auto|balance|balance-all",
    "column-gap": "normal|<length-percentage>",
    "column-rule": "<'column-rule-width'>||<'column-rule-style'>||<'column-rule-color'>",
    "column-rule-color": "<color>",
    "column-rule-style": "<'border-style'>",
    "column-rule-width": "<'border-width'>",
    "column-span": "none|all",
    "column-width": "<length>|auto",
    "columns": "<'column-width'>||<'column-count'>",
    "contain": "none|strict|content|[size||layout||style||paint]",
    "content": "normal|none|[<content-replacement>|<content-list>] [/ [<string>|<counter>]+]?",
    "content-visibility": "visible|auto|hidden",
    "counter-increment": "[<counter-name> <integer>?]+|none",
    "counter-reset": "[<counter-name> <integer>?|<reversed-counter-name> <integer>?]+|none",
    "counter-set": "[<counter-name> <integer>?]+|none",
    "cursor": "[[<url> [<x> <y>]? ,]* [auto|default|none|context-menu|help|pointer|progress|wait|cell|crosshair|text|vertical-text|alias|copy|move|no-drop|not-allowed|e-resize|n-resize|ne-resize|nw-resize|s-resize|se-resize|sw-resize|w-resize|ew-resize|ns-resize|nesw-resize|nwse-resize|col-resize|row-resize|all-scroll|zoom-in|zoom-out|grab|grabbing|hand|-webkit-grab|-webkit-grabbing|-webkit-zoom-in|-webkit-zoom-out|-moz-grab|-moz-grabbing|-moz-zoom-in|-moz-zoom-out]]",
    "direction": "ltr|rtl",
    "display": "[<display-outside>||<display-inside>]|<display-listitem>|<display-internal>|<display-box>|<display-legacy>|<-non-standard-display>",
    "empty-cells": "show|hide",
    "filter": "none|<filter-function-list>|<-ms-filter-function-list>",
    "flex": "none|[<'flex-grow'> <'flex-shrink'>?||<'flex-basis'>]",
    "flex-basis": "content|<'width'>",
    "flex-direction": "row|row-reverse|column|column-reverse",
    "flex-flow": "<'flex-direction'>||<'flex-wrap'>",
    "flex-grow": "<number>",
    "flex-shrink": "<number>",
    "flex-wrap": "nowrap|wrap|wrap-reverse",
    "float": "left|right|none|inline-start|inline-end",
    "font": "[[<'font-style'>||<font-variant-css21>||<'font-weight'>||<'font-stretch'>]? <'font-size'> [/ <'line-height'>]? <'font-family'>]|caption|icon|menu|message-box|small-caption|status-bar",
    "font-family": "[<family-name>|<generic-family>]#",
    "font-feature-settings": "normal|<feature-tag-value>#",
    "font-kerning": "auto|normal|none",
    "font-language-override": "normal|<string>",
    "font-optical-sizing": "auto|none",
    "font-variation-settings": "normal|[<string> <number>]#",
    "font-size": "<absolute-size>|<relative-size>|<length-percentage>",
    "font-size-adjust": "none|[ex-height|cap-height|ch-width|ic-width|ic-height]? [from-font|<number>]",
    "font-smooth": "auto|never|always|<absolute-size>|<length>",
    "font-stretch": "<font-stretch-absolute>",
    "font-style": "normal|italic|oblique <angle>?",
    "font-synthesis": "none|[weight||style||small-caps]",
    "font-variant": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>||stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )||[small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps]||<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero||<east-asian-variant-values>||<east-asian-width-values>||ruby]",
    "font-variant-alternates": "normal|[stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )]",
    "font-variant-caps": "normal|small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps",
    "font-variant-east-asian": "normal|[<east-asian-variant-values>||<east-asian-width-values>||ruby]",
    "font-variant-ligatures": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>]",
    "font-variant-numeric": "normal|[<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero]",
    "font-variant-position": "normal|sub|super",
    "font-weight": "<font-weight-absolute>|bolder|lighter",
    "forced-color-adjust": "auto|none",
    "gap": "<'row-gap'> <'column-gap'>?",
    "grid": "<'grid-template'>|<'grid-template-rows'> / [auto-flow&&dense?] <'grid-auto-columns'>?|[auto-flow&&dense?] <'grid-auto-rows'>? / <'grid-template-columns'>",
    "grid-area": "<grid-line> [/ <grid-line>]{0,3}",
    "grid-auto-columns": "<track-size>+",
    "grid-auto-flow": "[row|column]||dense",
    "grid-auto-rows": "<track-size>+",
    "grid-column": "<grid-line> [/ <grid-line>]?",
    "grid-column-end": "<grid-line>",
    "grid-column-gap": "<length-percentage>",
    "grid-column-start": "<grid-line>",
    "grid-gap": "<'grid-row-gap'> <'grid-column-gap'>?",
    "grid-row": "<grid-line> [/ <grid-line>]?",
    "grid-row-end": "<grid-line>",
    "grid-row-gap": "<length-percentage>",
    "grid-row-start": "<grid-line>",
    "grid-template": "none|[<'grid-template-rows'> / <'grid-template-columns'>]|[<line-names>? <string> <track-size>? <line-names>?]+ [/ <explicit-track-list>]?",
    "grid-template-areas": "none|<string>+",
    "grid-template-columns": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?",
    "grid-template-rows": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?",
    "hanging-punctuation": "none|[first||[force-end|allow-end]||last]",
    "height": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )",
    "hyphenate-character": "auto|<string>",
    "hyphens": "none|manual|auto",
    "image-orientation": "from-image|<angle>|[<angle>? flip]",
    "image-rendering": "auto|crisp-edges|pixelated|optimizeSpeed|optimizeQuality|<-non-standard-image-rendering>",
    "image-resolution": "[from-image||<resolution>]&&snap?",
    "ime-mode": "auto|normal|active|inactive|disabled",
    "initial-letter": "normal|[<number> <integer>?]",
    "initial-letter-align": "[auto|alphabetic|hanging|ideographic]",
    "inline-size": "<'width'>",
    "input-security": "auto|none",
    "inset": "<'top'>{1,4}",
    "inset-block": "<'top'>{1,2}",
    "inset-block-end": "<'top'>",
    "inset-block-start": "<'top'>",
    "inset-inline": "<'top'>{1,2}",
    "inset-inline-end": "<'top'>",
    "inset-inline-start": "<'top'>",
    "isolation": "auto|isolate",
    "justify-content": "normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]",
    "justify-items": "normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]|legacy|legacy&&[left|right|center]",
    "justify-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]",
    "justify-tracks": "[normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]]#",
    "left": "<length>|<percentage>|auto",
    "letter-spacing": "normal|<length-percentage>",
    "line-break": "auto|loose|normal|strict|anywhere",
    "line-clamp": "none|<integer>",
    "line-height": "normal|<number>|<length>|<percentage>",
    "line-height-step": "<length>",
    "list-style": "<'list-style-type'>||<'list-style-position'>||<'list-style-image'>",
    "list-style-image": "<image>|none",
    "list-style-position": "inside|outside",
    "list-style-type": "<counter-style>|<string>|none",
    "margin": "[<length>|<percentage>|auto]{1,4}",
    "margin-block": "<'margin-left'>{1,2}",
    "margin-block-end": "<'margin-left'>",
    "margin-block-start": "<'margin-left'>",
    "margin-bottom": "<length>|<percentage>|auto",
    "margin-inline": "<'margin-left'>{1,2}",
    "margin-inline-end": "<'margin-left'>",
    "margin-inline-start": "<'margin-left'>",
    "margin-left": "<length>|<percentage>|auto",
    "margin-right": "<length>|<percentage>|auto",
    "margin-top": "<length>|<percentage>|auto",
    "margin-trim": "none|in-flow|all",
    "mask": "<mask-layer>#",
    "mask-border": "<'mask-border-source'>||<'mask-border-slice'> [/ <'mask-border-width'>? [/ <'mask-border-outset'>]?]?||<'mask-border-repeat'>||<'mask-border-mode'>",
    "mask-border-mode": "luminance|alpha",
    "mask-border-outset": "[<length>|<number>]{1,4}",
    "mask-border-repeat": "[stretch|repeat|round|space]{1,2}",
    "mask-border-slice": "<number-percentage>{1,4} fill?",
    "mask-border-source": "none|<image>",
    "mask-border-width": "[<length-percentage>|<number>|auto]{1,4}",
    "mask-clip": "[<geometry-box>|no-clip]#",
    "mask-composite": "<compositing-operator>#",
    "mask-image": "<mask-reference>#",
    "mask-mode": "<masking-mode>#",
    "mask-origin": "<geometry-box>#",
    "mask-position": "<position>#",
    "mask-repeat": "<repeat-style>#",
    "mask-size": "<bg-size>#",
    "mask-type": "luminance|alpha",
    "masonry-auto-flow": "[pack|next]||[definite-first|ordered]",
    "math-style": "normal|compact",
    "max-block-size": "<'max-width'>",
    "max-height": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )",
    "max-inline-size": "<'max-width'>",
    "max-lines": "none|<integer>",
    "max-width": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|<-non-standard-width>",
    "min-block-size": "<'min-width'>",
    "min-height": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )",
    "min-inline-size": "<'min-width'>",
    "min-width": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|<-non-standard-width>",
    "mix-blend-mode": "<blend-mode>|plus-lighter",
    "object-fit": "fill|contain|cover|none|scale-down",
    "object-position": "<position>",
    "offset": "[<'offset-position'>? [<'offset-path'> [<'offset-distance'>||<'offset-rotate'>]?]?]! [/ <'offset-anchor'>]?",
    "offset-anchor": "auto|<position>",
    "offset-distance": "<length-percentage>",
    "offset-path": "none|ray( [<angle>&&<size>&&contain?] )|<path()>|<url>|[<basic-shape>||<geometry-box>]",
    "offset-position": "auto|<position>",
    "offset-rotate": "[auto|reverse]||<angle>",
    "opacity": "<alpha-value>",
    "order": "<integer>",
    "orphans": "<integer>",
    "outline": "[<'outline-color'>||<'outline-style'>||<'outline-width'>]",
    "outline-color": "<color>|invert",
    "outline-offset": "<length>",
    "outline-style": "auto|<'border-style'>",
    "outline-width": "<line-width>",
    "overflow": "[visible|hidden|clip|scroll|auto]{1,2}|<-non-standard-overflow>",
    "overflow-anchor": "auto|none",
    "overflow-block": "visible|hidden|clip|scroll|auto",
    "overflow-clip-box": "padding-box|content-box",
    "overflow-clip-margin": "<visual-box>||<length [0,∞]>",
    "overflow-inline": "visible|hidden|clip|scroll|auto",
    "overflow-wrap": "normal|break-word|anywhere",
    "overflow-x": "visible|hidden|clip|scroll|auto",
    "overflow-y": "visible|hidden|clip|scroll|auto",
    "overscroll-behavior": "[contain|none|auto]{1,2}",
    "overscroll-behavior-block": "contain|none|auto",
    "overscroll-behavior-inline": "contain|none|auto",
    "overscroll-behavior-x": "contain|none|auto",
    "overscroll-behavior-y": "contain|none|auto",
    "padding": "[<length>|<percentage>]{1,4}",
    "padding-block": "<'padding-left'>{1,2}",
    "padding-block-end": "<'padding-left'>",
    "padding-block-start": "<'padding-left'>",
    "padding-bottom": "<length>|<percentage>",
    "padding-inline": "<'padding-left'>{1,2}",
    "padding-inline-end": "<'padding-left'>",
    "padding-inline-start": "<'padding-left'>",
    "padding-left": "<length>|<percentage>",
    "padding-right": "<length>|<percentage>",
    "padding-top": "<length>|<percentage>",
    "page-break-after": "auto|always|avoid|left|right|recto|verso",
    "page-break-before": "auto|always|avoid|left|right|recto|verso",
    "page-break-inside": "auto|avoid",
    "paint-order": "normal|[fill||stroke||markers]",
    "perspective": "none|<length>",
    "perspective-origin": "<position>",
    "place-content": "<'align-content'> <'justify-content'>?",
    "place-items": "<'align-items'> <'justify-items'>?",
    "place-self": "<'align-self'> <'justify-self'>?",
    "pointer-events": "auto|none|visiblePainted|visibleFill|visibleStroke|visible|painted|fill|stroke|all|inherit",
    "position": "static|relative|absolute|sticky|fixed|-webkit-sticky",
    "quotes": "none|auto|[<string> <string>]+",
    "resize": "none|both|horizontal|vertical|block|inline",
    "right": "<length>|<percentage>|auto",
    "rotate": "none|<angle>|[x|y|z|<number>{3}]&&<angle>",
    "row-gap": "normal|<length-percentage>",
    "ruby-align": "start|center|space-between|space-around",
    "ruby-merge": "separate|collapse|auto",
    "ruby-position": "[alternate||[over|under]]|inter-character",
    "scale": "none|<number>{1,3}",
    "scrollbar-color": "auto|<color>{2}",
    "scrollbar-gutter": "auto|stable&&both-edges?",
    "scrollbar-width": "auto|thin|none",
    "scroll-behavior": "auto|smooth",
    "scroll-margin": "<length>{1,4}",
    "scroll-margin-block": "<length>{1,2}",
    "scroll-margin-block-start": "<length>",
    "scroll-margin-block-end": "<length>",
    "scroll-margin-bottom": "<length>",
    "scroll-margin-inline": "<length>{1,2}",
    "scroll-margin-inline-start": "<length>",
    "scroll-margin-inline-end": "<length>",
    "scroll-margin-left": "<length>",
    "scroll-margin-right": "<length>",
    "scroll-margin-top": "<length>",
    "scroll-padding": "[auto|<length-percentage>]{1,4}",
    "scroll-padding-block": "[auto|<length-percentage>]{1,2}",
    "scroll-padding-block-start": "auto|<length-percentage>",
    "scroll-padding-block-end": "auto|<length-percentage>",
    "scroll-padding-bottom": "auto|<length-percentage>",
    "scroll-padding-inline": "[auto|<length-percentage>]{1,2}",
    "scroll-padding-inline-start": "auto|<length-percentage>",
    "scroll-padding-inline-end": "auto|<length-percentage>",
    "scroll-padding-left": "auto|<length-percentage>",
    "scroll-padding-right": "auto|<length-percentage>",
    "scroll-padding-top": "auto|<length-percentage>",
    "scroll-snap-align": "[none|start|end|center]{1,2}",
    "scroll-snap-coordinate": "none|<position>#",
    "scroll-snap-destination": "<position>",
    "scroll-snap-points-x": "none|repeat( <length-percentage> )",
    "scroll-snap-points-y": "none|repeat( <length-percentage> )",
    "scroll-snap-stop": "normal|always",
    "scroll-snap-type": "none|[x|y|block|inline|both] [mandatory|proximity]?",
    "scroll-snap-type-x": "none|mandatory|proximity",
    "scroll-snap-type-y": "none|mandatory|proximity",
    "shape-image-threshold": "<alpha-value>",
    "shape-margin": "<length-percentage>",
    "shape-outside": "none|[<shape-box>||<basic-shape>]|<image>",
    "tab-size": "<integer>|<length>",
    "table-layout": "auto|fixed",
    "text-align": "start|end|left|right|center|justify|match-parent",
    "text-align-last": "auto|start|end|left|right|center|justify",
    "text-combine-upright": "none|all|[digits <integer>?]",
    "text-decoration": "<'text-decoration-line'>||<'text-decoration-style'>||<'text-decoration-color'>||<'text-decoration-thickness'>",
    "text-decoration-color": "<color>",
    "text-decoration-line": "none|[underline||overline||line-through||blink]|spelling-error|grammar-error",
    "text-decoration-skip": "none|[objects||[spaces|[leading-spaces||trailing-spaces]]||edges||box-decoration]",
    "text-decoration-skip-ink": "auto|all|none",
    "text-decoration-style": "solid|double|dotted|dashed|wavy",
    "text-decoration-thickness": "auto|from-font|<length>|<percentage>",
    "text-emphasis": "<'text-emphasis-style'>||<'text-emphasis-color'>",
    "text-emphasis-color": "<color>",
    "text-emphasis-position": "[over|under]&&[right|left]",
    "text-emphasis-style": "none|[[filled|open]||[dot|circle|double-circle|triangle|sesame]]|<string>",
    "text-indent": "<length-percentage>&&hanging?&&each-line?",
    "text-justify": "auto|inter-character|inter-word|none",
    "text-orientation": "mixed|upright|sideways",
    "text-overflow": "[clip|ellipsis|<string>]{1,2}",
    "text-rendering": "auto|optimizeSpeed|optimizeLegibility|geometricPrecision",
    "text-shadow": "none|<shadow-t>#",
    "text-size-adjust": "none|auto|<percentage>",
    "text-transform": "none|capitalize|uppercase|lowercase|full-width|full-size-kana",
    "text-underline-offset": "auto|<length>|<percentage>",
    "text-underline-position": "auto|from-font|[under||[left|right]]",
    "top": "<length>|<percentage>|auto",
    "touch-action": "auto|none|[[pan-x|pan-left|pan-right]||[pan-y|pan-up|pan-down]||pinch-zoom]|manipulation",
    "transform": "none|<transform-list>",
    "transform-box": "content-box|border-box|fill-box|stroke-box|view-box",
    "transform-origin": "[<length-percentage>|left|center|right|top|bottom]|[[<length-percentage>|left|center|right]&&[<length-percentage>|top|center|bottom]] <length>?",
    "transform-style": "flat|preserve-3d",
    "transition": "<single-transition>#",
    "transition-delay": "<time>#",
    "transition-duration": "<time>#",
    "transition-property": "none|<single-transition-property>#",
    "transition-timing-function": "<easing-function>#",
    "translate": "none|<length-percentage> [<length-percentage> <length>?]?",
    "unicode-bidi": "normal|embed|isolate|bidi-override|isolate-override|plaintext|-moz-isolate|-moz-isolate-override|-moz-plaintext|-webkit-isolate|-webkit-isolate-override|-webkit-plaintext",
    "user-select": "auto|text|none|contain|all",
    "vertical-align": "baseline|sub|super|text-top|text-bottom|middle|top|bottom|<percentage>|<length>",
    "visibility": "visible|hidden|collapse",
    "white-space": "normal|pre|nowrap|pre-wrap|pre-line|break-spaces",
    "widows": "<integer>",
    "width": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|fill|stretch|intrinsic|-moz-max-content|-webkit-max-content|-moz-fit-content|-webkit-fit-content",
    "will-change": "auto|<animateable-feature>#",
    "word-break": "normal|break-all|keep-all|break-word",
    "word-spacing": "normal|<length>",
    "word-wrap": "normal|break-word",
    "writing-mode": "horizontal-tb|vertical-rl|vertical-lr|sideways-rl|sideways-lr|<svg-writing-mode>",
    "z-index": "auto|<integer>",
    "zoom": "normal|reset|<number>|<percentage>",
    "-moz-background-clip": "padding|border",
    "-moz-border-radius-bottomleft": "<'border-bottom-left-radius'>",
    "-moz-border-radius-bottomright": "<'border-bottom-right-radius'>",
    "-moz-border-radius-topleft": "<'border-top-left-radius'>",
    "-moz-border-radius-topright": "<'border-bottom-right-radius'>",
    "-moz-control-character-visibility": "visible|hidden",
    "-moz-osx-font-smoothing": "auto|grayscale",
    "-moz-user-select": "none|text|all|-moz-none",
    "-ms-flex-align": "start|end|center|baseline|stretch",
    "-ms-flex-item-align": "auto|start|end|center|baseline|stretch",
    "-ms-flex-line-pack": "start|end|center|justify|distribute|stretch",
    "-ms-flex-negative": "<'flex-shrink'>",
    "-ms-flex-pack": "start|end|center|justify|distribute",
    "-ms-flex-order": "<integer>",
    "-ms-flex-positive": "<'flex-grow'>",
    "-ms-flex-preferred-size": "<'flex-basis'>",
    "-ms-interpolation-mode": "nearest-neighbor|bicubic",
    "-ms-grid-column-align": "start|end|center|stretch",
    "-ms-grid-row-align": "start|end|center|stretch",
    "-ms-hyphenate-limit-last": "none|always|column|page|spread",
    "-webkit-background-clip": "[<box>|border|padding|content|text]#",
    "-webkit-column-break-after": "always|auto|avoid",
    "-webkit-column-break-before": "always|auto|avoid",
    "-webkit-column-break-inside": "always|auto|avoid",
    "-webkit-font-smoothing": "auto|none|antialiased|subpixel-antialiased",
    "-webkit-mask-box-image": "[<url>|<gradient>|none] [<length-percentage>{4} <-webkit-mask-box-repeat>{2}]?",
    "-webkit-print-color-adjust": "economy|exact",
    "-webkit-text-security": "none|circle|disc|square",
    "-webkit-user-drag": "none|element|auto",
    "-webkit-user-select": "auto|none|text|all",
    "alignment-baseline": "auto|baseline|before-edge|text-before-edge|middle|central|after-edge|text-after-edge|ideographic|alphabetic|hanging|mathematical",
    "baseline-shift": "baseline|sub|super|<svg-length>",
    "behavior": "<url>+",
    "clip-rule": "nonzero|evenodd",
    "cue": "<'cue-before'> <'cue-after'>?",
    "cue-after": "<url> <decibel>?|none",
    "cue-before": "<url> <decibel>?|none",
    "dominant-baseline": "auto|use-script|no-change|reset-size|ideographic|alphabetic|hanging|mathematical|central|middle|text-after-edge|text-before-edge",
    "fill": "<paint>",
    "fill-opacity": "<number-zero-one>",
    "fill-rule": "nonzero|evenodd",
    "glyph-orientation-horizontal": "<angle>",
    "glyph-orientation-vertical": "<angle>",
    "kerning": "auto|<svg-length>",
    "marker": "none|<url>",
    "marker-end": "none|<url>",
    "marker-mid": "none|<url>",
    "marker-start": "none|<url>",
    "pause": "<'pause-before'> <'pause-after'>?",
    "pause-after": "<time>|none|x-weak|weak|medium|strong|x-strong",
    "pause-before": "<time>|none|x-weak|weak|medium|strong|x-strong",
    "rest": "<'rest-before'> <'rest-after'>?",
    "rest-after": "<time>|none|x-weak|weak|medium|strong|x-strong",
    "rest-before": "<time>|none|x-weak|weak|medium|strong|x-strong",
    "shape-rendering": "auto|optimizeSpeed|crispEdges|geometricPrecision",
    "src": "[<url> [format( <string># )]?|local( <family-name> )]#",
    "speak": "auto|none|normal",
    "speak-as": "normal|spell-out||digits||[literal-punctuation|no-punctuation]",
    "stroke": "<paint>",
    "stroke-dasharray": "none|[<svg-length>+]#",
    "stroke-dashoffset": "<svg-length>",
    "stroke-linecap": "butt|round|square",
    "stroke-linejoin": "miter|round|bevel",
    "stroke-miterlimit": "<number-one-or-greater>",
    "stroke-opacity": "<number-zero-one>",
    "stroke-width": "<svg-length>",
    "text-anchor": "start|middle|end",
    "unicode-range": "<urange>#",
    "voice-balance": "<number>|left|center|right|leftwards|rightwards",
    "voice-duration": "auto|<time>",
    "voice-family": "[[<family-name>|<generic-voice>] ,]* [<family-name>|<generic-voice>]|preserve",
    "voice-pitch": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]",
    "voice-range": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]",
    "voice-rate": "[normal|x-slow|slow|medium|fast|x-fast]||<percentage>",
    "voice-stress": "normal|strong|moderate|none|reduced",
    "voice-volume": "silent|[[x-soft|soft|medium|loud|x-loud]||<decibel>]"
  },
  "atrules": {
    "charset": {
      "prelude": "<string>",
      "descriptors": null
    },
    "counter-style": {
      "prelude": "<counter-style-name>",
      "descriptors": {
        "additive-symbols": "[<integer>&&<symbol>]#",
        "fallback": "<counter-style-name>",
        "negative": "<symbol> <symbol>?",
        "pad": "<integer>&&<symbol>",
        "prefix": "<symbol>",
        "range": "[[<integer>|infinite]{2}]#|auto",
        "speak-as": "auto|bullets|numbers|words|spell-out|<counter-style-name>",
        "suffix": "<symbol>",
        "symbols": "<symbol>+",
        "system": "cyclic|numeric|alphabetic|symbolic|additive|[fixed <integer>?]|[extends <counter-style-name>]"
      }
    },
    "document": {
      "prelude": "[<url>|url-prefix( <string> )|domain( <string> )|media-document( <string> )|regexp( <string> )]#",
      "descriptors": null
    },
    "font-face": {
      "prelude": null,
      "descriptors": {
        "ascent-override": "normal|<percentage>",
        "descent-override": "normal|<percentage>",
        "font-display": "[auto|block|swap|fallback|optional]",
        "font-family": "<family-name>",
        "font-feature-settings": "normal|<feature-tag-value>#",
        "font-variation-settings": "normal|[<string> <number>]#",
        "font-stretch": "<font-stretch-absolute>{1,2}",
        "font-style": "normal|italic|oblique <angle>{0,2}",
        "font-weight": "<font-weight-absolute>{1,2}",
        "font-variant": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>||stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )||[small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps]||<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero||<east-asian-variant-values>||<east-asian-width-values>||ruby]",
        "line-gap-override": "normal|<percentage>",
        "size-adjust": "<percentage>",
        "src": "[<url> [format( <string># )]?|local( <family-name> )]#",
        "unicode-range": "<urange>#"
      }
    },
    "font-feature-values": {
      "prelude": "<family-name>#",
      "descriptors": null
    },
    "import": {
      "prelude": "[<string>|<url>] [layer|layer( <layer-name> )]? [supports( [<supports-condition>|<declaration>] )]? <media-query-list>?",
      "descriptors": null
    },
    "keyframes": {
      "prelude": "<keyframes-name>",
      "descriptors": null
    },
    "layer": {
      "prelude": "[<layer-name>#|<layer-name>?]",
      "descriptors": null
    },
    "media": {
      "prelude": "<media-query-list>",
      "descriptors": null
    },
    "namespace": {
      "prelude": "<namespace-prefix>? [<string>|<url>]",
      "descriptors": null
    },
    "page": {
      "prelude": "<page-selector-list>",
      "descriptors": {
        "bleed": "auto|<length>",
        "marks": "none|[crop||cross]",
        "size": "<length>{1,2}|auto|[<page-size>||[portrait|landscape]]"
      }
    },
    "property": {
      "prelude": "<custom-property-name>",
      "descriptors": {
        "syntax": "<string>",
        "inherits": "true|false",
        "initial-value": "<string>"
      }
    },
    "scroll-timeline": {
      "prelude": "<timeline-name>",
      "descriptors": null
    },
    "supports": {
      "prelude": "<supports-condition>",
      "descriptors": null
    },
    "viewport": {
      "prelude": null,
      "descriptors": {
        "height": "<viewport-length>{1,2}",
        "max-height": "<viewport-length>",
        "max-width": "<viewport-length>",
        "max-zoom": "auto|<number>|<percentage>",
        "min-height": "<viewport-length>",
        "min-width": "<viewport-length>",
        "min-zoom": "auto|<number>|<percentage>",
        "orientation": "auto|portrait|landscape",
        "user-zoom": "zoom|fixed",
        "viewport-fit": "auto|contain|cover",
        "width": "<viewport-length>{1,2}",
        "zoom": "auto|<number>|<percentage>"
      }
    }
  }
};
const PLUSSIGN$5 = 43;
const HYPHENMINUS$2 = 45;
const N = 110;
const DISALLOW_SIGN = true;
const ALLOW_SIGN = false;
function checkInteger(offset, disallowSign) {
  let pos = this.tokenStart + offset;
  const code2 = this.charCodeAt(pos);
  if (code2 === PLUSSIGN$5 || code2 === HYPHENMINUS$2) {
    if (disallowSign) {
      this.error("Number sign is not allowed");
    }
    pos++;
  }
  for (; pos < this.tokenEnd; pos++) {
    if (!isDigit$1(this.charCodeAt(pos))) {
      this.error("Integer is expected", pos);
    }
  }
}
function checkTokenIsInteger(disallowSign) {
  return checkInteger.call(this, 0, disallowSign);
}
function expectCharCode(offset, code2) {
  if (!this.cmpChar(this.tokenStart + offset, code2)) {
    let msg = "";
    switch (code2) {
      case N:
        msg = "N is expected";
        break;
      case HYPHENMINUS$2:
        msg = "HyphenMinus is expected";
        break;
    }
    this.error(msg, this.tokenStart + offset);
  }
}
function consumeB() {
  let offset = 0;
  let sign = 0;
  let type = this.tokenType;
  while (type === WhiteSpace$1 || type === Comment$1) {
    type = this.lookupType(++offset);
  }
  if (type !== Number$3) {
    if (this.isDelim(PLUSSIGN$5, offset) || this.isDelim(HYPHENMINUS$2, offset)) {
      sign = this.isDelim(PLUSSIGN$5, offset) ? PLUSSIGN$5 : HYPHENMINUS$2;
      do {
        type = this.lookupType(++offset);
      } while (type === WhiteSpace$1 || type === Comment$1);
      if (type !== Number$3) {
        this.skip(offset);
        checkTokenIsInteger.call(this, DISALLOW_SIGN);
      }
    } else {
      return null;
    }
  }
  if (offset > 0) {
    this.skip(offset);
  }
  if (sign === 0) {
    type = this.charCodeAt(this.tokenStart);
    if (type !== PLUSSIGN$5 && type !== HYPHENMINUS$2) {
      this.error("Number sign is expected");
    }
  }
  checkTokenIsInteger.call(this, sign !== 0);
  return sign === HYPHENMINUS$2 ? "-" + this.consume(Number$3) : this.consume(Number$3);
}
const name$1p = "AnPlusB";
const structure$D = {
  a: [String, null],
  b: [String, null]
};
function parse$G() {
  const start = this.tokenStart;
  let a = null;
  let b = null;
  if (this.tokenType === Number$3) {
    checkTokenIsInteger.call(this, ALLOW_SIGN);
    b = this.consume(Number$3);
  } else if (this.tokenType === Ident && this.cmpChar(this.tokenStart, HYPHENMINUS$2)) {
    a = "-1";
    expectCharCode.call(this, 1, N);
    switch (this.tokenEnd - this.tokenStart) {
      // -n
      // -n <signed-integer>
      // -n ['+' | '-'] <signless-integer>
      case 2:
        this.next();
        b = consumeB.call(this);
        break;
      // -n- <signless-integer>
      case 3:
        expectCharCode.call(this, 2, HYPHENMINUS$2);
        this.next();
        this.skipSC();
        checkTokenIsInteger.call(this, DISALLOW_SIGN);
        b = "-" + this.consume(Number$3);
        break;
      // <dashndashdigit-ident>
      default:
        expectCharCode.call(this, 2, HYPHENMINUS$2);
        checkInteger.call(this, 3, DISALLOW_SIGN);
        this.next();
        b = this.substrToCursor(start + 2);
    }
  } else if (this.tokenType === Ident || this.isDelim(PLUSSIGN$5) && this.lookupType(1) === Ident) {
    let sign = 0;
    a = "1";
    if (this.isDelim(PLUSSIGN$5)) {
      sign = 1;
      this.next();
    }
    expectCharCode.call(this, 0, N);
    switch (this.tokenEnd - this.tokenStart) {
      // '+'? n
      // '+'? n <signed-integer>
      // '+'? n ['+' | '-'] <signless-integer>
      case 1:
        this.next();
        b = consumeB.call(this);
        break;
      // '+'? n- <signless-integer>
      case 2:
        expectCharCode.call(this, 1, HYPHENMINUS$2);
        this.next();
        this.skipSC();
        checkTokenIsInteger.call(this, DISALLOW_SIGN);
        b = "-" + this.consume(Number$3);
        break;
      // '+'? <ndashdigit-ident>
      default:
        expectCharCode.call(this, 1, HYPHENMINUS$2);
        checkInteger.call(this, 2, DISALLOW_SIGN);
        this.next();
        b = this.substrToCursor(start + sign + 1);
    }
  } else if (this.tokenType === Dimension$1) {
    const code2 = this.charCodeAt(this.tokenStart);
    const sign = code2 === PLUSSIGN$5 || code2 === HYPHENMINUS$2;
    let i = this.tokenStart + sign;
    for (; i < this.tokenEnd; i++) {
      if (!isDigit$1(this.charCodeAt(i))) {
        break;
      }
    }
    if (i === this.tokenStart + sign) {
      this.error("Integer is expected", this.tokenStart + sign);
    }
    expectCharCode.call(this, i - this.tokenStart, N);
    a = this.substring(start, i);
    if (i + 1 === this.tokenEnd) {
      this.next();
      b = consumeB.call(this);
    } else {
      expectCharCode.call(this, i - this.tokenStart + 1, HYPHENMINUS$2);
      if (i + 2 === this.tokenEnd) {
        this.next();
        this.skipSC();
        checkTokenIsInteger.call(this, DISALLOW_SIGN);
        b = "-" + this.consume(Number$3);
      } else {
        checkInteger.call(this, i - this.tokenStart + 2, DISALLOW_SIGN);
        this.next();
        b = this.substrToCursor(i + 1);
      }
    }
  } else {
    this.error();
  }
  if (a !== null && a.charCodeAt(0) === PLUSSIGN$5) {
    a = a.substr(1);
  }
  if (b !== null && b.charCodeAt(0) === PLUSSIGN$5) {
    b = b.substr(1);
  }
  return {
    type: "AnPlusB",
    loc: this.getLocation(start, this.tokenStart),
    a,
    b
  };
}
function generate$G(node2) {
  if (node2.a) {
    const a = node2.a === "+1" && "n" || node2.a === "1" && "n" || node2.a === "-1" && "-n" || node2.a + "n";
    if (node2.b) {
      const b = node2.b[0] === "-" || node2.b[0] === "+" ? node2.b : "+" + node2.b;
      this.tokenize(a + b);
    } else {
      this.tokenize(a);
    }
  } else {
    this.tokenize(node2.b);
  }
}
const AnPlusB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$G,
  name: name$1p,
  parse: parse$G,
  structure: structure$D
}, Symbol.toStringTag, { value: "Module" }));
function consumeRaw$5(startToken) {
  return this.Raw(startToken, this.consumeUntilLeftCurlyBracketOrSemicolon, true);
}
function isDeclarationBlockAtrule() {
  for (let offset = 1, type; type = this.lookupType(offset); offset++) {
    if (type === RightCurlyBracket) {
      return true;
    }
    if (type === LeftCurlyBracket || type === AtKeyword) {
      return false;
    }
  }
  return false;
}
const name$1o = "Atrule";
const walkContext$9 = "atrule";
const structure$C = {
  name: String,
  prelude: ["AtrulePrelude", "Raw", null],
  block: ["Block", null]
};
function parse$F() {
  const start = this.tokenStart;
  let name2;
  let nameLowerCase;
  let prelude = null;
  let block = null;
  this.eat(AtKeyword);
  name2 = this.substrToCursor(start + 1);
  nameLowerCase = name2.toLowerCase();
  this.skipSC();
  if (this.eof === false && this.tokenType !== LeftCurlyBracket && this.tokenType !== Semicolon) {
    if (this.parseAtrulePrelude) {
      prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name2), consumeRaw$5);
    } else {
      prelude = consumeRaw$5.call(this, this.tokenIndex);
    }
    this.skipSC();
  }
  switch (this.tokenType) {
    case Semicolon:
      this.next();
      break;
    case LeftCurlyBracket:
      if (hasOwnProperty.call(this.atrule, nameLowerCase) && typeof this.atrule[nameLowerCase].block === "function") {
        block = this.atrule[nameLowerCase].block.call(this);
      } else {
        block = this.Block(isDeclarationBlockAtrule.call(this));
      }
      break;
  }
  return {
    type: "Atrule",
    loc: this.getLocation(start, this.tokenStart),
    name: name2,
    prelude,
    block
  };
}
function generate$F(node2) {
  this.token(AtKeyword, "@" + node2.name);
  if (node2.prelude !== null) {
    this.node(node2.prelude);
  }
  if (node2.block) {
    this.node(node2.block);
  } else {
    this.token(Semicolon, ";");
  }
}
const Atrule$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$F,
  name: name$1o,
  parse: parse$F,
  structure: structure$C,
  walkContext: walkContext$9
}, Symbol.toStringTag, { value: "Module" }));
const name$1n = "AtrulePrelude";
const walkContext$8 = "atrulePrelude";
const structure$B = {
  children: [[]]
};
function parse$E(name2) {
  let children = null;
  if (name2 !== null) {
    name2 = name2.toLowerCase();
  }
  this.skipSC();
  if (hasOwnProperty.call(this.atrule, name2) && typeof this.atrule[name2].prelude === "function") {
    children = this.atrule[name2].prelude.call(this);
  } else {
    children = this.readSequence(this.scope.AtrulePrelude);
  }
  this.skipSC();
  if (this.eof !== true && this.tokenType !== LeftCurlyBracket && this.tokenType !== Semicolon) {
    this.error("Semicolon or block is expected");
  }
  return {
    type: "AtrulePrelude",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate$E(node2) {
  this.children(node2);
}
const AtrulePrelude = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$E,
  name: name$1n,
  parse: parse$E,
  structure: structure$B,
  walkContext: walkContext$8
}, Symbol.toStringTag, { value: "Module" }));
const DOLLARSIGN$1 = 36;
const ASTERISK$5 = 42;
const EQUALSSIGN = 61;
const CIRCUMFLEXACCENT = 94;
const VERTICALLINE$2 = 124;
const TILDE$2 = 126;
function getAttributeName() {
  if (this.eof) {
    this.error("Unexpected end of input");
  }
  const start = this.tokenStart;
  let expectIdent = false;
  if (this.isDelim(ASTERISK$5)) {
    expectIdent = true;
    this.next();
  } else if (!this.isDelim(VERTICALLINE$2)) {
    this.eat(Ident);
  }
  if (this.isDelim(VERTICALLINE$2)) {
    if (this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN) {
      this.next();
      this.eat(Ident);
    } else if (expectIdent) {
      this.error("Identifier is expected", this.tokenEnd);
    }
  } else if (expectIdent) {
    this.error("Vertical line is expected");
  }
  return {
    type: "Identifier",
    loc: this.getLocation(start, this.tokenStart),
    name: this.substrToCursor(start)
  };
}
function getOperator() {
  const start = this.tokenStart;
  const code2 = this.charCodeAt(start);
  if (code2 !== EQUALSSIGN && // =
  code2 !== TILDE$2 && // ~=
  code2 !== CIRCUMFLEXACCENT && // ^=
  code2 !== DOLLARSIGN$1 && // $=
  code2 !== ASTERISK$5 && // *=
  code2 !== VERTICALLINE$2) {
    this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected");
  }
  this.next();
  if (code2 !== EQUALSSIGN) {
    if (!this.isDelim(EQUALSSIGN)) {
      this.error("Equal sign is expected");
    }
    this.next();
  }
  return this.substrToCursor(start);
}
const name$1m = "AttributeSelector";
const structure$A = {
  name: "Identifier",
  matcher: [String, null],
  value: ["String", "Identifier", null],
  flags: [String, null]
};
function parse$D() {
  const start = this.tokenStart;
  let name2;
  let matcher = null;
  let value2 = null;
  let flags = null;
  this.eat(LeftSquareBracket);
  this.skipSC();
  name2 = getAttributeName.call(this);
  this.skipSC();
  if (this.tokenType !== RightSquareBracket) {
    if (this.tokenType !== Ident) {
      matcher = getOperator.call(this);
      this.skipSC();
      value2 = this.tokenType === String$2 ? this.String() : this.Identifier();
      this.skipSC();
    }
    if (this.tokenType === Ident) {
      flags = this.consume(Ident);
      this.skipSC();
    }
  }
  this.eat(RightSquareBracket);
  return {
    type: "AttributeSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: name2,
    matcher,
    value: value2,
    flags
  };
}
function generate$D(node2) {
  this.token(Delim, "[");
  this.node(node2.name);
  if (node2.matcher !== null) {
    this.tokenize(node2.matcher);
    this.node(node2.value);
  }
  if (node2.flags !== null) {
    this.token(Ident, node2.flags);
  }
  this.token(Delim, "]");
}
const AttributeSelector$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$D,
  name: name$1m,
  parse: parse$D,
  structure: structure$A
}, Symbol.toStringTag, { value: "Module" }));
function consumeRaw$4(startToken) {
  return this.Raw(startToken, null, true);
}
function consumeRule() {
  return this.parseWithFallback(this.Rule, consumeRaw$4);
}
function consumeRawDeclaration(startToken) {
  return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
}
function consumeDeclaration() {
  if (this.tokenType === Semicolon) {
    return consumeRawDeclaration.call(this, this.tokenIndex);
  }
  const node2 = this.parseWithFallback(this.Declaration, consumeRawDeclaration);
  if (this.tokenType === Semicolon) {
    this.next();
  }
  return node2;
}
const name$1l = "Block";
const walkContext$7 = "block";
const structure$z = {
  children: [[
    "Atrule",
    "Rule",
    "Declaration"
  ]]
};
function parse$C(isDeclaration) {
  const consumer = isDeclaration ? consumeDeclaration : consumeRule;
  const start = this.tokenStart;
  let children = this.createList();
  this.eat(LeftCurlyBracket);
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case RightCurlyBracket:
          break scan;
        case WhiteSpace$1:
        case Comment$1:
          this.next();
          break;
        case AtKeyword:
          children.push(this.parseWithFallback(this.Atrule, consumeRaw$4));
          break;
        default:
          children.push(consumer.call(this));
      }
    }
  if (!this.eof) {
    this.eat(RightCurlyBracket);
  }
  return {
    type: "Block",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate$C(node2) {
  this.token(LeftCurlyBracket, "{");
  this.children(node2, (prev) => {
    if (prev.type === "Declaration") {
      this.token(Semicolon, ";");
    }
  });
  this.token(RightCurlyBracket, "}");
}
const Block = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$C,
  name: name$1l,
  parse: parse$C,
  structure: structure$z,
  walkContext: walkContext$7
}, Symbol.toStringTag, { value: "Module" }));
const name$1k = "Brackets";
const structure$y = {
  children: [[]]
};
function parse$B(readSequence2, recognizer) {
  const start = this.tokenStart;
  let children = null;
  this.eat(LeftSquareBracket);
  children = readSequence2.call(this, recognizer);
  if (!this.eof) {
    this.eat(RightSquareBracket);
  }
  return {
    type: "Brackets",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate$B(node2) {
  this.token(Delim, "[");
  this.children(node2);
  this.token(Delim, "]");
}
const Brackets = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$B,
  name: name$1k,
  parse: parse$B,
  structure: structure$y
}, Symbol.toStringTag, { value: "Module" }));
const name$1j = "CDC";
const structure$x = [];
function parse$A() {
  const start = this.tokenStart;
  this.eat(CDC$1);
  return {
    type: "CDC",
    loc: this.getLocation(start, this.tokenStart)
  };
}
function generate$A() {
  this.token(CDC$1, "-->");
}
const CDC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$A,
  name: name$1j,
  parse: parse$A,
  structure: structure$x
}, Symbol.toStringTag, { value: "Module" }));
const name$1i = "CDO";
const structure$w = [];
function parse$z() {
  const start = this.tokenStart;
  this.eat(CDO$1);
  return {
    type: "CDO",
    loc: this.getLocation(start, this.tokenStart)
  };
}
function generate$z() {
  this.token(CDO$1, "<!--");
}
const CDO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$z,
  name: name$1i,
  parse: parse$z,
  structure: structure$w
}, Symbol.toStringTag, { value: "Module" }));
const FULLSTOP$2 = 46;
const name$1h = "ClassSelector";
const structure$v = {
  name: String
};
function parse$y() {
  this.eatDelim(FULLSTOP$2);
  return {
    type: "ClassSelector",
    loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),
    name: this.consume(Ident)
  };
}
function generate$y(node2) {
  this.token(Delim, ".");
  this.token(Ident, node2.name);
}
const ClassSelector = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$y,
  name: name$1h,
  parse: parse$y,
  structure: structure$v
}, Symbol.toStringTag, { value: "Module" }));
const PLUSSIGN$4 = 43;
const SOLIDUS$5 = 47;
const GREATERTHANSIGN$1 = 62;
const TILDE$1 = 126;
const name$1g = "Combinator";
const structure$u = {
  name: String
};
function parse$x() {
  const start = this.tokenStart;
  let name2;
  switch (this.tokenType) {
    case WhiteSpace$1:
      name2 = " ";
      break;
    case Delim:
      switch (this.charCodeAt(this.tokenStart)) {
        case GREATERTHANSIGN$1:
        case PLUSSIGN$4:
        case TILDE$1:
          this.next();
          break;
        case SOLIDUS$5:
          this.next();
          this.eatIdent("deep");
          this.eatDelim(SOLIDUS$5);
          break;
        default:
          this.error("Combinator is expected");
      }
      name2 = this.substrToCursor(start);
      break;
  }
  return {
    type: "Combinator",
    loc: this.getLocation(start, this.tokenStart),
    name: name2
  };
}
function generate$x(node2) {
  this.tokenize(node2.name);
}
const Combinator = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$x,
  name: name$1g,
  parse: parse$x,
  structure: structure$u
}, Symbol.toStringTag, { value: "Module" }));
const ASTERISK$4 = 42;
const SOLIDUS$4 = 47;
const name$1f = "Comment";
const structure$t = {
  value: String
};
function parse$w() {
  const start = this.tokenStart;
  let end = this.tokenEnd;
  this.eat(Comment$1);
  if (end - start + 2 >= 2 && this.charCodeAt(end - 2) === ASTERISK$4 && this.charCodeAt(end - 1) === SOLIDUS$4) {
    end -= 2;
  }
  return {
    type: "Comment",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substring(start + 2, end)
  };
}
function generate$w(node2) {
  this.token(Comment$1, "/*" + node2.value + "*/");
}
const Comment = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$w,
  name: name$1f,
  parse: parse$w,
  structure: structure$t
}, Symbol.toStringTag, { value: "Module" }));
const EXCLAMATIONMARK$1 = 33;
const NUMBERSIGN$2 = 35;
const DOLLARSIGN = 36;
const AMPERSAND = 38;
const ASTERISK$3 = 42;
const PLUSSIGN$3 = 43;
const SOLIDUS$3 = 47;
function consumeValueRaw(startToken) {
  return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, true);
}
function consumeCustomPropertyRaw(startToken) {
  return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, false);
}
function consumeValue() {
  const startValueToken = this.tokenIndex;
  const value2 = this.Value();
  if (value2.type !== "Raw" && this.eof === false && this.tokenType !== Semicolon && this.isDelim(EXCLAMATIONMARK$1) === false && this.isBalanceEdge(startValueToken) === false) {
    this.error();
  }
  return value2;
}
const name$1e = "Declaration";
const walkContext$6 = "declaration";
const structure$s = {
  important: [Boolean, String],
  property: String,
  value: ["Value", "Raw"]
};
function parse$v() {
  const start = this.tokenStart;
  const startToken = this.tokenIndex;
  const property2 = readProperty.call(this);
  const customProperty = isCustomProperty(property2);
  const parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
  const consumeRaw2 = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
  let important = false;
  let value2;
  this.skipSC();
  this.eat(Colon);
  const valueStart = this.tokenIndex;
  if (!customProperty) {
    this.skipSC();
  }
  if (parseValue) {
    value2 = this.parseWithFallback(consumeValue, consumeRaw2);
  } else {
    value2 = consumeRaw2.call(this, this.tokenIndex);
  }
  if (customProperty && value2.type === "Value" && value2.children.isEmpty) {
    for (let offset = valueStart - this.tokenIndex; offset <= 0; offset++) {
      if (this.lookupType(offset) === WhiteSpace$1) {
        value2.children.appendData({
          type: "WhiteSpace",
          loc: null,
          value: " "
        });
        break;
      }
    }
  }
  if (this.isDelim(EXCLAMATIONMARK$1)) {
    important = getImportant.call(this);
    this.skipSC();
  }
  if (this.eof === false && this.tokenType !== Semicolon && this.isBalanceEdge(startToken) === false) {
    this.error();
  }
  return {
    type: "Declaration",
    loc: this.getLocation(start, this.tokenStart),
    important,
    property: property2,
    value: value2
  };
}
function generate$v(node2) {
  this.token(Ident, node2.property);
  this.token(Colon, ":");
  this.node(node2.value);
  if (node2.important) {
    this.token(Delim, "!");
    this.token(Ident, node2.important === true ? "important" : node2.important);
  }
}
function readProperty() {
  const start = this.tokenStart;
  if (this.tokenType === Delim) {
    switch (this.charCodeAt(this.tokenStart)) {
      case ASTERISK$3:
      case DOLLARSIGN:
      case PLUSSIGN$3:
      case NUMBERSIGN$2:
      case AMPERSAND:
        this.next();
        break;
      // TODO: not sure we should support this hack
      case SOLIDUS$3:
        this.next();
        if (this.isDelim(SOLIDUS$3)) {
          this.next();
        }
        break;
    }
  }
  if (this.tokenType === Hash$1) {
    this.eat(Hash$1);
  } else {
    this.eat(Ident);
  }
  return this.substrToCursor(start);
}
function getImportant() {
  this.eat(Delim);
  this.skipSC();
  const important = this.consume(Ident);
  return important === "important" ? true : important;
}
const Declaration = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$v,
  name: name$1e,
  parse: parse$v,
  structure: structure$s,
  walkContext: walkContext$6
}, Symbol.toStringTag, { value: "Module" }));
function consumeRaw$3(startToken) {
  return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
}
const name$1d = "DeclarationList";
const structure$r = {
  children: [[
    "Declaration"
  ]]
};
function parse$u() {
  const children = this.createList();
  while (!this.eof) {
    switch (this.tokenType) {
      case WhiteSpace$1:
      case Comment$1:
      case Semicolon:
        this.next();
        break;
      default:
        children.push(this.parseWithFallback(this.Declaration, consumeRaw$3));
    }
  }
  return {
    type: "DeclarationList",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate$u(node2) {
  this.children(node2, (prev) => {
    if (prev.type === "Declaration") {
      this.token(Semicolon, ";");
    }
  });
}
const DeclarationList = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$u,
  name: name$1d,
  parse: parse$u,
  structure: structure$r
}, Symbol.toStringTag, { value: "Module" }));
const name$1c = "Dimension";
const structure$q = {
  value: String,
  unit: String
};
function parse$t() {
  const start = this.tokenStart;
  const value2 = this.consumeNumber(Dimension$1);
  return {
    type: "Dimension",
    loc: this.getLocation(start, this.tokenStart),
    value: value2,
    unit: this.substring(start + value2.length, this.tokenStart)
  };
}
function generate$t(node2) {
  this.token(Dimension$1, node2.value + node2.unit);
}
const Dimension = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$t,
  name: name$1c,
  parse: parse$t,
  structure: structure$q
}, Symbol.toStringTag, { value: "Module" }));
const name$1b = "Function";
const walkContext$5 = "function";
const structure$p = {
  name: String,
  children: [[]]
};
function parse$s(readSequence2, recognizer) {
  const start = this.tokenStart;
  const name2 = this.consumeFunctionName();
  const nameLowerCase = name2.toLowerCase();
  let children;
  children = recognizer.hasOwnProperty(nameLowerCase) ? recognizer[nameLowerCase].call(this, recognizer) : readSequence2.call(this, recognizer);
  if (!this.eof) {
    this.eat(RightParenthesis);
  }
  return {
    type: "Function",
    loc: this.getLocation(start, this.tokenStart),
    name: name2,
    children
  };
}
function generate$s(node2) {
  this.token(Function$1, node2.name + "(");
  this.children(node2);
  this.token(RightParenthesis, ")");
}
const Function = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$s,
  name: name$1b,
  parse: parse$s,
  structure: structure$p,
  walkContext: walkContext$5
}, Symbol.toStringTag, { value: "Module" }));
const xxx = "XXX";
const name$1a = "Hash";
const structure$o = {
  value: String
};
function parse$r() {
  const start = this.tokenStart;
  this.eat(Hash$1);
  return {
    type: "Hash",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substrToCursor(start + 1)
  };
}
function generate$r(node2) {
  this.token(Hash$1, "#" + node2.value);
}
const Hash = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$r,
  name: name$1a,
  parse: parse$r,
  structure: structure$o,
  xxx
}, Symbol.toStringTag, { value: "Module" }));
const name$19 = "Identifier";
const structure$n = {
  name: String
};
function parse$q() {
  return {
    type: "Identifier",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    name: this.consume(Ident)
  };
}
function generate$q(node2) {
  this.token(Ident, node2.name);
}
const Identifier = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$q,
  name: name$19,
  parse: parse$q,
  structure: structure$n
}, Symbol.toStringTag, { value: "Module" }));
const name$18 = "IdSelector";
const structure$m = {
  name: String
};
function parse$p() {
  const start = this.tokenStart;
  this.eat(Hash$1);
  return {
    type: "IdSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: this.substrToCursor(start + 1)
  };
}
function generate$p(node2) {
  this.token(Delim, "#" + node2.name);
}
const IdSelector = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$p,
  name: name$18,
  parse: parse$p,
  structure: structure$m
}, Symbol.toStringTag, { value: "Module" }));
const name$17 = "MediaFeature";
const structure$l = {
  name: String,
  value: ["Identifier", "Number", "Dimension", "Ratio", null]
};
function parse$o() {
  const start = this.tokenStart;
  let name2;
  let value2 = null;
  this.eat(LeftParenthesis);
  this.skipSC();
  name2 = this.consume(Ident);
  this.skipSC();
  if (this.tokenType !== RightParenthesis) {
    this.eat(Colon);
    this.skipSC();
    switch (this.tokenType) {
      case Number$3:
        if (this.lookupNonWSType(1) === Delim) {
          value2 = this.Ratio();
        } else {
          value2 = this.Number();
        }
        break;
      case Dimension$1:
        value2 = this.Dimension();
        break;
      case Ident:
        value2 = this.Identifier();
        break;
      default:
        this.error("Number, dimension, ratio or identifier is expected");
    }
    this.skipSC();
  }
  this.eat(RightParenthesis);
  return {
    type: "MediaFeature",
    loc: this.getLocation(start, this.tokenStart),
    name: name2,
    value: value2
  };
}
function generate$o(node2) {
  this.token(LeftParenthesis, "(");
  this.token(Ident, node2.name);
  if (node2.value !== null) {
    this.token(Colon, ":");
    this.node(node2.value);
  }
  this.token(RightParenthesis, ")");
}
const MediaFeature = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$o,
  name: name$17,
  parse: parse$o,
  structure: structure$l
}, Symbol.toStringTag, { value: "Module" }));
const name$16 = "MediaQuery";
const structure$k = {
  children: [[
    "Identifier",
    "MediaFeature",
    "WhiteSpace"
  ]]
};
function parse$n() {
  const children = this.createList();
  let child = null;
  this.skipSC();
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case Comment$1:
        case WhiteSpace$1:
          this.next();
          continue;
        case Ident:
          child = this.Identifier();
          break;
        case LeftParenthesis:
          child = this.MediaFeature();
          break;
        default:
          break scan;
      }
      children.push(child);
    }
  if (child === null) {
    this.error("Identifier or parenthesis is expected");
  }
  return {
    type: "MediaQuery",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate$n(node2) {
  this.children(node2);
}
const MediaQuery = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$n,
  name: name$16,
  parse: parse$n,
  structure: structure$k
}, Symbol.toStringTag, { value: "Module" }));
const name$15 = "MediaQueryList";
const structure$j = {
  children: [[
    "MediaQuery"
  ]]
};
function parse$m() {
  const children = this.createList();
  this.skipSC();
  while (!this.eof) {
    children.push(this.MediaQuery());
    if (this.tokenType !== Comma) {
      break;
    }
    this.next();
  }
  return {
    type: "MediaQueryList",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate$m(node2) {
  this.children(node2, () => this.token(Comma, ","));
}
const MediaQueryList = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$m,
  name: name$15,
  parse: parse$m,
  structure: structure$j
}, Symbol.toStringTag, { value: "Module" }));
const name$14 = "Nth";
const structure$i = {
  nth: ["AnPlusB", "Identifier"],
  selector: ["SelectorList", null]
};
function parse$l() {
  this.skipSC();
  const start = this.tokenStart;
  let end = start;
  let selector2 = null;
  let nth2;
  if (this.lookupValue(0, "odd") || this.lookupValue(0, "even")) {
    nth2 = this.Identifier();
  } else {
    nth2 = this.AnPlusB();
  }
  end = this.tokenStart;
  this.skipSC();
  if (this.lookupValue(0, "of")) {
    this.next();
    selector2 = this.SelectorList();
    end = this.tokenStart;
  }
  return {
    type: "Nth",
    loc: this.getLocation(start, end),
    nth: nth2,
    selector: selector2
  };
}
function generate$l(node2) {
  this.node(node2.nth);
  if (node2.selector !== null) {
    this.token(Ident, "of");
    this.node(node2.selector);
  }
}
const Nth = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$l,
  name: name$14,
  parse: parse$l,
  structure: structure$i
}, Symbol.toStringTag, { value: "Module" }));
const name$13 = "Number";
const structure$h = {
  value: String
};
function parse$k() {
  return {
    type: "Number",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    value: this.consume(Number$3)
  };
}
function generate$k(node2) {
  this.token(Number$3, node2.value);
}
const Number$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$k,
  name: name$13,
  parse: parse$k,
  structure: structure$h
}, Symbol.toStringTag, { value: "Module" }));
const name$12 = "Operator";
const structure$g = {
  value: String
};
function parse$j() {
  const start = this.tokenStart;
  this.next();
  return {
    type: "Operator",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substrToCursor(start)
  };
}
function generate$j(node2) {
  this.tokenize(node2.value);
}
const Operator = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$j,
  name: name$12,
  parse: parse$j,
  structure: structure$g
}, Symbol.toStringTag, { value: "Module" }));
const name$11 = "Parentheses";
const structure$f = {
  children: [[]]
};
function parse$i(readSequence2, recognizer) {
  const start = this.tokenStart;
  let children = null;
  this.eat(LeftParenthesis);
  children = readSequence2.call(this, recognizer);
  if (!this.eof) {
    this.eat(RightParenthesis);
  }
  return {
    type: "Parentheses",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate$i(node2) {
  this.token(LeftParenthesis, "(");
  this.children(node2);
  this.token(RightParenthesis, ")");
}
const Parentheses = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$i,
  name: name$11,
  parse: parse$i,
  structure: structure$f
}, Symbol.toStringTag, { value: "Module" }));
const name$10 = "Percentage";
const structure$e = {
  value: String
};
function parse$h() {
  return {
    type: "Percentage",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    value: this.consumeNumber(Percentage$1)
  };
}
function generate$h(node2) {
  this.token(Percentage$1, node2.value + "%");
}
const Percentage = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$h,
  name: name$10,
  parse: parse$h,
  structure: structure$e
}, Symbol.toStringTag, { value: "Module" }));
const name$$ = "PseudoClassSelector";
const walkContext$4 = "function";
const structure$d = {
  name: String,
  children: [["Raw"], null]
};
function parse$g() {
  const start = this.tokenStart;
  let children = null;
  let name2;
  let nameLowerCase;
  this.eat(Colon);
  if (this.tokenType === Function$1) {
    name2 = this.consumeFunctionName();
    nameLowerCase = name2.toLowerCase();
    if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
      this.skipSC();
      children = this.pseudo[nameLowerCase].call(this);
      this.skipSC();
    } else {
      children = this.createList();
      children.push(
        this.Raw(this.tokenIndex, null, false)
      );
    }
    this.eat(RightParenthesis);
  } else {
    name2 = this.consume(Ident);
  }
  return {
    type: "PseudoClassSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: name2,
    children
  };
}
function generate$g(node2) {
  this.token(Colon, ":");
  if (node2.children === null) {
    this.token(Ident, node2.name);
  } else {
    this.token(Function$1, node2.name + "(");
    this.children(node2);
    this.token(RightParenthesis, ")");
  }
}
const PseudoClassSelector = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$g,
  name: name$$,
  parse: parse$g,
  structure: structure$d,
  walkContext: walkContext$4
}, Symbol.toStringTag, { value: "Module" }));
const name$_ = "PseudoElementSelector";
const walkContext$3 = "function";
const structure$c = {
  name: String,
  children: [["Raw"], null]
};
function parse$f() {
  const start = this.tokenStart;
  let children = null;
  let name2;
  let nameLowerCase;
  this.eat(Colon);
  this.eat(Colon);
  if (this.tokenType === Function$1) {
    name2 = this.consumeFunctionName();
    nameLowerCase = name2.toLowerCase();
    if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
      this.skipSC();
      children = this.pseudo[nameLowerCase].call(this);
      this.skipSC();
    } else {
      children = this.createList();
      children.push(
        this.Raw(this.tokenIndex, null, false)
      );
    }
    this.eat(RightParenthesis);
  } else {
    name2 = this.consume(Ident);
  }
  return {
    type: "PseudoElementSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: name2,
    children
  };
}
function generate$f(node2) {
  this.token(Colon, ":");
  this.token(Colon, ":");
  if (node2.children === null) {
    this.token(Ident, node2.name);
  } else {
    this.token(Function$1, node2.name + "(");
    this.children(node2);
    this.token(RightParenthesis, ")");
  }
}
const PseudoElementSelector = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$f,
  name: name$_,
  parse: parse$f,
  structure: structure$c,
  walkContext: walkContext$3
}, Symbol.toStringTag, { value: "Module" }));
const SOLIDUS$2 = 47;
const FULLSTOP$1 = 46;
function consumeNumber() {
  this.skipSC();
  const value2 = this.consume(Number$3);
  for (let i = 0; i < value2.length; i++) {
    const code2 = value2.charCodeAt(i);
    if (!isDigit$1(code2) && code2 !== FULLSTOP$1) {
      this.error("Unsigned number is expected", this.tokenStart - value2.length + i);
    }
  }
  if (Number(value2) === 0) {
    this.error("Zero number is not allowed", this.tokenStart - value2.length);
  }
  return value2;
}
const name$Z = "Ratio";
const structure$b = {
  left: String,
  right: String
};
function parse$e() {
  const start = this.tokenStart;
  const left = consumeNumber.call(this);
  let right;
  this.skipSC();
  this.eatDelim(SOLIDUS$2);
  right = consumeNumber.call(this);
  return {
    type: "Ratio",
    loc: this.getLocation(start, this.tokenStart),
    left,
    right
  };
}
function generate$e(node2) {
  this.token(Number$3, node2.left);
  this.token(Delim, "/");
  this.token(Number$3, node2.right);
}
const Ratio = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$e,
  name: name$Z,
  parse: parse$e,
  structure: structure$b
}, Symbol.toStringTag, { value: "Module" }));
function getOffsetExcludeWS() {
  if (this.tokenIndex > 0) {
    if (this.lookupType(-1) === WhiteSpace$1) {
      return this.tokenIndex > 1 ? this.getTokenStart(this.tokenIndex - 1) : this.firstCharOffset;
    }
  }
  return this.tokenStart;
}
const name$Y = "Raw";
const structure$a = {
  value: String
};
function parse$d(startToken, consumeUntil, excludeWhiteSpace) {
  const startOffset = this.getTokenStart(startToken);
  let endOffset;
  this.skipUntilBalanced(startToken, consumeUntil || this.consumeUntilBalanceEnd);
  if (excludeWhiteSpace && this.tokenStart > startOffset) {
    endOffset = getOffsetExcludeWS.call(this);
  } else {
    endOffset = this.tokenStart;
  }
  return {
    type: "Raw",
    loc: this.getLocation(startOffset, endOffset),
    value: this.substring(startOffset, endOffset)
  };
}
function generate$d(node2) {
  this.tokenize(node2.value);
}
const Raw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$d,
  name: name$Y,
  parse: parse$d,
  structure: structure$a
}, Symbol.toStringTag, { value: "Module" }));
function consumeRaw$2(startToken) {
  return this.Raw(startToken, this.consumeUntilLeftCurlyBracket, true);
}
function consumePrelude() {
  const prelude = this.SelectorList();
  if (prelude.type !== "Raw" && this.eof === false && this.tokenType !== LeftCurlyBracket) {
    this.error();
  }
  return prelude;
}
const name$X = "Rule";
const walkContext$2 = "rule";
const structure$9 = {
  prelude: ["SelectorList", "Raw"],
  block: ["Block"]
};
function parse$c() {
  const startToken = this.tokenIndex;
  const startOffset = this.tokenStart;
  let prelude;
  let block;
  if (this.parseRulePrelude) {
    prelude = this.parseWithFallback(consumePrelude, consumeRaw$2);
  } else {
    prelude = consumeRaw$2.call(this, startToken);
  }
  block = this.Block(true);
  return {
    type: "Rule",
    loc: this.getLocation(startOffset, this.tokenStart),
    prelude,
    block
  };
}
function generate$c(node2) {
  this.node(node2.prelude);
  this.node(node2.block);
}
const Rule = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$c,
  name: name$X,
  parse: parse$c,
  structure: structure$9,
  walkContext: walkContext$2
}, Symbol.toStringTag, { value: "Module" }));
const name$W = "Selector";
const structure$8 = {
  children: [[
    "TypeSelector",
    "IdSelector",
    "ClassSelector",
    "AttributeSelector",
    "PseudoClassSelector",
    "PseudoElementSelector",
    "Combinator",
    "WhiteSpace"
  ]]
};
function parse$b() {
  const children = this.readSequence(this.scope.Selector);
  if (this.getFirstListNode(children) === null) {
    this.error("Selector is expected");
  }
  return {
    type: "Selector",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate$b(node2) {
  this.children(node2);
}
const Selector = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$b,
  name: name$W,
  parse: parse$b,
  structure: structure$8
}, Symbol.toStringTag, { value: "Module" }));
const name$V = "SelectorList";
const walkContext$1 = "selector";
const structure$7 = {
  children: [[
    "Selector",
    "Raw"
  ]]
};
function parse$a() {
  const children = this.createList();
  while (!this.eof) {
    children.push(this.Selector());
    if (this.tokenType === Comma) {
      this.next();
      continue;
    }
    break;
  }
  return {
    type: "SelectorList",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate$a(node2) {
  this.children(node2, () => this.token(Comma, ","));
}
const SelectorList = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$a,
  name: name$V,
  parse: parse$a,
  structure: structure$7,
  walkContext: walkContext$1
}, Symbol.toStringTag, { value: "Module" }));
const REVERSE_SOLIDUS$1 = 92;
const QUOTATION_MARK$1 = 34;
const APOSTROPHE$1 = 39;
function decode$1(str) {
  const len = str.length;
  const firstChar = str.charCodeAt(0);
  const start = firstChar === QUOTATION_MARK$1 || firstChar === APOSTROPHE$1 ? 1 : 0;
  const end = start === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar ? len - 2 : len - 1;
  let decoded = "";
  for (let i = start; i <= end; i++) {
    let code2 = str.charCodeAt(i);
    if (code2 === REVERSE_SOLIDUS$1) {
      if (i === end) {
        if (i !== len - 1) {
          decoded = str.substr(i + 1);
        }
        break;
      }
      code2 = str.charCodeAt(++i);
      if (isValidEscape(REVERSE_SOLIDUS$1, code2)) {
        const escapeStart = i - 1;
        const escapeEnd = consumeEscaped(str, escapeStart);
        i = escapeEnd - 1;
        decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
      } else {
        if (code2 === 13 && str.charCodeAt(i + 1) === 10) {
          i++;
        }
      }
    } else {
      decoded += str[i];
    }
  }
  return decoded;
}
function encode$1(str, apostrophe) {
  const quote = apostrophe ? "'" : '"';
  const quoteCode = apostrophe ? APOSTROPHE$1 : QUOTATION_MARK$1;
  let encoded = "";
  let wsBeforeHexIsNeeded = false;
  for (let i = 0; i < str.length; i++) {
    const code2 = str.charCodeAt(i);
    if (code2 === 0) {
      encoded += "�";
      continue;
    }
    if (code2 <= 31 || code2 === 127) {
      encoded += "\\" + code2.toString(16);
      wsBeforeHexIsNeeded = true;
      continue;
    }
    if (code2 === quoteCode || code2 === REVERSE_SOLIDUS$1) {
      encoded += "\\" + str.charAt(i);
      wsBeforeHexIsNeeded = false;
    } else {
      if (wsBeforeHexIsNeeded && (isHexDigit(code2) || isWhiteSpace$1(code2))) {
        encoded += " ";
      }
      encoded += str.charAt(i);
      wsBeforeHexIsNeeded = false;
    }
  }
  return quote + encoded + quote;
}
const name$U = "String";
const structure$6 = {
  value: String
};
function parse$9() {
  return {
    type: "String",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    value: decode$1(this.consume(String$2))
  };
}
function generate$9(node2) {
  this.token(String$2, encode$1(node2.value));
}
const String$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$9,
  name: name$U,
  parse: parse$9,
  structure: structure$6
}, Symbol.toStringTag, { value: "Module" }));
const EXCLAMATIONMARK = 33;
function consumeRaw$1(startToken) {
  return this.Raw(startToken, null, false);
}
const name$T = "StyleSheet";
const walkContext = "stylesheet";
const structure$5 = {
  children: [[
    "Comment",
    "CDO",
    "CDC",
    "Atrule",
    "Rule",
    "Raw"
  ]]
};
function parse$8() {
  const start = this.tokenStart;
  const children = this.createList();
  let child;
  while (!this.eof) {
    switch (this.tokenType) {
      case WhiteSpace$1:
        this.next();
        continue;
      case Comment$1:
        if (this.charCodeAt(this.tokenStart + 2) !== EXCLAMATIONMARK) {
          this.next();
          continue;
        }
        child = this.Comment();
        break;
      case CDO$1:
        child = this.CDO();
        break;
      case CDC$1:
        child = this.CDC();
        break;
      // CSS Syntax Module Level 3
      // §2.2 Error handling
      // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
      case AtKeyword:
        child = this.parseWithFallback(this.Atrule, consumeRaw$1);
        break;
      // Anything else starts a qualified rule ...
      default:
        child = this.parseWithFallback(this.Rule, consumeRaw$1);
    }
    children.push(child);
  }
  return {
    type: "StyleSheet",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate$8(node2) {
  this.children(node2);
}
const StyleSheet = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$8,
  name: name$T,
  parse: parse$8,
  structure: structure$5,
  walkContext
}, Symbol.toStringTag, { value: "Module" }));
const ASTERISK$2 = 42;
const VERTICALLINE$1 = 124;
function eatIdentifierOrAsterisk() {
  if (this.tokenType !== Ident && this.isDelim(ASTERISK$2) === false) {
    this.error("Identifier or asterisk is expected");
  }
  this.next();
}
const name$S = "TypeSelector";
const structure$4 = {
  name: String
};
function parse$7() {
  const start = this.tokenStart;
  if (this.isDelim(VERTICALLINE$1)) {
    this.next();
    eatIdentifierOrAsterisk.call(this);
  } else {
    eatIdentifierOrAsterisk.call(this);
    if (this.isDelim(VERTICALLINE$1)) {
      this.next();
      eatIdentifierOrAsterisk.call(this);
    }
  }
  return {
    type: "TypeSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: this.substrToCursor(start)
  };
}
function generate$7(node2) {
  this.tokenize(node2.name);
}
const TypeSelector = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$7,
  name: name$S,
  parse: parse$7,
  structure: structure$4
}, Symbol.toStringTag, { value: "Module" }));
const PLUSSIGN$2 = 43;
const HYPHENMINUS$1 = 45;
const QUESTIONMARK = 63;
function eatHexSequence(offset, allowDash) {
  let len = 0;
  for (let pos = this.tokenStart + offset; pos < this.tokenEnd; pos++) {
    const code2 = this.charCodeAt(pos);
    if (code2 === HYPHENMINUS$1 && allowDash && len !== 0) {
      eatHexSequence.call(this, offset + len + 1, false);
      return -1;
    }
    if (!isHexDigit(code2)) {
      this.error(
        allowDash && len !== 0 ? "Hyphen minus" + (len < 6 ? " or hex digit" : "") + " is expected" : len < 6 ? "Hex digit is expected" : "Unexpected input",
        pos
      );
    }
    if (++len > 6) {
      this.error("Too many hex digits", pos);
    }
  }
  this.next();
  return len;
}
function eatQuestionMarkSequence(max) {
  let count = 0;
  while (this.isDelim(QUESTIONMARK)) {
    if (++count > max) {
      this.error("Too many question marks");
    }
    this.next();
  }
}
function startsWith(code2) {
  if (this.charCodeAt(this.tokenStart) !== code2) {
    this.error((code2 === PLUSSIGN$2 ? "Plus sign" : "Hyphen minus") + " is expected");
  }
}
function scanUnicodeRange() {
  let hexLength = 0;
  switch (this.tokenType) {
    case Number$3:
      hexLength = eatHexSequence.call(this, 1, true);
      if (this.isDelim(QUESTIONMARK)) {
        eatQuestionMarkSequence.call(this, 6 - hexLength);
        break;
      }
      if (this.tokenType === Dimension$1 || this.tokenType === Number$3) {
        startsWith.call(this, HYPHENMINUS$1);
        eatHexSequence.call(this, 1, false);
        break;
      }
      break;
    case Dimension$1:
      hexLength = eatHexSequence.call(this, 1, true);
      if (hexLength > 0) {
        eatQuestionMarkSequence.call(this, 6 - hexLength);
      }
      break;
    default:
      this.eatDelim(PLUSSIGN$2);
      if (this.tokenType === Ident) {
        hexLength = eatHexSequence.call(this, 0, true);
        if (hexLength > 0) {
          eatQuestionMarkSequence.call(this, 6 - hexLength);
        }
        break;
      }
      if (this.isDelim(QUESTIONMARK)) {
        this.next();
        eatQuestionMarkSequence.call(this, 5);
        break;
      }
      this.error("Hex digit or question mark is expected");
  }
}
const name$R = "UnicodeRange";
const structure$3 = {
  value: String
};
function parse$6() {
  const start = this.tokenStart;
  this.eatIdent("u");
  scanUnicodeRange.call(this);
  return {
    type: "UnicodeRange",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substrToCursor(start)
  };
}
function generate$6(node2) {
  this.tokenize(node2.value);
}
const UnicodeRange = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$6,
  name: name$R,
  parse: parse$6,
  structure: structure$3
}, Symbol.toStringTag, { value: "Module" }));
const SPACE$1 = 32;
const REVERSE_SOLIDUS = 92;
const QUOTATION_MARK = 34;
const APOSTROPHE = 39;
const LEFTPARENTHESIS = 40;
const RIGHTPARENTHESIS = 41;
function decode(str) {
  const len = str.length;
  let start = 4;
  let end = str.charCodeAt(len - 1) === RIGHTPARENTHESIS ? len - 2 : len - 1;
  let decoded = "";
  while (start < end && isWhiteSpace$1(str.charCodeAt(start))) {
    start++;
  }
  while (start < end && isWhiteSpace$1(str.charCodeAt(end))) {
    end--;
  }
  for (let i = start; i <= end; i++) {
    let code2 = str.charCodeAt(i);
    if (code2 === REVERSE_SOLIDUS) {
      if (i === end) {
        if (i !== len - 1) {
          decoded = str.substr(i + 1);
        }
        break;
      }
      code2 = str.charCodeAt(++i);
      if (isValidEscape(REVERSE_SOLIDUS, code2)) {
        const escapeStart = i - 1;
        const escapeEnd = consumeEscaped(str, escapeStart);
        i = escapeEnd - 1;
        decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
      } else {
        if (code2 === 13 && str.charCodeAt(i + 1) === 10) {
          i++;
        }
      }
    } else {
      decoded += str[i];
    }
  }
  return decoded;
}
function encode(str) {
  let encoded = "";
  let wsBeforeHexIsNeeded = false;
  for (let i = 0; i < str.length; i++) {
    const code2 = str.charCodeAt(i);
    if (code2 === 0) {
      encoded += "�";
      continue;
    }
    if (code2 <= 31 || code2 === 127) {
      encoded += "\\" + code2.toString(16);
      wsBeforeHexIsNeeded = true;
      continue;
    }
    if (code2 === SPACE$1 || code2 === REVERSE_SOLIDUS || code2 === QUOTATION_MARK || code2 === APOSTROPHE || code2 === LEFTPARENTHESIS || code2 === RIGHTPARENTHESIS) {
      encoded += "\\" + str.charAt(i);
      wsBeforeHexIsNeeded = false;
    } else {
      if (wsBeforeHexIsNeeded && isHexDigit(code2)) {
        encoded += " ";
      }
      encoded += str.charAt(i);
      wsBeforeHexIsNeeded = false;
    }
  }
  return "url(" + encoded + ")";
}
const name$Q = "Url";
const structure$2 = {
  value: String
};
function parse$5() {
  const start = this.tokenStart;
  let value2;
  switch (this.tokenType) {
    case Url$2:
      value2 = decode(this.consume(Url$2));
      break;
    case Function$1:
      if (!this.cmpStr(this.tokenStart, this.tokenEnd, "url(")) {
        this.error("Function name must be `url`");
      }
      this.eat(Function$1);
      this.skipSC();
      value2 = decode$1(this.consume(String$2));
      this.skipSC();
      if (!this.eof) {
        this.eat(RightParenthesis);
      }
      break;
    default:
      this.error("Url or Function is expected");
  }
  return {
    type: "Url",
    loc: this.getLocation(start, this.tokenStart),
    value: value2
  };
}
function generate$5(node2) {
  this.token(Url$2, encode(node2.value));
}
const Url$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$5,
  name: name$Q,
  parse: parse$5,
  structure: structure$2
}, Symbol.toStringTag, { value: "Module" }));
const name$P = "Value";
const structure$1 = {
  children: [[]]
};
function parse$4() {
  const start = this.tokenStart;
  const children = this.readSequence(this.scope.Value);
  return {
    type: "Value",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate$4(node2) {
  this.children(node2);
}
const Value = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$4,
  name: name$P,
  parse: parse$4,
  structure: structure$1
}, Symbol.toStringTag, { value: "Module" }));
const SPACE = Object.freeze({
  type: "WhiteSpace",
  loc: null,
  value: " "
});
const name$O = "WhiteSpace";
const structure = {
  value: String
};
function parse$3() {
  this.eat(WhiteSpace$1);
  return SPACE;
}
function generate$3(node2) {
  this.token(WhiteSpace$1, node2.value);
}
const WhiteSpace = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generate: generate$3,
  name: name$O,
  parse: parse$3,
  structure
}, Symbol.toStringTag, { value: "Module" }));
const node$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AnPlusB,
  Atrule: Atrule$1,
  AtrulePrelude,
  AttributeSelector: AttributeSelector$1,
  Block,
  Brackets,
  CDC,
  CDO,
  ClassSelector,
  Combinator,
  Comment,
  Declaration,
  DeclarationList,
  Dimension,
  Function,
  Hash,
  IdSelector,
  Identifier,
  MediaFeature,
  MediaQuery,
  MediaQueryList,
  Nth,
  Number: Number$2,
  Operator,
  Parentheses,
  Percentage,
  PseudoClassSelector,
  PseudoElementSelector,
  Ratio,
  Raw,
  Rule,
  Selector,
  SelectorList,
  String: String$1,
  StyleSheet,
  TypeSelector,
  UnicodeRange,
  Url: Url$1,
  Value,
  WhiteSpace
}, Symbol.toStringTag, { value: "Module" }));
const lexerConfig = {
  generic: true,
  ...definitions,
  node: node$1
};
const NUMBERSIGN$1 = 35;
const ASTERISK$1 = 42;
const PLUSSIGN$1 = 43;
const HYPHENMINUS = 45;
const SOLIDUS$1 = 47;
const U = 117;
function defaultRecognizer(context) {
  switch (this.tokenType) {
    case Hash$1:
      return this.Hash();
    case Comma:
      return this.Operator();
    case LeftParenthesis:
      return this.Parentheses(this.readSequence, context.recognizer);
    case LeftSquareBracket:
      return this.Brackets(this.readSequence, context.recognizer);
    case String$2:
      return this.String();
    case Dimension$1:
      return this.Dimension();
    case Percentage$1:
      return this.Percentage();
    case Number$3:
      return this.Number();
    case Function$1:
      return this.cmpStr(this.tokenStart, this.tokenEnd, "url(") ? this.Url() : this.Function(this.readSequence, context.recognizer);
    case Url$2:
      return this.Url();
    case Ident:
      if (this.cmpChar(this.tokenStart, U) && this.cmpChar(this.tokenStart + 1, PLUSSIGN$1)) {
        return this.UnicodeRange();
      } else {
        return this.Identifier();
      }
    case Delim: {
      const code2 = this.charCodeAt(this.tokenStart);
      if (code2 === SOLIDUS$1 || code2 === ASTERISK$1 || code2 === PLUSSIGN$1 || code2 === HYPHENMINUS) {
        return this.Operator();
      }
      if (code2 === NUMBERSIGN$1) {
        this.error("Hex or identifier is expected", this.tokenStart + 1);
      }
      break;
    }
  }
}
const atrulePrelude = {
  getNode: defaultRecognizer
};
const NUMBERSIGN = 35;
const ASTERISK = 42;
const PLUSSIGN = 43;
const SOLIDUS = 47;
const FULLSTOP = 46;
const GREATERTHANSIGN = 62;
const VERTICALLINE = 124;
const TILDE = 126;
function onWhiteSpace(next, children) {
  if (children.last !== null && children.last.type !== "Combinator" && next !== null && next.type !== "Combinator") {
    children.push({
      // FIXME: this.Combinator() should be used instead
      type: "Combinator",
      loc: null,
      name: " "
    });
  }
}
function getNode() {
  switch (this.tokenType) {
    case LeftSquareBracket:
      return this.AttributeSelector();
    case Hash$1:
      return this.IdSelector();
    case Colon:
      if (this.lookupType(1) === Colon) {
        return this.PseudoElementSelector();
      } else {
        return this.PseudoClassSelector();
      }
    case Ident:
      return this.TypeSelector();
    case Number$3:
    case Percentage$1:
      return this.Percentage();
    case Dimension$1:
      if (this.charCodeAt(this.tokenStart) === FULLSTOP) {
        this.error("Identifier is expected", this.tokenStart + 1);
      }
      break;
    case Delim: {
      const code2 = this.charCodeAt(this.tokenStart);
      switch (code2) {
        case PLUSSIGN:
        case GREATERTHANSIGN:
        case TILDE:
        case SOLIDUS:
          return this.Combinator();
        case FULLSTOP:
          return this.ClassSelector();
        case ASTERISK:
        case VERTICALLINE:
          return this.TypeSelector();
        case NUMBERSIGN:
          return this.IdSelector();
      }
      break;
    }
  }
}
const selector$1 = {
  onWhiteSpace,
  getNode
};
function expressionFn() {
  return this.createSingleNodeList(
    this.Raw(this.tokenIndex, null, false)
  );
}
function varFn() {
  const children = this.createList();
  this.skipSC();
  children.push(this.Identifier());
  this.skipSC();
  if (this.tokenType === Comma) {
    children.push(this.Operator());
    const startIndex = this.tokenIndex;
    const value2 = this.parseCustomProperty ? this.Value(null) : this.Raw(this.tokenIndex, this.consumeUntilExclamationMarkOrSemicolon, false);
    if (value2.type === "Value" && value2.children.isEmpty) {
      for (let offset = startIndex - this.tokenIndex; offset <= 0; offset++) {
        if (this.lookupType(offset) === WhiteSpace$1) {
          value2.children.appendData({
            type: "WhiteSpace",
            loc: null,
            value: " "
          });
          break;
        }
      }
    }
    children.push(value2);
  }
  return children;
}
function isPlusMinusOperator(node2) {
  return node2 !== null && node2.type === "Operator" && (node2.value[node2.value.length - 1] === "-" || node2.value[node2.value.length - 1] === "+");
}
const value = {
  getNode: defaultRecognizer,
  onWhiteSpace(next, children) {
    if (isPlusMinusOperator(next)) {
      next.value = " " + next.value;
    }
    if (isPlusMinusOperator(children.last)) {
      children.last.value += " ";
    }
  },
  "expression": expressionFn,
  "var": varFn
};
const scope = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AtrulePrelude: atrulePrelude,
  Selector: selector$1,
  Value: value
}, Symbol.toStringTag, { value: "Module" }));
const fontFace = {
  parse: {
    prelude: null,
    block() {
      return this.Block(true);
    }
  }
};
const importAtrule = {
  parse: {
    prelude() {
      const children = this.createList();
      this.skipSC();
      switch (this.tokenType) {
        case String$2:
          children.push(this.String());
          break;
        case Url$2:
        case Function$1:
          children.push(this.Url());
          break;
        default:
          this.error("String or url() is expected");
      }
      if (this.lookupNonWSType(0) === Ident || this.lookupNonWSType(0) === LeftParenthesis) {
        children.push(this.MediaQueryList());
      }
      return children;
    },
    block: null
  }
};
const media = {
  parse: {
    prelude() {
      return this.createSingleNodeList(
        this.MediaQueryList()
      );
    },
    block() {
      return this.Block(false);
    }
  }
};
const page = {
  parse: {
    prelude() {
      return this.createSingleNodeList(
        this.SelectorList()
      );
    },
    block() {
      return this.Block(true);
    }
  }
};
function consumeRaw() {
  return this.createSingleNodeList(
    this.Raw(this.tokenIndex, null, false)
  );
}
function parentheses() {
  this.skipSC();
  if (this.tokenType === Ident && this.lookupNonWSType(1) === Colon) {
    return this.createSingleNodeList(
      this.Declaration()
    );
  }
  return readSequence.call(this);
}
function readSequence() {
  const children = this.createList();
  let child;
  this.skipSC();
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case Comment$1:
        case WhiteSpace$1:
          this.next();
          continue;
        case Function$1:
          child = this.Function(consumeRaw, this.scope.AtrulePrelude);
          break;
        case Ident:
          child = this.Identifier();
          break;
        case LeftParenthesis:
          child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
          break;
        default:
          break scan;
      }
      children.push(child);
    }
  return children;
}
const supports = {
  parse: {
    prelude() {
      const children = readSequence.call(this);
      if (this.getFirstListNode(children) === null) {
        this.error("Condition is expected");
      }
      return children;
    },
    block() {
      return this.Block(false);
    }
  }
};
const atrule = {
  "font-face": fontFace,
  "import": importAtrule,
  media,
  page,
  supports
};
const selectorList = {
  parse() {
    return this.createSingleNodeList(
      this.SelectorList()
    );
  }
};
const selector = {
  parse() {
    return this.createSingleNodeList(
      this.Selector()
    );
  }
};
const identList = {
  parse() {
    return this.createSingleNodeList(
      this.Identifier()
    );
  }
};
const nth = {
  parse() {
    return this.createSingleNodeList(
      this.Nth()
    );
  }
};
const pseudo = {
  "dir": identList,
  "has": selectorList,
  "lang": identList,
  "matches": selectorList,
  "is": selectorList,
  "-moz-any": selectorList,
  "-webkit-any": selectorList,
  "where": selectorList,
  "not": selectorList,
  "nth-child": nth,
  "nth-last-child": nth,
  "nth-last-of-type": nth,
  "nth-of-type": nth,
  "slotted": selector
};
const node = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AnPlusB: parse$G,
  Atrule: parse$F,
  AtrulePrelude: parse$E,
  AttributeSelector: parse$D,
  Block: parse$C,
  Brackets: parse$B,
  CDC: parse$A,
  CDO: parse$z,
  ClassSelector: parse$y,
  Combinator: parse$x,
  Comment: parse$w,
  Declaration: parse$v,
  DeclarationList: parse$u,
  Dimension: parse$t,
  Function: parse$s,
  Hash: parse$r,
  IdSelector: parse$p,
  Identifier: parse$q,
  MediaFeature: parse$o,
  MediaQuery: parse$n,
  MediaQueryList: parse$m,
  Nth: parse$l,
  Number: parse$k,
  Operator: parse$j,
  Parentheses: parse$i,
  Percentage: parse$h,
  PseudoClassSelector: parse$g,
  PseudoElementSelector: parse$f,
  Ratio: parse$e,
  Raw: parse$d,
  Rule: parse$c,
  Selector: parse$b,
  SelectorList: parse$a,
  String: parse$9,
  StyleSheet: parse$8,
  TypeSelector: parse$7,
  UnicodeRange: parse$6,
  Url: parse$5,
  Value: parse$4,
  WhiteSpace: parse$3
}, Symbol.toStringTag, { value: "Module" }));
const parserConfig = {
  parseContext: {
    default: "StyleSheet",
    stylesheet: "StyleSheet",
    atrule: "Atrule",
    atrulePrelude(options) {
      return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
    },
    mediaQueryList: "MediaQueryList",
    mediaQuery: "MediaQuery",
    rule: "Rule",
    selectorList: "SelectorList",
    selector: "Selector",
    block() {
      return this.Block(true);
    },
    declarationList: "DeclarationList",
    declaration: "Declaration",
    value: "Value"
  },
  scope,
  atrule,
  pseudo,
  node
};
const walkerConfig = {
  node: node$1
};
const syntax$1 = createSyntax$1({
  ...lexerConfig,
  ...parserConfig,
  ...walkerConfig
});
function clone(node2) {
  const result = {};
  for (const key in node2) {
    let value2 = node2[key];
    if (value2) {
      if (Array.isArray(value2) || value2 instanceof List2) {
        value2 = value2.map(clone);
      } else if (value2.constructor === Object) {
        value2 = clone(value2);
      }
    }
    result[key] = value2;
  }
  return result;
}
const {
  tokenize: tokenize$1,
  parse: parse$2,
  generate: generate$2,
  lexer: lexer$1,
  createLexer,
  walk: walk$1,
  find: find$1,
  findLast: findLast$1,
  findAll: findAll$1,
  toPlainObject: toPlainObject$1,
  fromPlainObject: fromPlainObject$1,
  fork
} = syntax$1;
const { hasOwnProperty: hasOwnProperty$4 } = Object.prototype;
function buildMap(list, caseInsensitive) {
  const map = /* @__PURE__ */ Object.create(null);
  if (!Array.isArray(list)) {
    return null;
  }
  for (let name2 of list) {
    if (caseInsensitive) {
      name2 = name2.toLowerCase();
    }
    map[name2] = true;
  }
  return map;
}
function buildList(data) {
  if (!data) {
    return null;
  }
  const tags = buildMap(data.tags, true);
  const ids = buildMap(data.ids);
  const classes2 = buildMap(data.classes);
  if (tags === null && ids === null && classes2 === null) {
    return null;
  }
  return {
    tags,
    ids,
    classes: classes2
  };
}
function buildIndex(data) {
  let scopes = false;
  if (data.scopes && Array.isArray(data.scopes)) {
    scopes = /* @__PURE__ */ Object.create(null);
    for (let i = 0; i < data.scopes.length; i++) {
      const list = data.scopes[i];
      if (!list || !Array.isArray(list)) {
        throw new Error("Wrong usage format");
      }
      for (const name2 of list) {
        if (hasOwnProperty$4.call(scopes, name2)) {
          throw new Error(`Class can't be used for several scopes: ${name2}`);
        }
        scopes[name2] = i + 1;
      }
    }
  }
  return {
    whitelist: buildList(data),
    blacklist: buildList(data.blacklist),
    scopes
  };
}
function hasNoChildren(node2) {
  return !node2 || !node2.children || node2.children.isEmpty;
}
function isNodeChildrenList(node2, list) {
  return node2 !== null && node2.children === list;
}
function cleanAtrule(node2, item, list) {
  if (node2.block) {
    if (this.stylesheet !== null) {
      this.stylesheet.firstAtrulesAllowed = false;
    }
    if (hasNoChildren(node2.block)) {
      list.remove(item);
      return;
    }
  }
  switch (node2.name) {
    case "charset":
      if (hasNoChildren(node2.prelude)) {
        list.remove(item);
        return;
      }
      if (item.prev) {
        list.remove(item);
        return;
      }
      break;
    case "import":
      if (this.stylesheet === null || !this.stylesheet.firstAtrulesAllowed) {
        list.remove(item);
        return;
      }
      list.prevUntil(item.prev, function(rule) {
        if (rule.type === "Atrule") {
          if (rule.name === "import" || rule.name === "charset") {
            return;
          }
        }
        this.root.firstAtrulesAllowed = false;
        list.remove(item);
        return true;
      }, this);
      break;
    default: {
      const name2 = keyword(node2.name).basename;
      if (name2 === "keyframes" || name2 === "media" || name2 === "supports") {
        if (hasNoChildren(node2.prelude) || hasNoChildren(node2.block)) {
          list.remove(item);
        }
      }
    }
  }
}
function cleanComment(data, item, list) {
  list.remove(item);
}
function cleanDeclartion(node2, item, list) {
  if (node2.value.children && node2.value.children.isEmpty) {
    list.remove(item);
    return;
  }
  if (property(node2.property).custom) {
    if (/\S/.test(node2.value.value)) {
      node2.value.value = node2.value.value.trim();
    }
  }
}
function cleanRaw(node2, item, list) {
  if (isNodeChildrenList(this.stylesheet, list) || isNodeChildrenList(this.block, list)) {
    list.remove(item);
  }
}
const { hasOwnProperty: hasOwnProperty$3 } = Object.prototype;
const skipUsageFilteringAtrule = /* @__PURE__ */ new Set(["keyframes"]);
function cleanUnused(selectorList2, usageData) {
  selectorList2.children.forEach((selector2, item, list) => {
    let shouldRemove = false;
    walk$1(selector2, function(node2) {
      if (this.selector === null || this.selector === selectorList2) {
        switch (node2.type) {
          case "SelectorList":
            if (this.function === null || this.function.name.toLowerCase() !== "not") {
              if (cleanUnused(node2, usageData)) {
                shouldRemove = true;
              }
            }
            break;
          case "ClassSelector":
            if (usageData.whitelist !== null && usageData.whitelist.classes !== null && !hasOwnProperty$3.call(usageData.whitelist.classes, node2.name)) {
              shouldRemove = true;
            }
            if (usageData.blacklist !== null && usageData.blacklist.classes !== null && hasOwnProperty$3.call(usageData.blacklist.classes, node2.name)) {
              shouldRemove = true;
            }
            break;
          case "IdSelector":
            if (usageData.whitelist !== null && usageData.whitelist.ids !== null && !hasOwnProperty$3.call(usageData.whitelist.ids, node2.name)) {
              shouldRemove = true;
            }
            if (usageData.blacklist !== null && usageData.blacklist.ids !== null && hasOwnProperty$3.call(usageData.blacklist.ids, node2.name)) {
              shouldRemove = true;
            }
            break;
          case "TypeSelector":
            if (node2.name.charAt(node2.name.length - 1) !== "*") {
              if (usageData.whitelist !== null && usageData.whitelist.tags !== null && !hasOwnProperty$3.call(usageData.whitelist.tags, node2.name.toLowerCase())) {
                shouldRemove = true;
              }
              if (usageData.blacklist !== null && usageData.blacklist.tags !== null && hasOwnProperty$3.call(usageData.blacklist.tags, node2.name.toLowerCase())) {
                shouldRemove = true;
              }
            }
            break;
        }
      }
    });
    if (shouldRemove) {
      list.remove(item);
    }
  });
  return selectorList2.children.isEmpty;
}
function cleanRule(node2, item, list, options) {
  if (hasNoChildren(node2.prelude) || hasNoChildren(node2.block)) {
    list.remove(item);
    return;
  }
  if (this.atrule && skipUsageFilteringAtrule.has(keyword(this.atrule.name).basename)) {
    return;
  }
  const { usage } = options;
  if (usage && (usage.whitelist !== null || usage.blacklist !== null)) {
    cleanUnused(node2.prelude, usage);
    if (hasNoChildren(node2.prelude)) {
      list.remove(item);
      return;
    }
  }
}
function cleanTypeSelector(node2, item, list) {
  const name2 = item.data.name;
  if (name2 !== "*") {
    return;
  }
  const nextType = item.next && item.next.data.type;
  if (nextType === "IdSelector" || nextType === "ClassSelector" || nextType === "AttributeSelector" || nextType === "PseudoClassSelector" || nextType === "PseudoElementSelector") {
    list.remove(item);
  }
}
function cleanWhitespace(node2, item, list) {
  list.remove(item);
}
const handlers$2 = {
  Atrule: cleanAtrule,
  Comment: cleanComment,
  Declaration: cleanDeclartion,
  Raw: cleanRaw,
  Rule: cleanRule,
  TypeSelector: cleanTypeSelector,
  WhiteSpace: cleanWhitespace
};
function clean(ast, options) {
  walk$1(ast, {
    leave(node2, item, list) {
      if (handlers$2.hasOwnProperty(node2.type)) {
        handlers$2[node2.type].call(this, node2, item, list, options);
      }
    }
  });
}
function compressKeyframes(node2) {
  node2.block.children.forEach((rule) => {
    rule.prelude.children.forEach((simpleselector) => {
      simpleselector.children.forEach((data, item) => {
        if (data.type === "Percentage" && data.value === "100") {
          item.data = {
            type: "TypeSelector",
            loc: data.loc,
            name: "to"
          };
        } else if (data.type === "TypeSelector" && data.name === "from") {
          item.data = {
            type: "Percentage",
            loc: data.loc,
            value: "0"
          };
        }
      });
    });
  });
}
function Atrule(node2) {
  if (keyword(node2.name).basename === "keyframes") {
    compressKeyframes(node2);
  }
}
const blockUnquoteRx = /^(-?\d|--)|[\u0000-\u002c\u002e\u002f\u003A-\u0040\u005B-\u005E\u0060\u007B-\u009f]/;
function canUnquote(value2) {
  if (value2 === "" || value2 === "-") {
    return false;
  }
  return !blockUnquoteRx.test(value2);
}
function AttributeSelector(node2) {
  const attrValue = node2.value;
  if (!attrValue || attrValue.type !== "String") {
    return;
  }
  if (canUnquote(attrValue.value)) {
    node2.value = {
      type: "Identifier",
      loc: attrValue.loc,
      name: attrValue.value
    };
  }
}
function compressFont(node2) {
  const list = node2.children;
  list.forEachRight(function(node3, item) {
    if (node3.type === "Identifier") {
      if (node3.name === "bold") {
        item.data = {
          type: "Number",
          loc: node3.loc,
          value: "700"
        };
      } else if (node3.name === "normal") {
        const prev = item.prev;
        if (prev && prev.data.type === "Operator" && prev.data.value === "/") {
          this.remove(prev);
        }
        this.remove(item);
      }
    }
  });
  if (list.isEmpty) {
    list.insert(list.createItem({
      type: "Identifier",
      name: "normal"
    }));
  }
}
function compressFontWeight(node2) {
  const value2 = node2.children.head.data;
  if (value2.type === "Identifier") {
    switch (value2.name) {
      case "normal":
        node2.children.head.data = {
          type: "Number",
          loc: value2.loc,
          value: "400"
        };
        break;
      case "bold":
        node2.children.head.data = {
          type: "Number",
          loc: value2.loc,
          value: "700"
        };
        break;
    }
  }
}
function compressBackground(node2) {
  function flush() {
    if (!buffer2.length) {
      buffer2.unshift(
        {
          type: "Number",
          loc: null,
          value: "0"
        },
        {
          type: "Number",
          loc: null,
          value: "0"
        }
      );
    }
    newValue.push.apply(newValue, buffer2);
    buffer2 = [];
  }
  let newValue = [];
  let buffer2 = [];
  node2.children.forEach((node3) => {
    if (node3.type === "Operator" && node3.value === ",") {
      flush();
      newValue.push(node3);
      return;
    }
    if (node3.type === "Identifier") {
      if (node3.name === "transparent" || node3.name === "none" || node3.name === "repeat" || node3.name === "scroll") {
        return;
      }
    }
    buffer2.push(node3);
  });
  flush();
  node2.children = new List2().fromArray(newValue);
}
function compressBorder(node2) {
  node2.children.forEach((node3, item, list) => {
    if (node3.type === "Identifier" && node3.name.toLowerCase() === "none") {
      if (list.head === list.tail) {
        item.data = {
          type: "Number",
          loc: node3.loc,
          value: "0"
        };
      } else {
        list.remove(item);
      }
    }
  });
}
const handlers$1 = {
  "font": compressFont,
  "font-weight": compressFontWeight,
  "background": compressBackground,
  "border": compressBorder,
  "outline": compressBorder
};
function compressValue(node2) {
  if (!this.declaration) {
    return;
  }
  const property$12 = property(this.declaration.property);
  if (handlers$1.hasOwnProperty(property$12.basename)) {
    handlers$1[property$12.basename](node2);
  }
}
const OMIT_PLUSSIGN = /^(?:\+|(-))?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
function packNumber(value2, item) {
  const regexp = OMIT_PLUSSIGN;
  value2 = String(value2).replace(regexp, "$1$2$3");
  if (value2 === "" || value2 === "-") {
    value2 = "0";
  }
  return value2;
}
function Number$1(node2) {
  node2.value = packNumber(node2.value);
}
const MATH_FUNCTIONS = /* @__PURE__ */ new Set([
  "calc",
  "min",
  "max",
  "clamp"
]);
const LENGTH_UNIT = /* @__PURE__ */ new Set([
  // absolute length units
  "px",
  "mm",
  "cm",
  "in",
  "pt",
  "pc",
  // relative length units
  "em",
  "ex",
  "ch",
  "rem",
  // viewport-percentage lengths
  "vh",
  "vw",
  "vmin",
  "vmax",
  "vm"
]);
function compressDimension(node2, item) {
  const value2 = packNumber(node2.value);
  node2.value = value2;
  if (value2 === "0" && this.declaration !== null && this.atrulePrelude === null) {
    const unit = node2.unit.toLowerCase();
    if (!LENGTH_UNIT.has(unit)) {
      return;
    }
    if (this.declaration.property === "-ms-flex" || this.declaration.property === "flex") {
      return;
    }
    if (this.function && MATH_FUNCTIONS.has(this.function.name)) {
      return;
    }
    item.data = {
      type: "Number",
      loc: node2.loc,
      value: value2
    };
  }
}
const blacklist = /* @__PURE__ */ new Set([
  // see https://github.com/jakubpawlowicz/clean-css/issues/957
  "width",
  "min-width",
  "max-width",
  "height",
  "min-height",
  "max-height",
  // issue #410: Don’t remove units in flex-basis value for (-ms-)flex shorthand
  // issue #362: shouldn't remove unit in -ms-flex since it breaks flex in IE10/11
  // issue #200: shouldn't remove unit in flex since it breaks flex in IE10/11
  "flex",
  "-ms-flex"
]);
function compressPercentage(node2, item) {
  node2.value = packNumber(node2.value);
  if (node2.value === "0" && this.declaration && !blacklist.has(this.declaration.property)) {
    item.data = {
      type: "Number",
      loc: node2.loc,
      value: node2.value
    };
    if (!lexer$1.matchDeclaration(this.declaration).isType(item.data, "length")) {
      item.data = node2;
    }
  }
}
function Url(node2) {
  node2.value = node2.value.replace(/\\/g, "/");
}
const NAME_TO_HEX = {
  "aliceblue": "f0f8ff",
  "antiquewhite": "faebd7",
  "aqua": "0ff",
  "aquamarine": "7fffd4",
  "azure": "f0ffff",
  "beige": "f5f5dc",
  "bisque": "ffe4c4",
  "black": "000",
  "blanchedalmond": "ffebcd",
  "blue": "00f",
  "blueviolet": "8a2be2",
  "brown": "a52a2a",
  "burlywood": "deb887",
  "cadetblue": "5f9ea0",
  "chartreuse": "7fff00",
  "chocolate": "d2691e",
  "coral": "ff7f50",
  "cornflowerblue": "6495ed",
  "cornsilk": "fff8dc",
  "crimson": "dc143c",
  "cyan": "0ff",
  "darkblue": "00008b",
  "darkcyan": "008b8b",
  "darkgoldenrod": "b8860b",
  "darkgray": "a9a9a9",
  "darkgrey": "a9a9a9",
  "darkgreen": "006400",
  "darkkhaki": "bdb76b",
  "darkmagenta": "8b008b",
  "darkolivegreen": "556b2f",
  "darkorange": "ff8c00",
  "darkorchid": "9932cc",
  "darkred": "8b0000",
  "darksalmon": "e9967a",
  "darkseagreen": "8fbc8f",
  "darkslateblue": "483d8b",
  "darkslategray": "2f4f4f",
  "darkslategrey": "2f4f4f",
  "darkturquoise": "00ced1",
  "darkviolet": "9400d3",
  "deeppink": "ff1493",
  "deepskyblue": "00bfff",
  "dimgray": "696969",
  "dimgrey": "696969",
  "dodgerblue": "1e90ff",
  "firebrick": "b22222",
  "floralwhite": "fffaf0",
  "forestgreen": "228b22",
  "fuchsia": "f0f",
  "gainsboro": "dcdcdc",
  "ghostwhite": "f8f8ff",
  "gold": "ffd700",
  "goldenrod": "daa520",
  "gray": "808080",
  "grey": "808080",
  "green": "008000",
  "greenyellow": "adff2f",
  "honeydew": "f0fff0",
  "hotpink": "ff69b4",
  "indianred": "cd5c5c",
  "indigo": "4b0082",
  "ivory": "fffff0",
  "khaki": "f0e68c",
  "lavender": "e6e6fa",
  "lavenderblush": "fff0f5",
  "lawngreen": "7cfc00",
  "lemonchiffon": "fffacd",
  "lightblue": "add8e6",
  "lightcoral": "f08080",
  "lightcyan": "e0ffff",
  "lightgoldenrodyellow": "fafad2",
  "lightgray": "d3d3d3",
  "lightgrey": "d3d3d3",
  "lightgreen": "90ee90",
  "lightpink": "ffb6c1",
  "lightsalmon": "ffa07a",
  "lightseagreen": "20b2aa",
  "lightskyblue": "87cefa",
  "lightslategray": "789",
  "lightslategrey": "789",
  "lightsteelblue": "b0c4de",
  "lightyellow": "ffffe0",
  "lime": "0f0",
  "limegreen": "32cd32",
  "linen": "faf0e6",
  "magenta": "f0f",
  "maroon": "800000",
  "mediumaquamarine": "66cdaa",
  "mediumblue": "0000cd",
  "mediumorchid": "ba55d3",
  "mediumpurple": "9370db",
  "mediumseagreen": "3cb371",
  "mediumslateblue": "7b68ee",
  "mediumspringgreen": "00fa9a",
  "mediumturquoise": "48d1cc",
  "mediumvioletred": "c71585",
  "midnightblue": "191970",
  "mintcream": "f5fffa",
  "mistyrose": "ffe4e1",
  "moccasin": "ffe4b5",
  "navajowhite": "ffdead",
  "navy": "000080",
  "oldlace": "fdf5e6",
  "olive": "808000",
  "olivedrab": "6b8e23",
  "orange": "ffa500",
  "orangered": "ff4500",
  "orchid": "da70d6",
  "palegoldenrod": "eee8aa",
  "palegreen": "98fb98",
  "paleturquoise": "afeeee",
  "palevioletred": "db7093",
  "papayawhip": "ffefd5",
  "peachpuff": "ffdab9",
  "peru": "cd853f",
  "pink": "ffc0cb",
  "plum": "dda0dd",
  "powderblue": "b0e0e6",
  "purple": "800080",
  "rebeccapurple": "639",
  "red": "f00",
  "rosybrown": "bc8f8f",
  "royalblue": "4169e1",
  "saddlebrown": "8b4513",
  "salmon": "fa8072",
  "sandybrown": "f4a460",
  "seagreen": "2e8b57",
  "seashell": "fff5ee",
  "sienna": "a0522d",
  "silver": "c0c0c0",
  "skyblue": "87ceeb",
  "slateblue": "6a5acd",
  "slategray": "708090",
  "slategrey": "708090",
  "snow": "fffafa",
  "springgreen": "00ff7f",
  "steelblue": "4682b4",
  "tan": "d2b48c",
  "teal": "008080",
  "thistle": "d8bfd8",
  "tomato": "ff6347",
  "turquoise": "40e0d0",
  "violet": "ee82ee",
  "wheat": "f5deb3",
  "white": "fff",
  "whitesmoke": "f5f5f5",
  "yellow": "ff0",
  "yellowgreen": "9acd32"
};
const HEX_TO_NAME = {
  "800000": "maroon",
  "800080": "purple",
  "808000": "olive",
  "808080": "gray",
  "00ffff": "cyan",
  "f0ffff": "azure",
  "f5f5dc": "beige",
  "ffe4c4": "bisque",
  "000000": "black",
  "0000ff": "blue",
  "a52a2a": "brown",
  "ff7f50": "coral",
  "ffd700": "gold",
  "008000": "green",
  "4b0082": "indigo",
  "fffff0": "ivory",
  "f0e68c": "khaki",
  "00ff00": "lime",
  "faf0e6": "linen",
  "000080": "navy",
  "ffa500": "orange",
  "da70d6": "orchid",
  "cd853f": "peru",
  "ffc0cb": "pink",
  "dda0dd": "plum",
  "f00": "red",
  "ff0000": "red",
  "fa8072": "salmon",
  "a0522d": "sienna",
  "c0c0c0": "silver",
  "fffafa": "snow",
  "d2b48c": "tan",
  "008080": "teal",
  "ff6347": "tomato",
  "ee82ee": "violet",
  "f5deb3": "wheat",
  "ffffff": "white",
  "ffff00": "yellow"
};
function hueToRgb(p, q, t) {
  if (t < 0) {
    t += 1;
  }
  if (t > 1) {
    t -= 1;
  }
  if (t < 1 / 6) {
    return p + (q - p) * 6 * t;
  }
  if (t < 1 / 2) {
    return q;
  }
  if (t < 2 / 3) {
    return p + (q - p) * (2 / 3 - t) * 6;
  }
  return p;
}
function hslToRgb(h, s, l, a) {
  let r;
  let g2;
  let b;
  if (s === 0) {
    r = g2 = b = l;
  } else {
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hueToRgb(p, q, h + 1 / 3);
    g2 = hueToRgb(p, q, h);
    b = hueToRgb(p, q, h - 1 / 3);
  }
  return [
    Math.round(r * 255),
    Math.round(g2 * 255),
    Math.round(b * 255),
    a
  ];
}
function toHex(value2) {
  value2 = value2.toString(16);
  return value2.length === 1 ? "0" + value2 : value2;
}
function parseFunctionArgs(functionArgs, count, rgb) {
  let cursor = functionArgs.head;
  let args = [];
  let wasValue = false;
  while (cursor !== null) {
    const { type, value: value2 } = cursor.data;
    switch (type) {
      case "Number":
      case "Percentage":
        if (wasValue) {
          return;
        }
        wasValue = true;
        args.push({
          type,
          value: Number(value2)
        });
        break;
      case "Operator":
        if (value2 === ",") {
          if (!wasValue) {
            return;
          }
          wasValue = false;
        } else if (wasValue || value2 !== "+") {
          return;
        }
        break;
      default:
        return;
    }
    cursor = cursor.next;
  }
  if (args.length !== count) {
    return;
  }
  if (args.length === 4) {
    if (args[3].type !== "Number") {
      return;
    }
    args[3].type = "Alpha";
  }
  if (rgb) {
    if (args[0].type !== args[1].type || args[0].type !== args[2].type) {
      return;
    }
  } else {
    if (args[0].type !== "Number" || args[1].type !== "Percentage" || args[2].type !== "Percentage") {
      return;
    }
    args[0].type = "Angle";
  }
  return args.map(function(arg) {
    let value2 = Math.max(0, arg.value);
    switch (arg.type) {
      case "Number":
        value2 = Math.min(value2, 255);
        break;
      case "Percentage":
        value2 = Math.min(value2, 100) / 100;
        if (!rgb) {
          return value2;
        }
        value2 = 255 * value2;
        break;
      case "Angle":
        return (value2 % 360 + 360) % 360 / 360;
      case "Alpha":
        return Math.min(value2, 1);
    }
    return Math.round(value2);
  });
}
function compressFunction(node2, item) {
  let functionName = node2.name;
  let args;
  if (functionName === "rgba" || functionName === "hsla") {
    args = parseFunctionArgs(node2.children, 4, functionName === "rgba");
    if (!args) {
      return;
    }
    if (functionName === "hsla") {
      args = hslToRgb(...args);
      node2.name = "rgba";
    }
    if (args[3] === 0) {
      const scopeFunctionName = this.function && this.function.name;
      if (args[0] === 0 && args[1] === 0 && args[2] === 0 || !/^(?:to|from|color-stop)$|gradient$/i.test(scopeFunctionName)) {
        item.data = {
          type: "Identifier",
          loc: node2.loc,
          name: "transparent"
        };
        return;
      }
    }
    if (args[3] !== 1) {
      node2.children.forEach((node3, item2, list) => {
        if (node3.type === "Operator") {
          if (node3.value !== ",") {
            list.remove(item2);
          }
          return;
        }
        item2.data = {
          type: "Number",
          loc: node3.loc,
          value: packNumber(args.shift())
        };
      });
      return;
    }
    functionName = "rgb";
  }
  if (functionName === "hsl") {
    args = args || parseFunctionArgs(node2.children, 3, false);
    if (!args) {
      return;
    }
    args = hslToRgb(...args);
    functionName = "rgb";
  }
  if (functionName === "rgb") {
    args = args || parseFunctionArgs(node2.children, 3, true);
    if (!args) {
      return;
    }
    item.data = {
      type: "Hash",
      loc: node2.loc,
      value: toHex(args[0]) + toHex(args[1]) + toHex(args[2])
    };
    compressHex(item.data, item);
  }
}
function compressIdent(node2, item) {
  if (this.declaration === null) {
    return;
  }
  let color = node2.name.toLowerCase();
  if (NAME_TO_HEX.hasOwnProperty(color) && lexer$1.matchDeclaration(this.declaration).isType(node2, "color")) {
    const hex = NAME_TO_HEX[color];
    if (hex.length + 1 <= color.length) {
      item.data = {
        type: "Hash",
        loc: node2.loc,
        value: hex
      };
    } else {
      if (color === "grey") {
        color = "gray";
      }
      node2.name = color;
    }
  }
}
function compressHex(node2, item) {
  let color = node2.value.toLowerCase();
  if (color.length === 6 && color[0] === color[1] && color[2] === color[3] && color[4] === color[5]) {
    color = color[0] + color[2] + color[4];
  }
  if (HEX_TO_NAME[color]) {
    item.data = {
      type: "Identifier",
      loc: node2.loc,
      name: HEX_TO_NAME[color]
    };
  } else {
    node2.value = color;
  }
}
const handlers = {
  Atrule,
  AttributeSelector,
  Value: compressValue,
  Dimension: compressDimension,
  Percentage: compressPercentage,
  Number: Number$1,
  Url,
  Hash: compressHex,
  Identifier: compressIdent,
  Function: compressFunction
};
function replace(ast) {
  walk$1(ast, {
    leave(node2, item, list) {
      if (handlers.hasOwnProperty(node2.type)) {
        handlers[node2.type].call(this, node2, item, list);
      }
    }
  });
}
class Index {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  resolve(str) {
    let index = this.map.get(str);
    if (index === void 0) {
      index = this.map.size + 1;
      this.map.set(str, index);
    }
    return index;
  }
}
function createDeclarationIndexer() {
  const ids = new Index();
  return function markDeclaration(node2) {
    const id = generate$2(node2);
    node2.id = ids.resolve(id);
    node2.length = id.length;
    node2.fingerprint = null;
    return node2;
  };
}
function ensureSelectorList(node2) {
  if (node2.type === "Raw") {
    return parse$2(node2.value, { context: "selectorList" });
  }
  return node2;
}
function maxSpecificity(a, b) {
  for (let i = 0; i < 3; i++) {
    if (a[i] !== b[i]) {
      return a[i] > b[i] ? a : b;
    }
  }
  return a;
}
function maxSelectorListSpecificity(selectorList2) {
  return ensureSelectorList(selectorList2).children.reduce(
    (result, node2) => maxSpecificity(specificity(node2), result),
    [0, 0, 0]
  );
}
function specificity(simpleSelector) {
  let A = 0;
  let B = 0;
  let C = 0;
  simpleSelector.children.forEach((node2) => {
    switch (node2.type) {
      // count the number of ID selectors in the selector (= A)
      case "IdSelector":
        A++;
        break;
      // count the number of class selectors, attributes selectors, ...
      case "ClassSelector":
      case "AttributeSelector":
        B++;
        break;
      // ... and pseudo-classes in the selector (= B)
      case "PseudoClassSelector":
        switch (node2.name.toLowerCase()) {
          // The specificity of an :is(), :not(), or :has() pseudo-class is replaced
          // by the specificity of the most specific complex selector in its selector list argument.
          case "not":
          case "has":
          case "is":
          // :matches() is used before it was renamed to :is()
          // https://github.com/w3c/csswg-drafts/issues/3258
          case "matches":
          // Older browsers support :is() functionality as prefixed pseudo-class :any()
          // https://developer.mozilla.org/en-US/docs/Web/CSS/:is
          case "-webkit-any":
          case "-moz-any": {
            const [a, b, c] = maxSelectorListSpecificity(node2.children.first);
            A += a;
            B += b;
            C += c;
            break;
          }
          // Analogously, the specificity of an :nth-child() or :nth-last-child() selector
          // is the specificity of the pseudo class itself (counting as one pseudo-class selector)
          // plus the specificity of the most specific complex selector in its selector list argument (if any).
          case "nth-child":
          case "nth-last-child": {
            const arg = node2.children.first;
            if (arg.type === "Nth" && arg.selector) {
              const [a, b, c] = maxSelectorListSpecificity(arg.selector);
              A += a;
              B += b + 1;
              C += c;
            } else {
              B++;
            }
            break;
          }
          // The specificity of a :where() pseudo-class is replaced by zero.
          case "where":
            break;
          // The four Level 2 pseudo-elements (::before, ::after, ::first-line, and ::first-letter) may,
          // for legacy reasons, be represented using the <pseudo-class-selector> grammar,
          // with only a single ":" character at their start.
          // https://www.w3.org/TR/selectors-4/#single-colon-pseudos
          case "before":
          case "after":
          case "first-line":
          case "first-letter":
            C++;
            break;
          default:
            B++;
        }
        break;
      // count the number of type selectors ...
      case "TypeSelector":
        if (!node2.name.endsWith("*")) {
          C++;
        }
        break;
      // ... and pseudo-elements in the selector (= C)
      case "PseudoElementSelector":
        C++;
        break;
    }
  });
  return [A, B, C];
}
const nonFreezePseudoElements = /* @__PURE__ */ new Set([
  "first-letter",
  "first-line",
  "after",
  "before"
]);
const nonFreezePseudoClasses = /* @__PURE__ */ new Set([
  "link",
  "visited",
  "hover",
  "active",
  "first-letter",
  "first-line",
  "after",
  "before"
]);
function processSelector(node2, usageData) {
  const pseudos2 = /* @__PURE__ */ new Set();
  node2.prelude.children.forEach(function(simpleSelector) {
    let tagName = "*";
    let scope2 = 0;
    simpleSelector.children.forEach(function(node3) {
      switch (node3.type) {
        case "ClassSelector":
          if (usageData && usageData.scopes) {
            const classScope = usageData.scopes[node3.name] || 0;
            if (scope2 !== 0 && classScope !== scope2) {
              throw new Error("Selector can't has classes from different scopes: " + generate$2(simpleSelector));
            }
            scope2 = classScope;
          }
          break;
        case "PseudoClassSelector": {
          const name2 = node3.name.toLowerCase();
          if (!nonFreezePseudoClasses.has(name2)) {
            pseudos2.add(`:${name2}`);
          }
          break;
        }
        case "PseudoElementSelector": {
          const name2 = node3.name.toLowerCase();
          if (!nonFreezePseudoElements.has(name2)) {
            pseudos2.add(`::${name2}`);
          }
          break;
        }
        case "TypeSelector":
          tagName = node3.name.toLowerCase();
          break;
        case "AttributeSelector":
          if (node3.flags) {
            pseudos2.add(`[${node3.flags.toLowerCase()}]`);
          }
          break;
        case "Combinator":
          tagName = "*";
          break;
      }
    });
    simpleSelector.compareMarker = specificity(simpleSelector).toString();
    simpleSelector.id = null;
    simpleSelector.id = generate$2(simpleSelector);
    if (scope2) {
      simpleSelector.compareMarker += ":" + scope2;
    }
    if (tagName !== "*") {
      simpleSelector.compareMarker += "," + tagName;
    }
  });
  node2.pseudoSignature = pseudos2.size > 0 ? [...pseudos2].sort().join(",") : false;
}
function prepare(ast, options) {
  const markDeclaration = createDeclarationIndexer();
  walk$1(ast, {
    visit: "Rule",
    enter(node2) {
      node2.block.children.forEach(markDeclaration);
      processSelector(node2, options.usage);
    }
  });
  walk$1(ast, {
    visit: "Atrule",
    enter(node2) {
      if (node2.prelude) {
        node2.prelude.id = null;
        node2.prelude.id = generate$2(node2.prelude);
      }
      if (keyword(node2.name).basename === "keyframes") {
        node2.block.avoidRulesMerge = true;
        node2.block.children.forEach(function(rule) {
          rule.prelude.children.forEach(function(simpleselector) {
            simpleselector.compareMarker = simpleselector.id;
          });
        });
      }
    }
  });
  return {
    declaration: markDeclaration
  };
}
const { hasOwnProperty: hasOwnProperty$2 } = Object.prototype;
function addRuleToMap(map, item, list, single) {
  const node2 = item.data;
  const name2 = keyword(node2.name).basename;
  const id = node2.name.toLowerCase() + "/" + (node2.prelude ? node2.prelude.id : null);
  if (!hasOwnProperty$2.call(map, name2)) {
    map[name2] = /* @__PURE__ */ Object.create(null);
  }
  if (single) {
    delete map[name2][id];
  }
  if (!hasOwnProperty$2.call(map[name2], id)) {
    map[name2][id] = new List2();
  }
  map[name2][id].append(list.remove(item));
}
function relocateAtrules(ast, options) {
  const collected = /* @__PURE__ */ Object.create(null);
  let topInjectPoint = null;
  ast.children.forEach(function(node2, item, list) {
    if (node2.type === "Atrule") {
      const name2 = keyword(node2.name).basename;
      switch (name2) {
        case "keyframes":
          addRuleToMap(collected, item, list, true);
          return;
        case "media":
          if (options.forceMediaMerge) {
            addRuleToMap(collected, item, list, false);
            return;
          }
          break;
      }
      if (topInjectPoint === null && name2 !== "charset" && name2 !== "import") {
        topInjectPoint = item;
      }
    } else {
      if (topInjectPoint === null) {
        topInjectPoint = item;
      }
    }
  });
  for (const atrule2 in collected) {
    for (const id in collected[atrule2]) {
      ast.children.insertList(
        collected[atrule2][id],
        atrule2 === "media" ? null : topInjectPoint
      );
    }
  }
}
function isMediaRule(node2) {
  return node2.type === "Atrule" && node2.name === "media";
}
function processAtrule(node2, item, list) {
  if (!isMediaRule(node2)) {
    return;
  }
  const prev = item.prev && item.prev.data;
  if (!prev || !isMediaRule(prev)) {
    return;
  }
  if (node2.prelude && prev.prelude && node2.prelude.id === prev.prelude.id) {
    prev.block.children.appendList(node2.block.children);
    list.remove(item);
  }
}
function rejoinAtrule(ast, options) {
  relocateAtrules(ast, options);
  walk$1(ast, {
    visit: "Atrule",
    reverse: true,
    enter: processAtrule
  });
}
const { hasOwnProperty: hasOwnProperty$1 } = Object.prototype;
function isEqualSelectors(a, b) {
  let cursor1 = a.head;
  let cursor2 = b.head;
  while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
    cursor1 = cursor1.next;
    cursor2 = cursor2.next;
  }
  return cursor1 === null && cursor2 === null;
}
function isEqualDeclarations(a, b) {
  let cursor1 = a.head;
  let cursor2 = b.head;
  while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
    cursor1 = cursor1.next;
    cursor2 = cursor2.next;
  }
  return cursor1 === null && cursor2 === null;
}
function compareDeclarations(declarations1, declarations2) {
  const result = {
    eq: [],
    ne1: [],
    ne2: [],
    ne2overrided: []
  };
  const fingerprints = /* @__PURE__ */ Object.create(null);
  const declarations2hash = /* @__PURE__ */ Object.create(null);
  for (let cursor = declarations2.head; cursor; cursor = cursor.next) {
    declarations2hash[cursor.data.id] = true;
  }
  for (let cursor = declarations1.head; cursor; cursor = cursor.next) {
    const data = cursor.data;
    if (data.fingerprint) {
      fingerprints[data.fingerprint] = data.important;
    }
    if (declarations2hash[data.id]) {
      declarations2hash[data.id] = false;
      result.eq.push(data);
    } else {
      result.ne1.push(data);
    }
  }
  for (let cursor = declarations2.head; cursor; cursor = cursor.next) {
    const data = cursor.data;
    if (declarations2hash[data.id]) {
      if (!hasOwnProperty$1.call(fingerprints, data.fingerprint) || !fingerprints[data.fingerprint] && data.important) {
        result.ne2.push(data);
      }
      result.ne2overrided.push(data);
    }
  }
  return result;
}
function addSelectors(dest, source) {
  source.forEach((sourceData) => {
    const newStr = sourceData.id;
    let cursor = dest.head;
    while (cursor) {
      const nextStr = cursor.data.id;
      if (nextStr === newStr) {
        return;
      }
      if (nextStr > newStr) {
        break;
      }
      cursor = cursor.next;
    }
    dest.insert(dest.createItem(sourceData), cursor);
  });
  return dest;
}
function hasSimilarSelectors(selectors1, selectors2) {
  let cursor1 = selectors1.head;
  while (cursor1 !== null) {
    let cursor2 = selectors2.head;
    while (cursor2 !== null) {
      if (cursor1.data.compareMarker === cursor2.data.compareMarker) {
        return true;
      }
      cursor2 = cursor2.next;
    }
    cursor1 = cursor1.next;
  }
  return false;
}
function unsafeToSkipNode(node2) {
  switch (node2.type) {
    case "Rule":
      return hasSimilarSelectors(node2.prelude.children, this);
    case "Atrule":
      if (node2.block) {
        return node2.block.children.some(unsafeToSkipNode, this);
      }
      break;
    case "Declaration":
      return false;
  }
  return true;
}
function processRule$5(node2, item, list) {
  const selectors = node2.prelude.children;
  const declarations = node2.block.children;
  list.prevUntil(item.prev, function(prev) {
    if (prev.type !== "Rule") {
      return unsafeToSkipNode.call(selectors, prev);
    }
    const prevSelectors = prev.prelude.children;
    const prevDeclarations = prev.block.children;
    if (node2.pseudoSignature === prev.pseudoSignature) {
      if (isEqualSelectors(prevSelectors, selectors)) {
        prevDeclarations.appendList(declarations);
        list.remove(item);
        return true;
      }
      if (isEqualDeclarations(declarations, prevDeclarations)) {
        addSelectors(prevSelectors, selectors);
        list.remove(item);
        return true;
      }
    }
    return hasSimilarSelectors(selectors, prevSelectors);
  });
}
function initialMergeRule(ast) {
  walk$1(ast, {
    visit: "Rule",
    enter: processRule$5
  });
}
function processRule$4(node2, item, list) {
  const selectors = node2.prelude.children;
  while (selectors.head !== selectors.tail) {
    const newSelectors = new List2();
    newSelectors.insert(selectors.remove(selectors.head));
    list.insert(list.createItem({
      type: "Rule",
      loc: node2.loc,
      prelude: {
        type: "SelectorList",
        loc: node2.prelude.loc,
        children: newSelectors
      },
      block: {
        type: "Block",
        loc: node2.block.loc,
        children: node2.block.children.copy()
      },
      pseudoSignature: node2.pseudoSignature
    }), item);
  }
}
function disjoinRule(ast) {
  walk$1(ast, {
    visit: "Rule",
    reverse: true,
    enter: processRule$4
  });
}
const REPLACE = 1;
const REMOVE = 2;
const TOP = 0;
const RIGHT = 1;
const BOTTOM = 2;
const LEFT = 3;
const SIDES = ["top", "right", "bottom", "left"];
const SIDE = {
  "margin-top": "top",
  "margin-right": "right",
  "margin-bottom": "bottom",
  "margin-left": "left",
  "padding-top": "top",
  "padding-right": "right",
  "padding-bottom": "bottom",
  "padding-left": "left",
  "border-top-color": "top",
  "border-right-color": "right",
  "border-bottom-color": "bottom",
  "border-left-color": "left",
  "border-top-width": "top",
  "border-right-width": "right",
  "border-bottom-width": "bottom",
  "border-left-width": "left",
  "border-top-style": "top",
  "border-right-style": "right",
  "border-bottom-style": "bottom",
  "border-left-style": "left"
};
const MAIN_PROPERTY = {
  "margin": "margin",
  "margin-top": "margin",
  "margin-right": "margin",
  "margin-bottom": "margin",
  "margin-left": "margin",
  "padding": "padding",
  "padding-top": "padding",
  "padding-right": "padding",
  "padding-bottom": "padding",
  "padding-left": "padding",
  "border-color": "border-color",
  "border-top-color": "border-color",
  "border-right-color": "border-color",
  "border-bottom-color": "border-color",
  "border-left-color": "border-color",
  "border-width": "border-width",
  "border-top-width": "border-width",
  "border-right-width": "border-width",
  "border-bottom-width": "border-width",
  "border-left-width": "border-width",
  "border-style": "border-style",
  "border-top-style": "border-style",
  "border-right-style": "border-style",
  "border-bottom-style": "border-style",
  "border-left-style": "border-style"
};
class TRBL {
  constructor(name2) {
    this.name = name2;
    this.loc = null;
    this.iehack = void 0;
    this.sides = {
      "top": null,
      "right": null,
      "bottom": null,
      "left": null
    };
  }
  getValueSequence(declaration, count) {
    const values = [];
    let iehack = "";
    const hasBadValues = declaration.value.type !== "Value" || declaration.value.children.some(function(child) {
      let special = false;
      switch (child.type) {
        case "Identifier":
          switch (child.name) {
            case "\\0":
            case "\\9":
              iehack = child.name;
              return;
            case "inherit":
            case "initial":
            case "unset":
            case "revert":
              special = child.name;
              break;
          }
          break;
        case "Dimension":
          switch (child.unit) {
            // is not supported until IE11
            case "rem":
            // v* units is too buggy across browsers and better
            // don't merge values with those units
            case "vw":
            case "vh":
            case "vmin":
            case "vmax":
            case "vm":
              special = child.unit;
              break;
          }
          break;
        case "Hash":
        // color
        case "Number":
        case "Percentage":
          break;
        case "Function":
          if (child.name === "var") {
            return true;
          }
          special = child.name;
          break;
        default:
          return true;
      }
      values.push({
        node: child,
        special,
        important: declaration.important
      });
    });
    if (hasBadValues || values.length > count) {
      return false;
    }
    if (typeof this.iehack === "string" && this.iehack !== iehack) {
      return false;
    }
    this.iehack = iehack;
    return values;
  }
  canOverride(side, value2) {
    const currentValue = this.sides[side];
    return !currentValue || value2.important && !currentValue.important;
  }
  add(name2, declaration) {
    function attemptToAdd() {
      const sides = this.sides;
      const side = SIDE[name2];
      if (side) {
        if (side in sides === false) {
          return false;
        }
        const values = this.getValueSequence(declaration, 1);
        if (!values || !values.length) {
          return false;
        }
        for (const key in sides) {
          if (sides[key] !== null && sides[key].special !== values[0].special) {
            return false;
          }
        }
        if (!this.canOverride(side, values[0])) {
          return true;
        }
        sides[side] = values[0];
        return true;
      } else if (name2 === this.name) {
        const values = this.getValueSequence(declaration, 4);
        if (!values || !values.length) {
          return false;
        }
        switch (values.length) {
          case 1:
            values[RIGHT] = values[TOP];
            values[BOTTOM] = values[TOP];
            values[LEFT] = values[TOP];
            break;
          case 2:
            values[BOTTOM] = values[TOP];
            values[LEFT] = values[RIGHT];
            break;
          case 3:
            values[LEFT] = values[RIGHT];
            break;
        }
        for (let i = 0; i < 4; i++) {
          for (const key in sides) {
            if (sides[key] !== null && sides[key].special !== values[i].special) {
              return false;
            }
          }
        }
        for (let i = 0; i < 4; i++) {
          if (this.canOverride(SIDES[i], values[i])) {
            sides[SIDES[i]] = values[i];
          }
        }
        return true;
      }
    }
    if (!attemptToAdd.call(this)) {
      return false;
    }
    if (!this.loc) {
      this.loc = declaration.loc;
    }
    return true;
  }
  isOkToMinimize() {
    const top = this.sides.top;
    const right = this.sides.right;
    const bottom = this.sides.bottom;
    const left = this.sides.left;
    if (top && right && bottom && left) {
      const important = top.important + right.important + bottom.important + left.important;
      return important === 0 || important === 4;
    }
    return false;
  }
  getValue() {
    const result = new List2();
    const sides = this.sides;
    const values = [
      sides.top,
      sides.right,
      sides.bottom,
      sides.left
    ];
    const stringValues = [
      generate$2(sides.top.node),
      generate$2(sides.right.node),
      generate$2(sides.bottom.node),
      generate$2(sides.left.node)
    ];
    if (stringValues[LEFT] === stringValues[RIGHT]) {
      values.pop();
      if (stringValues[BOTTOM] === stringValues[TOP]) {
        values.pop();
        if (stringValues[RIGHT] === stringValues[TOP]) {
          values.pop();
        }
      }
    }
    for (let i = 0; i < values.length; i++) {
      result.appendData(values[i].node);
    }
    if (this.iehack) {
      result.appendData({
        type: "Identifier",
        loc: null,
        name: this.iehack
      });
    }
    return {
      type: "Value",
      loc: null,
      children: result
    };
  }
  getDeclaration() {
    return {
      type: "Declaration",
      loc: this.loc,
      important: this.sides.top.important,
      property: this.name,
      value: this.getValue()
    };
  }
}
function processRule$3(rule, shorts, shortDeclarations, lastShortSelector) {
  const declarations = rule.block.children;
  const selector2 = rule.prelude.children.first.id;
  rule.block.children.forEachRight(function(declaration, item) {
    const property2 = declaration.property;
    if (!MAIN_PROPERTY.hasOwnProperty(property2)) {
      return;
    }
    const key = MAIN_PROPERTY[property2];
    let shorthand;
    let operation;
    if (!lastShortSelector || selector2 === lastShortSelector) {
      if (key in shorts) {
        operation = REMOVE;
        shorthand = shorts[key];
      }
    }
    if (!shorthand || !shorthand.add(property2, declaration)) {
      operation = REPLACE;
      shorthand = new TRBL(key);
      if (!shorthand.add(property2, declaration)) {
        lastShortSelector = null;
        return;
      }
    }
    shorts[key] = shorthand;
    shortDeclarations.push({
      operation,
      block: declarations,
      item,
      shorthand
    });
    lastShortSelector = selector2;
  });
  return lastShortSelector;
}
function processShorthands(shortDeclarations, markDeclaration) {
  shortDeclarations.forEach(function(item) {
    const shorthand = item.shorthand;
    if (!shorthand.isOkToMinimize()) {
      return;
    }
    if (item.operation === REPLACE) {
      item.item.data = markDeclaration(shorthand.getDeclaration());
    } else {
      item.block.remove(item.item);
    }
  });
}
function restructBlock$1(ast, indexer) {
  const stylesheetMap = {};
  const shortDeclarations = [];
  walk$1(ast, {
    visit: "Rule",
    reverse: true,
    enter(node2) {
      const stylesheet = this.block || this.stylesheet;
      const ruleId = (node2.pseudoSignature || "") + "|" + node2.prelude.children.first.id;
      let ruleMap;
      let shorts;
      if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
        ruleMap = {
          lastShortSelector: null
        };
        stylesheetMap[stylesheet.id] = ruleMap;
      } else {
        ruleMap = stylesheetMap[stylesheet.id];
      }
      if (ruleMap.hasOwnProperty(ruleId)) {
        shorts = ruleMap[ruleId];
      } else {
        shorts = {};
        ruleMap[ruleId] = shorts;
      }
      ruleMap.lastShortSelector = processRule$3.call(this, node2, shorts, shortDeclarations, ruleMap.lastShortSelector);
    }
  });
  processShorthands(shortDeclarations, indexer.declaration);
}
let fingerprintId = 1;
const dontRestructure = /* @__PURE__ */ new Set([
  "src"
  // https://github.com/afelix/csso/issues/50
]);
const DONT_MIX_VALUE = {
  // https://developer.mozilla.org/en-US/docs/Web/CSS/display#Browser_compatibility
  "display": /table|ruby|flex|-(flex)?box$|grid|contents|run-in/i,
  // https://developer.mozilla.org/en/docs/Web/CSS/text-align
  "text-align": /^(start|end|match-parent|justify-all)$/i
};
const SAFE_VALUES = {
  cursor: [
    "auto",
    "crosshair",
    "default",
    "move",
    "text",
    "wait",
    "help",
    "n-resize",
    "e-resize",
    "s-resize",
    "w-resize",
    "ne-resize",
    "nw-resize",
    "se-resize",
    "sw-resize",
    "pointer",
    "progress",
    "not-allowed",
    "no-drop",
    "vertical-text",
    "all-scroll",
    "col-resize",
    "row-resize"
  ],
  overflow: [
    "hidden",
    "visible",
    "scroll",
    "auto"
  ],
  position: [
    "static",
    "relative",
    "absolute",
    "fixed"
  ]
};
const NEEDLESS_TABLE = {
  "border-width": ["border"],
  "border-style": ["border"],
  "border-color": ["border"],
  "border-top": ["border"],
  "border-right": ["border"],
  "border-bottom": ["border"],
  "border-left": ["border"],
  "border-top-width": ["border-top", "border-width", "border"],
  "border-right-width": ["border-right", "border-width", "border"],
  "border-bottom-width": ["border-bottom", "border-width", "border"],
  "border-left-width": ["border-left", "border-width", "border"],
  "border-top-style": ["border-top", "border-style", "border"],
  "border-right-style": ["border-right", "border-style", "border"],
  "border-bottom-style": ["border-bottom", "border-style", "border"],
  "border-left-style": ["border-left", "border-style", "border"],
  "border-top-color": ["border-top", "border-color", "border"],
  "border-right-color": ["border-right", "border-color", "border"],
  "border-bottom-color": ["border-bottom", "border-color", "border"],
  "border-left-color": ["border-left", "border-color", "border"],
  "margin-top": ["margin"],
  "margin-right": ["margin"],
  "margin-bottom": ["margin"],
  "margin-left": ["margin"],
  "padding-top": ["padding"],
  "padding-right": ["padding"],
  "padding-bottom": ["padding"],
  "padding-left": ["padding"],
  "font-style": ["font"],
  "font-variant": ["font"],
  "font-weight": ["font"],
  "font-size": ["font"],
  "font-family": ["font"],
  "list-style-type": ["list-style"],
  "list-style-position": ["list-style"],
  "list-style-image": ["list-style"]
};
function getPropertyFingerprint(propertyName, declaration, fingerprints) {
  const realName = property(propertyName).basename;
  if (realName === "background") {
    return propertyName + ":" + generate$2(declaration.value);
  }
  const declarationId = declaration.id;
  let fingerprint = fingerprints[declarationId];
  if (!fingerprint) {
    switch (declaration.value.type) {
      case "Value":
        const special = {};
        let vendorId = "";
        let iehack = "";
        let raw = false;
        declaration.value.children.forEach(function walk2(node2) {
          switch (node2.type) {
            case "Value":
            case "Brackets":
            case "Parentheses":
              node2.children.forEach(walk2);
              break;
            case "Raw":
              raw = true;
              break;
            case "Identifier": {
              const { name: name2 } = node2;
              if (!vendorId) {
                vendorId = keyword(name2).vendor;
              }
              if (/\\[09]/.test(name2)) {
                iehack = RegExp.lastMatch;
              }
              if (SAFE_VALUES.hasOwnProperty(realName)) {
                if (SAFE_VALUES[realName].indexOf(name2) === -1) {
                  special[name2] = true;
                }
              } else if (DONT_MIX_VALUE.hasOwnProperty(realName)) {
                if (DONT_MIX_VALUE[realName].test(name2)) {
                  special[name2] = true;
                }
              }
              break;
            }
            case "Function": {
              let { name: name2 } = node2;
              if (!vendorId) {
                vendorId = keyword(name2).vendor;
              }
              if (name2 === "rect") {
                const hasComma = node2.children.some(
                  (node3) => node3.type === "Operator" && node3.value === ","
                );
                if (!hasComma) {
                  name2 = "rect-backward";
                }
              }
              special[name2 + "()"] = true;
              node2.children.forEach(walk2);
              break;
            }
            case "Dimension": {
              const { unit } = node2;
              if (/\\[09]/.test(unit)) {
                iehack = RegExp.lastMatch;
              }
              switch (unit) {
                // is not supported until IE11
                case "rem":
                // v* units is too buggy across browsers and better
                // don't merge values with those units
                case "vw":
                case "vh":
                case "vmin":
                case "vmax":
                case "vm":
                  special[unit] = true;
                  break;
              }
              break;
            }
          }
        });
        fingerprint = raw ? "!" + fingerprintId++ : "!" + Object.keys(special).sort() + "|" + iehack + vendorId;
        break;
      case "Raw":
        fingerprint = "!" + declaration.value.value;
        break;
      default:
        fingerprint = generate$2(declaration.value);
    }
    fingerprints[declarationId] = fingerprint;
  }
  return propertyName + fingerprint;
}
function needless(props, declaration, fingerprints) {
  const property$12 = property(declaration.property);
  if (NEEDLESS_TABLE.hasOwnProperty(property$12.basename)) {
    const table = NEEDLESS_TABLE[property$12.basename];
    for (const entry of table) {
      const ppre = getPropertyFingerprint(property$12.prefix + entry, declaration, fingerprints);
      const prev = props.hasOwnProperty(ppre) ? props[ppre] : null;
      if (prev && (!declaration.important || prev.item.data.important)) {
        return prev;
      }
    }
  }
}
function processRule$2(rule, item, list, props, fingerprints) {
  const declarations = rule.block.children;
  declarations.forEachRight(function(declaration, declarationItem) {
    const { property: property2 } = declaration;
    const fingerprint = getPropertyFingerprint(property2, declaration, fingerprints);
    const prev = props[fingerprint];
    if (prev && !dontRestructure.has(property2)) {
      if (declaration.important && !prev.item.data.important) {
        props[fingerprint] = {
          block: declarations,
          item: declarationItem
        };
        prev.block.remove(prev.item);
      } else {
        declarations.remove(declarationItem);
      }
    } else {
      const prev2 = needless(props, declaration, fingerprints);
      if (prev2) {
        declarations.remove(declarationItem);
      } else {
        declaration.fingerprint = fingerprint;
        props[fingerprint] = {
          block: declarations,
          item: declarationItem
        };
      }
    }
  });
  if (declarations.isEmpty) {
    list.remove(item);
  }
}
function restructBlock(ast) {
  const stylesheetMap = {};
  const fingerprints = /* @__PURE__ */ Object.create(null);
  walk$1(ast, {
    visit: "Rule",
    reverse: true,
    enter(node2, item, list) {
      const stylesheet = this.block || this.stylesheet;
      const ruleId = (node2.pseudoSignature || "") + "|" + node2.prelude.children.first.id;
      let ruleMap;
      let props;
      if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
        ruleMap = {};
        stylesheetMap[stylesheet.id] = ruleMap;
      } else {
        ruleMap = stylesheetMap[stylesheet.id];
      }
      if (ruleMap.hasOwnProperty(ruleId)) {
        props = ruleMap[ruleId];
      } else {
        props = {};
        ruleMap[ruleId] = props;
      }
      processRule$2.call(this, node2, item, list, props, fingerprints);
    }
  });
}
function processRule$1(node2, item, list) {
  const selectors = node2.prelude.children;
  const declarations = node2.block.children;
  const nodeCompareMarker = selectors.first.compareMarker;
  const skippedCompareMarkers = {};
  list.nextUntil(item.next, function(next, nextItem) {
    if (next.type !== "Rule") {
      return unsafeToSkipNode.call(selectors, next);
    }
    if (node2.pseudoSignature !== next.pseudoSignature) {
      return true;
    }
    const nextFirstSelector = next.prelude.children.head;
    const nextDeclarations = next.block.children;
    const nextCompareMarker = nextFirstSelector.data.compareMarker;
    if (nextCompareMarker in skippedCompareMarkers) {
      return true;
    }
    if (selectors.head === selectors.tail) {
      if (selectors.first.id === nextFirstSelector.data.id) {
        declarations.appendList(nextDeclarations);
        list.remove(nextItem);
        return;
      }
    }
    if (isEqualDeclarations(declarations, nextDeclarations)) {
      const nextStr = nextFirstSelector.data.id;
      selectors.some((data, item2) => {
        const curStr = data.id;
        if (nextStr < curStr) {
          selectors.insert(nextFirstSelector, item2);
          return true;
        }
        if (!item2.next) {
          selectors.insert(nextFirstSelector);
          return true;
        }
      });
      list.remove(nextItem);
      return;
    }
    if (nextCompareMarker === nodeCompareMarker) {
      return true;
    }
    skippedCompareMarkers[nextCompareMarker] = true;
  });
}
function mergeRule(ast) {
  walk$1(ast, {
    visit: "Rule",
    enter: processRule$1
  });
}
function calcSelectorLength(list) {
  return list.reduce((res, data) => res + data.id.length + 1, 0) - 1;
}
function calcDeclarationsLength(tokens) {
  let length2 = 0;
  for (const token of tokens) {
    length2 += token.length;
  }
  return length2 + // declarations
  tokens.length - 1;
}
function processRule(node2, item, list) {
  const avoidRulesMerge = this.block !== null ? this.block.avoidRulesMerge : false;
  const selectors = node2.prelude.children;
  const block = node2.block;
  const disallowDownMarkers = /* @__PURE__ */ Object.create(null);
  let allowMergeUp = true;
  let allowMergeDown = true;
  list.prevUntil(item.prev, function(prev, prevItem) {
    const prevBlock = prev.block;
    const prevType = prev.type;
    if (prevType !== "Rule") {
      const unsafe = unsafeToSkipNode.call(selectors, prev);
      if (!unsafe && prevType === "Atrule" && prevBlock) {
        walk$1(prevBlock, {
          visit: "Rule",
          enter(node3) {
            node3.prelude.children.forEach((data) => {
              disallowDownMarkers[data.compareMarker] = true;
            });
          }
        });
      }
      return unsafe;
    }
    if (node2.pseudoSignature !== prev.pseudoSignature) {
      return true;
    }
    const prevSelectors = prev.prelude.children;
    allowMergeDown = !prevSelectors.some(
      (selector2) => selector2.compareMarker in disallowDownMarkers
    );
    if (!allowMergeDown && !allowMergeUp) {
      return true;
    }
    if (allowMergeUp && isEqualSelectors(prevSelectors, selectors)) {
      prevBlock.children.appendList(block.children);
      list.remove(item);
      return true;
    }
    const diff = compareDeclarations(block.children, prevBlock.children);
    if (diff.eq.length) {
      if (!diff.ne1.length && !diff.ne2.length) {
        if (allowMergeDown) {
          addSelectors(selectors, prevSelectors);
          list.remove(prevItem);
        }
        return true;
      } else if (!avoidRulesMerge) {
        if (diff.ne1.length && !diff.ne2.length) {
          const selectorLength = calcSelectorLength(selectors);
          const blockLength = calcDeclarationsLength(diff.eq);
          if (allowMergeUp && selectorLength < blockLength) {
            addSelectors(prevSelectors, selectors);
            block.children.fromArray(diff.ne1);
          }
        } else if (!diff.ne1.length && diff.ne2.length) {
          const selectorLength = calcSelectorLength(prevSelectors);
          const blockLength = calcDeclarationsLength(diff.eq);
          if (allowMergeDown && selectorLength < blockLength) {
            addSelectors(selectors, prevSelectors);
            prevBlock.children.fromArray(diff.ne2);
          }
        } else {
          const newSelector = {
            type: "SelectorList",
            loc: null,
            children: addSelectors(prevSelectors.copy(), selectors)
          };
          const newBlockLength = calcSelectorLength(newSelector.children) + 2;
          const blockLength = calcDeclarationsLength(diff.eq);
          if (blockLength >= newBlockLength) {
            const newItem = list.createItem({
              type: "Rule",
              loc: null,
              prelude: newSelector,
              block: {
                type: "Block",
                loc: null,
                children: new List2().fromArray(diff.eq)
              },
              pseudoSignature: node2.pseudoSignature
            });
            block.children.fromArray(diff.ne1);
            prevBlock.children.fromArray(diff.ne2overrided);
            if (allowMergeUp) {
              list.insert(newItem, prevItem);
            } else {
              list.insert(newItem, item);
            }
            return true;
          }
        }
      }
    }
    if (allowMergeUp) {
      allowMergeUp = !prevSelectors.some(
        (prevSelector) => selectors.some(
          (selector2) => selector2.compareMarker === prevSelector.compareMarker
        )
      );
    }
    prevSelectors.forEach((data) => {
      disallowDownMarkers[data.compareMarker] = true;
    });
  });
}
function restructRule(ast) {
  walk$1(ast, {
    visit: "Rule",
    reverse: true,
    enter: processRule
  });
}
function restructure(ast, options) {
  const indexer = prepare(ast, options);
  options.logger("prepare", ast);
  rejoinAtrule(ast, options);
  options.logger("mergeAtrule", ast);
  initialMergeRule(ast);
  options.logger("initialMergeRuleset", ast);
  disjoinRule(ast);
  options.logger("disjoinRuleset", ast);
  restructBlock$1(ast, indexer);
  options.logger("restructShorthand", ast);
  restructBlock(ast);
  options.logger("restructBlock", ast);
  mergeRule(ast);
  options.logger("mergeRuleset", ast);
  restructRule(ast);
  options.logger("restructRuleset", ast);
}
function readChunk(input, specialComments) {
  const children = new List2();
  let nonSpaceTokenInBuffer = false;
  let protectedComment;
  input.nextUntil(input.head, (node2, item, list) => {
    if (node2.type === "Comment") {
      if (!specialComments || node2.value.charAt(0) !== "!") {
        list.remove(item);
        return;
      }
      if (nonSpaceTokenInBuffer || protectedComment) {
        return true;
      }
      list.remove(item);
      protectedComment = node2;
      return;
    }
    if (node2.type !== "WhiteSpace") {
      nonSpaceTokenInBuffer = true;
    }
    children.insert(list.remove(item));
  });
  return {
    comment: protectedComment,
    stylesheet: {
      type: "StyleSheet",
      loc: null,
      children
    }
  };
}
function compressChunk(ast, firstAtrulesAllowed, num, options) {
  options.logger(`Compress block #${num}`, null, true);
  let seed = 1;
  if (ast.type === "StyleSheet") {
    ast.firstAtrulesAllowed = firstAtrulesAllowed;
    ast.id = seed++;
  }
  walk$1(ast, {
    visit: "Atrule",
    enter(node2) {
      if (node2.block !== null) {
        node2.block.id = seed++;
      }
    }
  });
  options.logger("init", ast);
  clean(ast, options);
  options.logger("clean", ast);
  replace(ast);
  options.logger("replace", ast);
  if (options.restructuring) {
    restructure(ast, options);
  }
  return ast;
}
function getCommentsOption(options) {
  let comments = "comments" in options ? options.comments : "exclamation";
  if (typeof comments === "boolean") {
    comments = comments ? "exclamation" : false;
  } else if (comments !== "exclamation" && comments !== "first-exclamation") {
    comments = false;
  }
  return comments;
}
function getRestructureOption(options) {
  if ("restructure" in options) {
    return options.restructure;
  }
  return "restructuring" in options ? options.restructuring : true;
}
function wrapBlock(block) {
  return new List2().appendData({
    type: "Rule",
    loc: null,
    prelude: {
      type: "SelectorList",
      loc: null,
      children: new List2().appendData({
        type: "Selector",
        loc: null,
        children: new List2().appendData({
          type: "TypeSelector",
          loc: null,
          name: "x"
        })
      })
    },
    block
  });
}
function compress$1(ast, options) {
  ast = ast || { type: "StyleSheet", loc: null, children: new List2() };
  options = options || {};
  const compressOptions = {
    logger: typeof options.logger === "function" ? options.logger : function() {
    },
    restructuring: getRestructureOption(options),
    forceMediaMerge: Boolean(options.forceMediaMerge),
    usage: options.usage ? buildIndex(options.usage) : false
  };
  const output = new List2();
  let specialComments = getCommentsOption(options);
  let firstAtrulesAllowed = true;
  let input;
  let chunk;
  let chunkNum = 1;
  let chunkChildren;
  if (options.clone) {
    ast = clone(ast);
  }
  if (ast.type === "StyleSheet") {
    input = ast.children;
    ast.children = output;
  } else {
    input = wrapBlock(ast);
  }
  do {
    chunk = readChunk(input, Boolean(specialComments));
    compressChunk(chunk.stylesheet, firstAtrulesAllowed, chunkNum++, compressOptions);
    chunkChildren = chunk.stylesheet.children;
    if (chunk.comment) {
      if (!output.isEmpty) {
        output.insert(List2.createItem({
          type: "Raw",
          value: "\n"
        }));
      }
      output.insert(List2.createItem(chunk.comment));
      if (!chunkChildren.isEmpty) {
        output.insert(List2.createItem({
          type: "Raw",
          value: "\n"
        }));
      }
    }
    if (firstAtrulesAllowed && !chunkChildren.isEmpty) {
      const lastRule = chunkChildren.last;
      if (lastRule.type !== "Atrule" || lastRule.name !== "import" && lastRule.name !== "charset") {
        firstAtrulesAllowed = false;
      }
    }
    if (specialComments !== "exclamation") {
      specialComments = false;
    }
    output.appendList(chunkChildren);
  } while (!input.isEmpty);
  return {
    ast
  };
}
function encodeString(value2) {
  const stringApostrophe = encode$1(value2, true);
  const stringQuote = encode$1(value2);
  return stringApostrophe.length < stringQuote.length ? stringApostrophe : stringQuote;
}
const {
  lexer,
  tokenize,
  parse: parse$1,
  generate: generate$1,
  walk,
  find,
  findLast,
  findAll,
  fromPlainObject,
  toPlainObject
} = fork({
  node: {
    String: {
      generate(node2) {
        this.token(String$2, encodeString(node2.value));
      }
    },
    Url: {
      generate(node2) {
        const encodedUrl = encode(node2.value);
        const string = encodeString(node2.value);
        this.token(
          Url$2,
          encodedUrl.length <= string.length + 5 ? encodedUrl : "url(" + string + ")"
        );
      }
    }
  }
});
const syntax = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  compress: compress$1,
  find,
  findAll,
  findLast,
  fromPlainObject,
  generate: generate$1,
  lexer,
  parse: parse$1,
  specificity,
  toPlainObject,
  tokenize,
  walk
}, Symbol.toStringTag, { value: "Module" }));
const { parse, generate, compress } = syntax;
function debugOutput(name2, options, startTime, data) {
  if (options.debug) {
    console.error(`## ${name2} done in %d ms
`, Date.now() - startTime);
  }
  return data;
}
function createDefaultLogger(level) {
  let lastDebug;
  return function logger(title, ast) {
    let line = title;
    if (ast) {
      line = `[${((Date.now() - lastDebug) / 1e3).toFixed(3)}s] ${line}`;
    }
    if (level > 1 && ast) {
      let css = generate(ast);
      if (level === 2 && css.length > 256) {
        css = css.substr(0, 256) + "...";
      }
      line += `
  ${css}
`;
    }
    console.error(line);
    lastDebug = Date.now();
  };
}
function buildCompressOptions(options) {
  options = { ...options };
  if (typeof options.logger !== "function" && options.debug) {
    options.logger = createDefaultLogger(options.debug);
  }
  return options;
}
function runHandler(ast, options, handlers2) {
  if (!Array.isArray(handlers2)) {
    handlers2 = [handlers2];
  }
  handlers2.forEach((fn2) => fn2(ast, options));
}
function minify(context, source, options) {
  options = options || {};
  const filename = options.filename || "<unknown>";
  let result;
  const ast = debugOutput(
    "parsing",
    options,
    Date.now(),
    parse(source, {
      context,
      filename,
      positions: Boolean(options.sourceMap)
    })
  );
  if (options.beforeCompress) {
    debugOutput(
      "beforeCompress",
      options,
      Date.now(),
      runHandler(ast, options, options.beforeCompress)
    );
  }
  const compressResult = debugOutput(
    "compress",
    options,
    Date.now(),
    compress(ast, buildCompressOptions(options))
  );
  if (options.afterCompress) {
    debugOutput(
      "afterCompress",
      options,
      Date.now(),
      runHandler(compressResult, options, options.afterCompress)
    );
  }
  if (options.sourceMap) {
    result = debugOutput("generate(sourceMap: true)", options, Date.now(), (() => {
      const tmp = generate(compressResult.ast, { sourceMap: true });
      tmp.map._file = filename;
      tmp.map.setSourceContent(filename, source);
      return tmp;
    })());
  } else {
    result = debugOutput("generate", options, Date.now(), {
      css: generate(compressResult.ast),
      map: null
    });
  }
  return result;
}
function minifyStylesheet(source, options) {
  return minify("stylesheet", source, options);
}
function minifyBlock(source, options) {
  return minify("declarationList", source, options);
}
const csstreeWalkSkip = walk$3.skip;
const parseRule = (ruleNode, dynamic) => {
  const declarations = [];
  ruleNode.block.children.forEach((cssNode) => {
    if (cssNode.type === "Declaration") {
      declarations.push({
        name: cssNode.property,
        value: generate$I(cssNode.value),
        important: cssNode.important === true
      });
    }
  });
  const rules = [];
  walk$3(ruleNode.prelude, (node2) => {
    if (node2.type === "Selector") {
      const newNode = clone$1(node2);
      let hasPseudoClasses = false;
      walk$3(newNode, (pseudoClassNode, item, list) => {
        if (pseudoClassNode.type === "PseudoClassSelector") {
          hasPseudoClasses = true;
          list.remove(item);
        }
      });
      rules.push({
        specificity: specificity(node2),
        dynamic: hasPseudoClasses || dynamic,
        // compute specificity from original node to consider pseudo classes
        selector: generate$I(newNode),
        declarations
      });
    }
  });
  return rules;
};
const parseStylesheet = (css, dynamic) => {
  const rules = [];
  const ast = parse$I(css, {
    parseValue: false,
    parseAtrulePrelude: false
  });
  walk$3(ast, (cssNode) => {
    if (cssNode.type === "Rule") {
      rules.push(...parseRule(cssNode, dynamic || false));
      return csstreeWalkSkip;
    }
    if (cssNode.type === "Atrule") {
      if ([
        "keyframes",
        "-webkit-keyframes",
        "-o-keyframes",
        "-moz-keyframes"
      ].includes(cssNode.name)) {
        return csstreeWalkSkip;
      }
      walk$3(cssNode, (ruleNode) => {
        if (ruleNode.type === "Rule") {
          rules.push(...parseRule(ruleNode, dynamic || true));
          return csstreeWalkSkip;
        }
      });
      return csstreeWalkSkip;
    }
  });
  return rules;
};
const parseStyleDeclarations = (css) => {
  const declarations = [];
  const ast = parse$I(css, {
    context: "declarationList",
    parseValue: false
  });
  walk$3(ast, (cssNode) => {
    if (cssNode.type === "Declaration") {
      declarations.push({
        name: cssNode.property,
        value: generate$I(cssNode.value),
        important: cssNode.important === true
      });
    }
  });
  return declarations;
};
const computeOwnStyle = (stylesheet, node2, parents) => {
  const computedStyle = {};
  const importantStyles = /* @__PURE__ */ new Map();
  for (const [name2, value2] of Object.entries(node2.attributes)) {
    if (attrsGroups.presentation.has(name2)) {
      computedStyle[name2] = { type: "static", inherited: false, value: value2 };
      importantStyles.set(name2, false);
    }
  }
  for (const { selector: selector2, declarations, dynamic } of stylesheet.rules) {
    if (matches(node2, selector2, parents)) {
      for (const { name: name2, value: value2, important } of declarations) {
        const computed = computedStyle[name2];
        if (computed && computed.type === "dynamic") {
          continue;
        }
        if (dynamic) {
          computedStyle[name2] = { type: "dynamic", inherited: false };
          continue;
        }
        if (computed == null || important === true || importantStyles.get(name2) === false) {
          computedStyle[name2] = { type: "static", inherited: false, value: value2 };
          importantStyles.set(name2, important);
        }
      }
    }
  }
  const styleDeclarations = node2.attributes.style == null ? [] : parseStyleDeclarations(node2.attributes.style);
  for (const { name: name2, value: value2, important } of styleDeclarations) {
    const computed = computedStyle[name2];
    if (computed && computed.type === "dynamic") {
      continue;
    }
    if (computed == null || important === true || importantStyles.get(name2) === false) {
      computedStyle[name2] = { type: "static", inherited: false, value: value2 };
      importantStyles.set(name2, important);
    }
  }
  return computedStyle;
};
const compareSpecificity = (a, b) => {
  for (let i = 0; i < 4; i += 1) {
    if (a[i] < b[i]) {
      return -1;
    } else if (a[i] > b[i]) {
      return 1;
    }
  }
  return 0;
};
const collectStylesheet = (root) => {
  const rules = [];
  const parents = /* @__PURE__ */ new Map();
  visit(root, {
    element: {
      enter: (node2, parentNode) => {
        parents.set(node2, parentNode);
        if (node2.name !== "style") {
          return;
        }
        if (node2.attributes.type == null || node2.attributes.type === "" || node2.attributes.type === "text/css") {
          const dynamic = node2.attributes.media != null && node2.attributes.media !== "all";
          for (const child of node2.children) {
            if (child.type === "text" || child.type === "cdata") {
              rules.push(...parseStylesheet(child.value, dynamic));
            }
          }
        }
      }
    }
  });
  rules.sort((a, b) => compareSpecificity(a.specificity, b.specificity));
  return { rules, parents };
};
const computeStyle = (stylesheet, node2) => {
  const { parents } = stylesheet;
  const computedStyles = computeOwnStyle(stylesheet, node2, parents);
  let parent = parents.get(node2);
  while (parent != null && parent.type !== "root") {
    const inheritedStyles = computeOwnStyle(stylesheet, parent, parents);
    for (const [name2, computed] of Object.entries(inheritedStyles)) {
      if (computedStyles[name2] == null && inheritableAttrs.has(name2) && !presentationNonInheritableGroupAttrs.has(name2)) {
        computedStyles[name2] = { ...computed, inherited: true };
      }
    }
    parent = parents.get(parent);
  }
  return computedStyles;
};
const includesAttrSelector = (selector2, name2, value2 = null, traversed = false) => {
  const selectors = typeof selector2 === "string" ? parse$1w(selector2) : parse$1w(generate$I(selector2.data));
  for (const subselector of selectors) {
    const hasAttrSelector = subselector.some((segment, index) => {
      if (traversed) {
        if (index === subselector.length - 1) {
          return false;
        }
        const isNextTraversal = isTraversal$1(subselector[index + 1]);
        if (!isNextTraversal) {
          return false;
        }
      }
      if (segment.type !== "attribute" || segment.name !== name2) {
        return false;
      }
      return value2 == null ? true : segment.value === value2;
    });
    if (hasAttrSelector) {
      return true;
    }
  }
  return false;
};
const name$N = "removeDeprecatedAttrs";
const description$N = "removes deprecated attributes";
function extractAttributesInStylesheet(stylesheet) {
  const attributesInStylesheet = /* @__PURE__ */ new Set();
  stylesheet.rules.forEach((rule) => {
    const selectors = parse$1w(rule.selector);
    selectors.forEach((subselector) => {
      subselector.forEach((segment) => {
        if (segment.type !== "attribute") {
          return;
        }
        attributesInStylesheet.add(segment.name);
      });
    });
  });
  return attributesInStylesheet;
}
function processAttributes(node2, deprecatedAttrs, params, attributesInStylesheet) {
  if (!deprecatedAttrs) {
    return;
  }
  if (deprecatedAttrs.safe) {
    deprecatedAttrs.safe.forEach((name2) => {
      if (attributesInStylesheet.has(name2)) {
        return;
      }
      delete node2.attributes[name2];
    });
  }
  if (params.removeUnsafe && deprecatedAttrs.unsafe) {
    deprecatedAttrs.unsafe.forEach((name2) => {
      if (attributesInStylesheet.has(name2)) {
        return;
      }
      delete node2.attributes[name2];
    });
  }
}
function fn$N(root, params) {
  const stylesheet = collectStylesheet(root);
  const attributesInStylesheet = extractAttributesInStylesheet(stylesheet);
  return {
    element: {
      enter: (node2) => {
        const elemConfig = elems[node2.name];
        if (!elemConfig) {
          return;
        }
        if (elemConfig.attrsGroups.has("core") && node2.attributes["xml:lang"] && !attributesInStylesheet.has("xml:lang") && node2.attributes["lang"]) {
          delete node2.attributes["xml:lang"];
        }
        elemConfig.attrsGroups.forEach((attrsGroup) => {
          processAttributes(
            node2,
            attrsGroupsDeprecated[attrsGroup],
            params,
            attributesInStylesheet
          );
        });
        processAttributes(
          node2,
          elemConfig.deprecated,
          params,
          attributesInStylesheet
        );
      }
    }
  };
}
const removeDeprecatedAttrs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$N,
  fn: fn$N,
  name: name$N
}, Symbol.toStringTag, { value: "Module" }));
const name$M = "removeMetadata";
const description$M = "removes <metadata>";
const fn$M = () => {
  return {
    element: {
      enter: (node2, parentNode) => {
        if (node2.name === "metadata") {
          detachNodeFromParent(node2, parentNode);
        }
      }
    }
  };
};
const removeMetadata = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$M,
  fn: fn$M,
  name: name$M
}, Symbol.toStringTag, { value: "Module" }));
const name$L = "removeEditorsNSData";
const description$L = "removes editors namespaces, elements and attributes";
const fn$L = (_root, params) => {
  let namespaces = [...editorNamespaces];
  if (Array.isArray(params.additionalNamespaces)) {
    namespaces = [...editorNamespaces, ...params.additionalNamespaces];
  }
  const prefixes = [];
  return {
    element: {
      enter: (node2, parentNode) => {
        if (node2.name === "svg") {
          for (const [name2, value2] of Object.entries(node2.attributes)) {
            if (name2.startsWith("xmlns:") && namespaces.includes(value2)) {
              prefixes.push(name2.slice("xmlns:".length));
              delete node2.attributes[name2];
            }
          }
        }
        for (const name2 of Object.keys(node2.attributes)) {
          if (name2.includes(":")) {
            const [prefix] = name2.split(":");
            if (prefixes.includes(prefix)) {
              delete node2.attributes[name2];
            }
          }
        }
        if (node2.name.includes(":")) {
          const [prefix] = node2.name.split(":");
          if (prefixes.includes(prefix)) {
            detachNodeFromParent(node2, parentNode);
          }
        }
      }
    }
  };
};
const removeEditorsNSData = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$L,
  fn: fn$L,
  name: name$L
}, Symbol.toStringTag, { value: "Module" }));
const name$K = "cleanupAttrs";
const description$K = "cleanups attributes from newlines, trailing and repeating spaces";
const regNewlinesNeedSpace = /(\S)\r?\n(\S)/g;
const regNewlines = /\r?\n/g;
const regSpaces = /\s{2,}/g;
const fn$K = (root, params) => {
  const { newlines = true, trim = true, spaces = true } = params;
  return {
    element: {
      enter: (node2) => {
        for (const name2 of Object.keys(node2.attributes)) {
          if (newlines) {
            node2.attributes[name2] = node2.attributes[name2].replace(
              regNewlinesNeedSpace,
              (match, p1, p2) => p1 + " " + p2
            );
            node2.attributes[name2] = node2.attributes[name2].replace(
              regNewlines,
              ""
            );
          }
          if (trim) {
            node2.attributes[name2] = node2.attributes[name2].trim();
          }
          if (spaces) {
            node2.attributes[name2] = node2.attributes[name2].replace(
              regSpaces,
              " "
            );
          }
        }
      }
    }
  };
};
const cleanupAttrs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$K,
  fn: fn$K,
  name: name$K
}, Symbol.toStringTag, { value: "Module" }));
const name$J = "mergeStyles";
const description$J = "merge multiple style elements into one";
const fn$J = () => {
  let firstStyleElement = null;
  let collectedStyles = "";
  let styleContentType = "text";
  return {
    element: {
      enter: (node2, parentNode) => {
        if (node2.name === "foreignObject") {
          return visitSkip;
        }
        if (node2.name !== "style") {
          return;
        }
        if (node2.attributes.type != null && node2.attributes.type !== "" && node2.attributes.type !== "text/css") {
          return;
        }
        let css = "";
        for (const child of node2.children) {
          if (child.type === "text") {
            css += child.value;
          }
          if (child.type === "cdata") {
            styleContentType = "cdata";
            css += child.value;
          }
        }
        if (css.trim().length === 0) {
          detachNodeFromParent(node2, parentNode);
          return;
        }
        if (node2.attributes.media == null) {
          collectedStyles += css;
        } else {
          collectedStyles += `@media ${node2.attributes.media}{${css}}`;
          delete node2.attributes.media;
        }
        if (firstStyleElement == null) {
          firstStyleElement = node2;
        } else {
          detachNodeFromParent(node2, parentNode);
          const child = { type: styleContentType, value: collectedStyles };
          firstStyleElement.children = [child];
        }
      }
    }
  };
};
const mergeStyles = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$J,
  fn: fn$J,
  name: name$J
}, Symbol.toStringTag, { value: "Module" }));
const name$I = "inlineStyles";
const description$I = "inline styles (additional options)";
const preservedPseudos = [
  ...pseudoClasses.functional,
  ...pseudoClasses.treeStructural
];
const fn$I = (root, params) => {
  const {
    onlyMatchedOnce = true,
    removeMatchedSelectors = true,
    useMqs = ["", "screen"],
    usePseudos = [""]
  } = params;
  const styles = [];
  const selectors = [];
  return {
    element: {
      enter: (node2, parentNode) => {
        if (node2.name === "foreignObject") {
          return visitSkip;
        }
        if (node2.name !== "style" || node2.children.length === 0) {
          return;
        }
        if (node2.attributes.type != null && node2.attributes.type !== "" && node2.attributes.type !== "text/css") {
          return;
        }
        const cssText = node2.children.filter((child) => child.type === "text" || child.type === "cdata").map((child) => child.value).join("");
        let cssAst = null;
        try {
          cssAst = parse$I(cssText, {
            parseValue: false,
            parseCustomProperty: false
          });
        } catch {
          return;
        }
        if (cssAst.type === "StyleSheet") {
          styles.push({ node: node2, parentNode, cssAst });
        }
        walk$3(cssAst, {
          visit: "Rule",
          enter(node3) {
            const atrule2 = this.atrule;
            let mediaQuery = "";
            if (atrule2 != null) {
              mediaQuery = atrule2.name;
              if (atrule2.prelude != null) {
                mediaQuery += ` ${generate$I(atrule2.prelude)}`;
              }
            }
            if (!useMqs.includes(mediaQuery)) {
              return;
            }
            if (node3.prelude.type === "SelectorList") {
              node3.prelude.children.forEach((childNode, item) => {
                if (childNode.type === "Selector") {
                  const pseudos2 = [];
                  childNode.children.forEach(
                    (grandchildNode, grandchildItem, grandchildList) => {
                      const isPseudo = grandchildNode.type === "PseudoClassSelector" || grandchildNode.type === "PseudoElementSelector";
                      if (isPseudo && !preservedPseudos.includes(grandchildNode.name)) {
                        pseudos2.push({
                          item: grandchildItem,
                          list: grandchildList
                        });
                      }
                    }
                  );
                  const pseudoSelectors = generate$I({
                    type: "Selector",
                    children: new List$1().fromArray(
                      pseudos2.map((pseudo2) => pseudo2.item.data)
                    )
                  });
                  if (usePseudos.includes(pseudoSelectors)) {
                    for (const pseudo2 of pseudos2) {
                      pseudo2.list.remove(pseudo2.item);
                    }
                  }
                  selectors.push({ node: childNode, rule: node3, item });
                }
              });
            }
          }
        });
      }
    },
    root: {
      exit: () => {
        if (styles.length === 0) {
          return;
        }
        const sortedSelectors = selectors.slice().sort((a, b) => {
          const aSpecificity = specificity(a.item.data);
          const bSpecificity = specificity(b.item.data);
          return compareSpecificity(aSpecificity, bSpecificity);
        }).reverse();
        for (const selector2 of sortedSelectors) {
          const selectorText = generate$I(selector2.item.data);
          const matchedElements = [];
          try {
            for (const node2 of querySelectorAll(root, selectorText)) {
              if (node2.type === "element") {
                matchedElements.push(node2);
              }
            }
          } catch {
            continue;
          }
          if (matchedElements.length === 0) {
            continue;
          }
          if (onlyMatchedOnce && matchedElements.length > 1) {
            continue;
          }
          for (const selectedEl of matchedElements) {
            const styleDeclarationList = parse$I(
              selectedEl.attributes.style ?? "",
              {
                context: "declarationList",
                parseValue: false
              }
            );
            if (styleDeclarationList.type !== "DeclarationList") {
              continue;
            }
            const styleDeclarationItems = /* @__PURE__ */ new Map();
            let firstListItem;
            walk$3(styleDeclarationList, {
              visit: "Declaration",
              enter(node2, item) {
                if (firstListItem == null) {
                  firstListItem = item;
                }
                styleDeclarationItems.set(node2.property.toLowerCase(), item);
              }
            });
            walk$3(selector2.rule, {
              visit: "Declaration",
              enter(ruleDeclaration) {
                const property2 = ruleDeclaration.property;
                if (attrsGroups.presentation.has(property2) && !selectors.some(
                  (selector3) => includesAttrSelector(selector3.item, property2)
                )) {
                  delete selectedEl.attributes[property2];
                }
                const matchedItem = styleDeclarationItems.get(property2);
                const ruleDeclarationItem = styleDeclarationList.children.createItem(ruleDeclaration);
                if (matchedItem == null) {
                  styleDeclarationList.children.insert(
                    ruleDeclarationItem,
                    firstListItem
                  );
                } else if (matchedItem.data.important !== true && ruleDeclaration.important === true) {
                  styleDeclarationList.children.replace(
                    matchedItem,
                    ruleDeclarationItem
                  );
                  styleDeclarationItems.set(property2, ruleDeclarationItem);
                }
              }
            });
            const newStyles = generate$I(styleDeclarationList);
            if (newStyles.length !== 0) {
              selectedEl.attributes.style = newStyles;
            }
          }
          if (removeMatchedSelectors && matchedElements.length !== 0 && selector2.rule.prelude.type === "SelectorList") {
            selector2.rule.prelude.children.remove(selector2.item);
          }
          selector2.matchedElements = matchedElements;
        }
        if (!removeMatchedSelectors) {
          return;
        }
        for (const selector2 of sortedSelectors) {
          if (selector2.matchedElements == null) {
            continue;
          }
          if (onlyMatchedOnce && selector2.matchedElements.length > 1) {
            continue;
          }
          for (const selectedEl of selector2.matchedElements) {
            const classList = new Set(
              selectedEl.attributes.class == null ? null : selectedEl.attributes.class.split(" ")
            );
            for (const child of selector2.node.children) {
              if (child.type === "ClassSelector" && !selectors.some(
                (selector3) => includesAttrSelector(
                  selector3.item,
                  "class",
                  child.name,
                  true
                )
              )) {
                classList.delete(child.name);
              }
            }
            if (classList.size === 0) {
              delete selectedEl.attributes.class;
            } else {
              selectedEl.attributes.class = Array.from(classList).join(" ");
            }
            const firstSubSelector = selector2.node.children.first;
            if (firstSubSelector?.type === "IdSelector" && selectedEl.attributes.id === firstSubSelector.name && !selectors.some(
              (selector3) => includesAttrSelector(
                selector3.item,
                "id",
                firstSubSelector.name,
                true
              )
            )) {
              delete selectedEl.attributes.id;
            }
          }
        }
        for (const style of styles) {
          walk$3(style.cssAst, {
            visit: "Rule",
            enter: function(node2, item, list) {
              if (node2.type === "Rule" && node2.prelude.type === "SelectorList" && node2.prelude.children.isEmpty) {
                list.remove(item);
              }
            }
          });
          if (style.cssAst.children.isEmpty) {
            detachNodeFromParent(style.node, style.parentNode);
          } else {
            const firstChild = style.node.children[0];
            if (firstChild.type === "text" || firstChild.type === "cdata") {
              firstChild.value = generate$I(style.cssAst);
            }
          }
        }
      }
    }
  };
};
const inlineStyles = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$I,
  fn: fn$I,
  name: name$I
}, Symbol.toStringTag, { value: "Module" }));
const regReferencesUrl = /\burl\((["'])?#(.+?)\1\)/g;
const regReferencesHref = /^#(.+?)$/;
const regReferencesBegin = /(\w+)\.[a-zA-Z]/;
const cleanupOutData = (data, params, command) => {
  let str = "";
  let delimiter;
  let prev;
  data.forEach((item, i) => {
    delimiter = " ";
    if (i == 0) {
      delimiter = "";
    }
    if (params.noSpaceAfterFlags && command == "a") ;
    const itemStr = params.leadingZero ? removeLeadingZero(item) : item.toString();
    if (params.negativeExtraSpace && delimiter != "" && (item < 0 || itemStr.charAt(0) === "." && prev % 1 !== 0)) {
      delimiter = "";
    }
    prev = item;
    str += delimiter + itemStr;
  });
  return str;
};
const removeLeadingZero = (value2) => {
  const strValue = value2.toString();
  if (0 < value2 && value2 < 1 && strValue.startsWith("0")) {
    return strValue.slice(1);
  }
  if (-1 < value2 && value2 < 0 && strValue[1] === "0") {
    return strValue[0] + strValue.slice(2);
  }
  return strValue;
};
const hasScripts = (node2) => {
  if (node2.name === "script" && node2.children.length !== 0) {
    return true;
  }
  if (node2.name === "a") {
    const hasJsLinks = Object.entries(node2.attributes).some(
      ([attrKey, attrValue]) => (attrKey === "href" || attrKey.endsWith(":href")) && attrValue != null && attrValue.trimStart().startsWith("javascript:")
    );
    if (hasJsLinks) {
      return true;
    }
  }
  const eventAttrs2 = [
    ...attrsGroups.animationEvent,
    ...attrsGroups.documentEvent,
    ...attrsGroups.documentElementEvent,
    ...attrsGroups.globalEvent,
    ...attrsGroups.graphicalEvent
  ];
  return eventAttrs2.some((attr) => node2.attributes[attr] != null);
};
const includesUrlReference = (body) => {
  return new RegExp(regReferencesUrl).test(body);
};
const findReferences = (attribute, value2) => {
  const results = [];
  if (referencesProps.has(attribute)) {
    const matches2 = value2.matchAll(regReferencesUrl);
    for (const match of matches2) {
      results.push(match[2]);
    }
  }
  if (attribute === "href" || attribute.endsWith(":href")) {
    const match = regReferencesHref.exec(value2);
    if (match != null) {
      results.push(match[1]);
    }
  }
  if (attribute === "begin") {
    const match = regReferencesBegin.exec(value2);
    if (match != null) {
      results.push(match[1]);
    }
  }
  return results.map((body) => decodeURI(body));
};
const toFixed = (num, precision2) => {
  const pow = 10 ** precision2;
  return Math.round(num * pow) / pow;
};
const name$H = "minifyStyles";
const description$H = "minifies styles and removes unused styles";
const fn$H = (_root, { usage, ...params }) => {
  const styleElements = /* @__PURE__ */ new Map();
  const elementsWithStyleAttributes = [];
  const tagsUsage = /* @__PURE__ */ new Set();
  const idsUsage = /* @__PURE__ */ new Set();
  const classesUsage = /* @__PURE__ */ new Set();
  let enableTagsUsage = true;
  let enableIdsUsage = true;
  let enableClassesUsage = true;
  let forceUsageDeoptimized = false;
  if (typeof usage === "boolean") {
    enableTagsUsage = usage;
    enableIdsUsage = usage;
    enableClassesUsage = usage;
  } else if (usage) {
    enableTagsUsage = usage.tags == null ? true : usage.tags;
    enableIdsUsage = usage.ids == null ? true : usage.ids;
    enableClassesUsage = usage.classes == null ? true : usage.classes;
    forceUsageDeoptimized = usage.force == null ? false : usage.force;
  }
  let deoptimized = false;
  return {
    element: {
      enter: (node2, parentNode) => {
        if (hasScripts(node2)) {
          deoptimized = true;
        }
        tagsUsage.add(node2.name);
        if (node2.attributes.id != null) {
          idsUsage.add(node2.attributes.id);
        }
        if (node2.attributes.class != null) {
          for (const className of node2.attributes.class.split(/\s+/)) {
            classesUsage.add(className);
          }
        }
        if (node2.name === "style" && node2.children.length !== 0) {
          styleElements.set(node2, parentNode);
        } else if (node2.attributes.style != null) {
          elementsWithStyleAttributes.push(node2);
        }
      }
    },
    root: {
      exit: () => {
        const cssoUsage = {};
        if (!deoptimized || forceUsageDeoptimized) {
          if (enableTagsUsage) {
            cssoUsage.tags = Array.from(tagsUsage);
          }
          if (enableIdsUsage) {
            cssoUsage.ids = Array.from(idsUsage);
          }
          if (enableClassesUsage) {
            cssoUsage.classes = Array.from(classesUsage);
          }
        }
        for (const [styleNode, styleNodeParent] of styleElements.entries()) {
          if (styleNode.children[0].type === "text" || styleNode.children[0].type === "cdata") {
            const cssText = styleNode.children[0].value;
            const minified = minifyStylesheet(cssText, {
              ...params,
              usage: cssoUsage
            }).css;
            if (minified.length === 0) {
              detachNodeFromParent(styleNode, styleNodeParent);
              continue;
            }
            if (cssText.indexOf(">") >= 0 || cssText.indexOf("<") >= 0) {
              styleNode.children[0].type = "cdata";
              styleNode.children[0].value = minified;
            } else {
              styleNode.children[0].type = "text";
              styleNode.children[0].value = minified;
            }
          }
        }
        for (const node2 of elementsWithStyleAttributes) {
          const elemStyle = node2.attributes.style;
          node2.attributes.style = minifyBlock(elemStyle, {
            ...params
          }).css;
        }
      }
    }
  };
};
const minifyStyles = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$H,
  fn: fn$H,
  name: name$H
}, Symbol.toStringTag, { value: "Module" }));
const name$G = "cleanupIds";
const description$G = "removes unused IDs and minifies used";
const generateIdChars = [
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z"
];
const maxIdIndex = generateIdChars.length - 1;
const hasStringPrefix = (string, prefixes) => {
  for (const prefix of prefixes) {
    if (string.startsWith(prefix)) {
      return true;
    }
  }
  return false;
};
const generateId = (currentId) => {
  if (currentId == null) {
    return [0];
  }
  currentId[currentId.length - 1] += 1;
  for (let i = currentId.length - 1; i > 0; i--) {
    if (currentId[i] > maxIdIndex) {
      currentId[i] = 0;
      if (currentId[i - 1] !== void 0) {
        currentId[i - 1]++;
      }
    }
  }
  if (currentId[0] > maxIdIndex) {
    currentId[0] = 0;
    currentId.unshift(0);
  }
  return currentId;
};
const getIdString = (arr) => {
  return arr.map((i) => generateIdChars[i]).join("");
};
const fn$G = (_root, params) => {
  const {
    remove = true,
    minify: minify2 = true,
    preserve = [],
    preservePrefixes = [],
    force = false
  } = params;
  const preserveIds = new Set(
    Array.isArray(preserve) ? preserve : preserve ? [preserve] : []
  );
  const preserveIdPrefixes = Array.isArray(preservePrefixes) ? preservePrefixes : preservePrefixes ? [preservePrefixes] : [];
  const nodeById = /* @__PURE__ */ new Map();
  const referencesById = /* @__PURE__ */ new Map();
  let deoptimized = false;
  return {
    element: {
      enter: (node2) => {
        if (!force) {
          if (node2.name === "style" && node2.children.length !== 0 || hasScripts(node2)) {
            deoptimized = true;
            return;
          }
          if (node2.name === "svg") {
            let hasDefsOnly = true;
            for (const child of node2.children) {
              if (child.type !== "element" || child.name !== "defs") {
                hasDefsOnly = false;
                break;
              }
            }
            if (hasDefsOnly) {
              return visitSkip;
            }
          }
        }
        for (const [name2, value2] of Object.entries(node2.attributes)) {
          if (name2 === "id") {
            const id = value2;
            if (nodeById.has(id)) {
              delete node2.attributes.id;
            } else {
              nodeById.set(id, node2);
            }
          } else {
            const ids = findReferences(name2, value2);
            for (const id of ids) {
              let refs = referencesById.get(id);
              if (refs == null) {
                refs = [];
                referencesById.set(id, refs);
              }
              refs.push({ element: node2, name: name2 });
            }
          }
        }
      }
    },
    root: {
      exit: () => {
        if (deoptimized) {
          return;
        }
        const isIdPreserved = (id) => preserveIds.has(id) || hasStringPrefix(id, preserveIdPrefixes);
        let currentId = null;
        for (const [id, refs] of referencesById) {
          const node2 = nodeById.get(id);
          if (node2 != null) {
            if (minify2 && isIdPreserved(id) === false) {
              let currentIdString;
              do {
                currentId = generateId(currentId);
                currentIdString = getIdString(currentId);
              } while (isIdPreserved(currentIdString) || referencesById.has(currentIdString) && nodeById.get(currentIdString) == null);
              node2.attributes.id = currentIdString;
              for (const { element, name: name2 } of refs) {
                const value2 = element.attributes[name2];
                if (value2.includes("#")) {
                  element.attributes[name2] = value2.replace(`#${encodeURI(id)}`, `#${currentIdString}`).replace(`#${id}`, `#${currentIdString}`);
                } else {
                  element.attributes[name2] = value2.replace(
                    `${id}.`,
                    `${currentIdString}.`
                  );
                }
              }
            }
            nodeById.delete(id);
          }
        }
        if (remove) {
          for (const [id, node2] of nodeById) {
            if (isIdPreserved(id) === false) {
              delete node2.attributes.id;
            }
          }
        }
      }
    }
  };
};
const cleanupIds = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$G,
  fn: fn$G,
  name: name$G
}, Symbol.toStringTag, { value: "Module" }));
const name$F = "removeUselessDefs";
const description$F = "removes elements in <defs> without id";
const fn$F = () => {
  return {
    element: {
      enter: (node2, parentNode) => {
        if (node2.name === "defs" || elemsGroups.nonRendering.has(node2.name) && node2.attributes.id == null) {
          const usefulNodes = [];
          collectUsefulNodes(node2, usefulNodes);
          if (usefulNodes.length === 0) {
            detachNodeFromParent(node2, parentNode);
          }
          node2.children = usefulNodes;
        }
      }
    }
  };
};
const collectUsefulNodes = (node2, usefulNodes) => {
  for (const child of node2.children) {
    if (child.type === "element") {
      if (child.attributes.id != null || child.name === "style") {
        usefulNodes.push(child);
      } else {
        collectUsefulNodes(child, usefulNodes);
      }
    }
  }
};
const removeUselessDefs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$F,
  fn: fn$F,
  name: name$F
}, Symbol.toStringTag, { value: "Module" }));
const name$E = "cleanupNumericValues";
const description$E = 'rounds numeric values to the fixed precision, removes default "px" units';
const regNumericValues$3 = /^([-+]?\d*\.?\d+([eE][-+]?\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/;
const absoluteLengths$1 = {
  // relative to px
  cm: 96 / 2.54,
  mm: 96 / 25.4,
  in: 96,
  pt: 4 / 3,
  pc: 16,
  px: 1
};
const fn$E = (_root, params) => {
  const {
    floatPrecision = 3,
    leadingZero = true,
    defaultPx = true,
    convertToPx = true
  } = params;
  return {
    element: {
      enter: (node2) => {
        if (node2.attributes.viewBox != null) {
          const nums = node2.attributes.viewBox.trim().split(/(?:\s,?|,)\s*/g);
          node2.attributes.viewBox = nums.map((value2) => {
            const num = Number(value2);
            return Number.isNaN(num) ? value2 : Number(num.toFixed(floatPrecision));
          }).join(" ");
        }
        for (const [name2, value2] of Object.entries(node2.attributes)) {
          if (name2 === "version") {
            continue;
          }
          const match = regNumericValues$3.exec(value2);
          if (match) {
            let num = Number(Number(match[1]).toFixed(floatPrecision));
            const matchedUnit = match[3] || "";
            let units2 = matchedUnit;
            if (convertToPx && units2 !== "" && units2 in absoluteLengths$1) {
              const pxNum = Number(
                (absoluteLengths$1[units2] * Number(match[1])).toFixed(
                  floatPrecision
                )
              );
              if (pxNum.toString().length < match[0].length) {
                num = pxNum;
                units2 = "px";
              }
            }
            let str;
            if (leadingZero) {
              str = removeLeadingZero(num);
            } else {
              str = num.toString();
            }
            if (defaultPx && units2 === "px") {
              units2 = "";
            }
            node2.attributes[name2] = str + units2;
          }
        }
      }
    }
  };
};
const cleanupNumericValues = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$E,
  fn: fn$E,
  name: name$E
}, Symbol.toStringTag, { value: "Module" }));
const name$D = "convertColors";
const description$D = "converts colors: rgb() to #rrggbb and #rrggbb to #rgb";
const rNumber = "([+-]?(?:\\d*\\.\\d+|\\d+\\.?)%?)";
const rComma = "(?:\\s*,\\s*|\\s+)";
const regRGB = new RegExp(
  "^rgb\\(\\s*" + rNumber + rComma + rNumber + rComma + rNumber + "\\s*\\)$"
);
const regHEX = /^#(([a-fA-F0-9])\2){3}$/;
const convertRgbToHex = ([r, g2, b]) => {
  const hexNumber = (
    // operator precedence is (+) > (<<) > (|)
    (256 + // [1][0]
    r << // [1][r]
    8 | // [1][r][0]
    g2) << // [1][r][g]
    8 | // [1][r][g][0]
    b
  );
  return "#" + hexNumber.toString(16).slice(1).toUpperCase();
};
const fn$D = (_root, params) => {
  const {
    currentColor = false,
    names2hex = true,
    rgb2hex = true,
    convertCase = "lower",
    shorthex = true,
    shortname = true
  } = params;
  let maskCounter = 0;
  return {
    element: {
      enter: (node2) => {
        if (node2.name === "mask") {
          maskCounter++;
        }
        for (const [name2, value2] of Object.entries(node2.attributes)) {
          if (colorsProps.has(name2)) {
            let val = value2;
            if (currentColor && maskCounter === 0) {
              let matched;
              if (typeof currentColor === "string") {
                matched = val === currentColor;
              } else if (currentColor instanceof RegExp) {
                matched = currentColor.exec(val) != null;
              } else {
                matched = val !== "none";
              }
              if (matched) {
                val = "currentColor";
              }
            }
            if (names2hex) {
              const colorName = val.toLowerCase();
              if (colorsNames[colorName] != null) {
                val = colorsNames[colorName];
              }
            }
            if (rgb2hex) {
              const match = val.match(regRGB);
              if (match != null) {
                const nums = match.slice(1, 4).map((m) => {
                  let n;
                  if (m.indexOf("%") > -1) {
                    n = Math.round(parseFloat(m) * 2.55);
                  } else {
                    n = Number(m);
                  }
                  return Math.max(0, Math.min(n, 255));
                });
                val = convertRgbToHex(nums);
              }
            }
            if (convertCase && !includesUrlReference(val) && val !== "currentColor") {
              if (convertCase === "lower") {
                val = val.toLowerCase();
              } else if (convertCase === "upper") {
                val = val.toUpperCase();
              }
            }
            if (shorthex) {
              const match = regHEX.exec(val);
              if (match != null) {
                val = "#" + match[0][1] + match[0][3] + match[0][5];
              }
            }
            if (shortname) {
              const colorName = val.toLowerCase();
              if (colorsShortNames[colorName] != null) {
                val = colorsShortNames[colorName];
              }
            }
            node2.attributes[name2] = val;
          }
        }
      },
      exit: (node2) => {
        if (node2.name === "mask") {
          maskCounter--;
        }
      }
    }
  };
};
const convertColors = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$D,
  fn: fn$D,
  name: name$D
}, Symbol.toStringTag, { value: "Module" }));
const name$C = "removeUnknownsAndDefaults";
const description$C = "removes unknown elements content and attributes, removes attrs with default values";
const allowedChildrenPerElement = /* @__PURE__ */ new Map();
const allowedAttributesPerElement = /* @__PURE__ */ new Map();
const attributesDefaultsPerElement = /* @__PURE__ */ new Map();
for (const [name2, config] of Object.entries(elems)) {
  const allowedChildren = /* @__PURE__ */ new Set();
  if (config.content) {
    for (const elementName of config.content) {
      allowedChildren.add(elementName);
    }
  }
  if (config.contentGroups) {
    for (const contentGroupName of config.contentGroups) {
      const elemsGroup = elemsGroups[contentGroupName];
      if (elemsGroup) {
        for (const elementName of elemsGroup) {
          allowedChildren.add(elementName);
        }
      }
    }
  }
  const allowedAttributes = /* @__PURE__ */ new Set();
  if (config.attrs) {
    for (const attrName of config.attrs) {
      allowedAttributes.add(attrName);
    }
  }
  const attributesDefaults = /* @__PURE__ */ new Map();
  if (config.defaults) {
    for (const [attrName, defaultValue] of Object.entries(config.defaults)) {
      attributesDefaults.set(attrName, defaultValue);
    }
  }
  for (const attrsGroupName of config.attrsGroups) {
    const attrsGroup = attrsGroups[attrsGroupName];
    if (attrsGroup) {
      for (const attrName of attrsGroup) {
        allowedAttributes.add(attrName);
      }
    }
    const groupDefaults = attrsGroupsDefaults[attrsGroupName];
    if (groupDefaults) {
      for (const [attrName, defaultValue] of Object.entries(groupDefaults)) {
        attributesDefaults.set(attrName, defaultValue);
      }
    }
  }
  allowedChildrenPerElement.set(name2, allowedChildren);
  allowedAttributesPerElement.set(name2, allowedAttributes);
  attributesDefaultsPerElement.set(name2, attributesDefaults);
}
const fn$C = (root, params) => {
  const {
    unknownContent = true,
    unknownAttrs = true,
    defaultAttrs = true,
    defaultMarkupDeclarations = true,
    uselessOverrides = true,
    keepDataAttrs = true,
    keepAriaAttrs = true,
    keepRoleAttr = false
  } = params;
  const stylesheet = collectStylesheet(root);
  return {
    instruction: {
      enter: (node2) => {
        if (defaultMarkupDeclarations) {
          node2.value = node2.value.replace(/\s*standalone\s*=\s*(["'])no\1/, "");
        }
      }
    },
    element: {
      enter: (node2, parentNode) => {
        if (node2.name.includes(":")) {
          return;
        }
        if (node2.name === "foreignObject") {
          return visitSkip;
        }
        if (unknownContent && parentNode.type === "element") {
          const allowedChildren = allowedChildrenPerElement.get(
            parentNode.name
          );
          if (allowedChildren == null || allowedChildren.size === 0) {
            if (allowedChildrenPerElement.get(node2.name) == null) {
              detachNodeFromParent(node2, parentNode);
              return;
            }
          } else {
            if (allowedChildren.has(node2.name) === false) {
              detachNodeFromParent(node2, parentNode);
              return;
            }
          }
        }
        const allowedAttributes = allowedAttributesPerElement.get(node2.name);
        const attributesDefaults = attributesDefaultsPerElement.get(node2.name);
        const computedParentStyle = parentNode.type === "element" ? computeStyle(stylesheet, parentNode) : null;
        for (const [name2, value2] of Object.entries(node2.attributes)) {
          if (keepDataAttrs && name2.startsWith("data-")) {
            continue;
          }
          if (keepAriaAttrs && name2.startsWith("aria-")) {
            continue;
          }
          if (keepRoleAttr && name2 === "role") {
            continue;
          }
          if (name2 === "xmlns") {
            continue;
          }
          if (name2.includes(":")) {
            const [prefix] = name2.split(":");
            if (prefix !== "xml" && prefix !== "xlink") {
              continue;
            }
          }
          if (unknownAttrs && allowedAttributes && allowedAttributes.has(name2) === false) {
            delete node2.attributes[name2];
          }
          if (defaultAttrs && node2.attributes.id == null && attributesDefaults && attributesDefaults.get(name2) === value2) {
            if (computedParentStyle?.[name2] == null) {
              delete node2.attributes[name2];
            }
          }
          if (uselessOverrides && node2.attributes.id == null) {
            const style = computedParentStyle?.[name2];
            if (presentationNonInheritableGroupAttrs.has(name2) === false && style != null && style.type === "static" && style.value === value2) {
              delete node2.attributes[name2];
            }
          }
        }
      }
    }
  };
};
const removeUnknownsAndDefaults = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$C,
  fn: fn$C,
  name: name$C
}, Symbol.toStringTag, { value: "Module" }));
const name$B = "removeNonInheritableGroupAttrs";
const description$B = "removes non-inheritable group's presentational attributes";
const fn$B = () => {
  return {
    element: {
      enter: (node2) => {
        if (node2.name === "g") {
          for (const name2 of Object.keys(node2.attributes)) {
            if (attrsGroups.presentation.has(name2) && !inheritableAttrs.has(name2) && !presentationNonInheritableGroupAttrs.has(name2)) {
              delete node2.attributes[name2];
            }
          }
        }
      }
    }
  };
};
const removeNonInheritableGroupAttrs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$B,
  fn: fn$B,
  name: name$B
}, Symbol.toStringTag, { value: "Module" }));
const name$A = "removeUselessStrokeAndFill";
const description$A = "removes useless stroke and fill attributes";
const fn$A = (root, params) => {
  const {
    stroke: removeStroke = true,
    fill: removeFill = true,
    removeNone = false
  } = params;
  let hasStyleOrScript = false;
  visit(root, {
    element: {
      enter: (node2) => {
        if (node2.name === "style" || hasScripts(node2)) {
          hasStyleOrScript = true;
        }
      }
    }
  });
  if (hasStyleOrScript) {
    return null;
  }
  const stylesheet = collectStylesheet(root);
  return {
    element: {
      enter: (node2, parentNode) => {
        if (node2.attributes.id != null) {
          return visitSkip;
        }
        if (!elemsGroups.shape.has(node2.name)) {
          return;
        }
        const computedStyle = computeStyle(stylesheet, node2);
        const stroke = computedStyle.stroke;
        const strokeOpacity = computedStyle["stroke-opacity"];
        const strokeWidth = computedStyle["stroke-width"];
        const markerEnd = computedStyle["marker-end"];
        const fill = computedStyle.fill;
        const fillOpacity = computedStyle["fill-opacity"];
        const computedParentStyle = parentNode.type === "element" ? computeStyle(stylesheet, parentNode) : null;
        const parentStroke = computedParentStyle == null ? null : computedParentStyle.stroke;
        if (removeStroke) {
          if (stroke == null || stroke.type === "static" && stroke.value == "none" || strokeOpacity != null && strokeOpacity.type === "static" && strokeOpacity.value === "0" || strokeWidth != null && strokeWidth.type === "static" && strokeWidth.value === "0") {
            if (strokeWidth != null && strokeWidth.type === "static" && strokeWidth.value === "0" || markerEnd == null) {
              for (const name2 of Object.keys(node2.attributes)) {
                if (name2.startsWith("stroke")) {
                  delete node2.attributes[name2];
                }
              }
              if (parentStroke != null && parentStroke.type === "static" && parentStroke.value !== "none") {
                node2.attributes.stroke = "none";
              }
            }
          }
        }
        if (removeFill) {
          if (fill != null && fill.type === "static" && fill.value === "none" || fillOpacity != null && fillOpacity.type === "static" && fillOpacity.value === "0") {
            for (const name2 of Object.keys(node2.attributes)) {
              if (name2.startsWith("fill-")) {
                delete node2.attributes[name2];
              }
            }
            if (fill == null || fill.type === "static" && fill.value !== "none") {
              node2.attributes.fill = "none";
            }
          }
        }
        if (removeNone) {
          if ((stroke == null || node2.attributes.stroke === "none") && (fill != null && fill.type === "static" && fill.value === "none" || node2.attributes.fill === "none")) {
            detachNodeFromParent(node2, parentNode);
          }
        }
      }
    }
  };
};
const removeUselessStrokeAndFill = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$A,
  fn: fn$A,
  name: name$A
}, Symbol.toStringTag, { value: "Module" }));
const name$z = "cleanupEnableBackground";
const description$z = "remove or cleanup enable-background attribute when possible";
const regEnableBackground = /^new\s0\s0\s([-+]?\d*\.?\d+([eE][-+]?\d+)?)\s([-+]?\d*\.?\d+([eE][-+]?\d+)?)$/;
const fn$z = (root) => {
  let hasFilter = false;
  visit(root, {
    element: {
      enter: (node2) => {
        if (node2.name === "filter") {
          hasFilter = true;
        }
      }
    }
  });
  return {
    element: {
      enter: (node2) => {
        let newStyle = null;
        let enableBackgroundDeclaration = null;
        if (node2.attributes.style != null) {
          newStyle = parse$I(node2.attributes.style, {
            context: "declarationList"
          });
          if (newStyle.type === "DeclarationList") {
            const enableBackgroundDeclarations = [];
            walk$3(newStyle, (node3, nodeItem) => {
              if (node3.type === "Declaration" && node3.property === "enable-background") {
                enableBackgroundDeclarations.push(nodeItem);
                enableBackgroundDeclaration = nodeItem;
              }
            });
            for (let i = 0; i < enableBackgroundDeclarations.length - 1; i++) {
              newStyle.children.remove(enableBackgroundDeclarations[i]);
            }
          }
        }
        if (!hasFilter) {
          delete node2.attributes["enable-background"];
          if (newStyle?.type === "DeclarationList") {
            if (enableBackgroundDeclaration) {
              newStyle.children.remove(enableBackgroundDeclaration);
            }
            if (newStyle.children.isEmpty) {
              delete node2.attributes.style;
            } else {
              node2.attributes.style = generate$I(newStyle);
            }
          }
          return;
        }
        const hasDimensions = node2.attributes.width != null && node2.attributes.height != null;
        if ((node2.name === "svg" || node2.name === "mask" || node2.name === "pattern") && hasDimensions) {
          const attrValue = node2.attributes["enable-background"];
          const attrCleaned = cleanupValue(
            attrValue,
            node2.name,
            node2.attributes.width,
            node2.attributes.height
          );
          if (attrCleaned) {
            node2.attributes["enable-background"] = attrCleaned;
          } else {
            delete node2.attributes["enable-background"];
          }
          if (newStyle?.type === "DeclarationList" && enableBackgroundDeclaration) {
            const styleValue = generate$I(
              // @ts-expect-error
              enableBackgroundDeclaration.data.value
            );
            const styleCleaned = cleanupValue(
              styleValue,
              node2.name,
              node2.attributes.width,
              node2.attributes.height
            );
            if (styleCleaned) {
              enableBackgroundDeclaration.data.value = {
                type: "Raw",
                value: styleCleaned
              };
            } else {
              newStyle.children.remove(enableBackgroundDeclaration);
            }
          }
        }
        if (newStyle?.type === "DeclarationList") {
          if (newStyle.children.isEmpty) {
            delete node2.attributes.style;
          } else {
            node2.attributes.style = generate$I(newStyle);
          }
        }
      }
    }
  };
};
const cleanupValue = (value2, nodeName, width, height) => {
  const match = regEnableBackground.exec(value2);
  if (match != null && width === match[1] && height === match[3]) {
    return nodeName === "svg" ? void 0 : "new";
  }
  return value2;
};
const cleanupEnableBackground = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$z,
  fn: fn$z,
  name: name$z
}, Symbol.toStringTag, { value: "Module" }));
const argsCountPerCommand = {
  M: 2,
  m: 2,
  Z: 0,
  z: 0,
  L: 2,
  l: 2,
  H: 1,
  h: 1,
  V: 1,
  v: 1,
  C: 6,
  c: 6,
  S: 4,
  s: 4,
  Q: 4,
  q: 4,
  T: 2,
  t: 2,
  A: 7,
  a: 7
};
const isCommand = (c) => {
  return c in argsCountPerCommand;
};
const isWhiteSpace = (c) => {
  return c === " " || c === "	" || c === "\r" || c === "\n";
};
const isDigit = (c) => {
  const codePoint = c.codePointAt(0);
  if (codePoint == null) {
    return false;
  }
  return 48 <= codePoint && codePoint <= 57;
};
const readNumber = (string, cursor) => {
  let i = cursor;
  let value2 = "";
  let state = "none";
  for (; i < string.length; i += 1) {
    const c = string[i];
    if (c === "+" || c === "-") {
      if (state === "none") {
        state = "sign";
        value2 += c;
        continue;
      }
      if (state === "e") {
        state = "exponent_sign";
        value2 += c;
        continue;
      }
    }
    if (isDigit(c)) {
      if (state === "none" || state === "sign" || state === "whole") {
        state = "whole";
        value2 += c;
        continue;
      }
      if (state === "decimal_point" || state === "decimal") {
        state = "decimal";
        value2 += c;
        continue;
      }
      if (state === "e" || state === "exponent_sign" || state === "exponent") {
        state = "exponent";
        value2 += c;
        continue;
      }
    }
    if (c === ".") {
      if (state === "none" || state === "sign" || state === "whole") {
        state = "decimal_point";
        value2 += c;
        continue;
      }
    }
    if (c === "E" || c == "e") {
      if (state === "whole" || state === "decimal_point" || state === "decimal") {
        state = "e";
        value2 += c;
        continue;
      }
    }
    break;
  }
  const number2 = Number.parseFloat(value2);
  if (Number.isNaN(number2)) {
    return [cursor, null];
  } else {
    return [i - 1, number2];
  }
};
const parsePathData = (string) => {
  const pathData = [];
  let command = null;
  let args = (
    /** @type {number[]} */
    []
  );
  let argsCount = 0;
  let canHaveComma = false;
  let hadComma = false;
  for (let i = 0; i < string.length; i += 1) {
    const c = string.charAt(i);
    if (isWhiteSpace(c)) {
      continue;
    }
    if (canHaveComma && c === ",") {
      if (hadComma) {
        break;
      }
      hadComma = true;
      continue;
    }
    if (isCommand(c)) {
      if (hadComma) {
        return pathData;
      }
      if (command == null) {
        if (c !== "M" && c !== "m") {
          return pathData;
        }
      } else if (args.length !== 0) {
        return pathData;
      }
      command = c;
      args = [];
      argsCount = argsCountPerCommand[command];
      canHaveComma = false;
      if (argsCount === 0) {
        pathData.push({ command, args });
      }
      continue;
    }
    if (command == null) {
      return pathData;
    }
    let newCursor = i;
    let number2 = null;
    if (command === "A" || command === "a") {
      const position = args.length;
      if (position === 0 || position === 1) {
        if (c !== "+" && c !== "-") {
          [newCursor, number2] = readNumber(string, i);
        }
      }
      if (position === 2 || position === 5 || position === 6) {
        [newCursor, number2] = readNumber(string, i);
      }
      if (position === 3 || position === 4) {
        if (c === "0") {
          number2 = 0;
        }
        if (c === "1") {
          number2 = 1;
        }
      }
    } else {
      [newCursor, number2] = readNumber(string, i);
    }
    if (number2 == null) {
      return pathData;
    }
    args.push(number2);
    canHaveComma = true;
    hadComma = false;
    i = newCursor;
    if (args.length === argsCount) {
      pathData.push({ command, args });
      if (command === "M") {
        command = "L";
      }
      if (command === "m") {
        command = "l";
      }
      args = [];
    }
  }
  return pathData;
};
const roundAndStringify = (number2, precision2) => {
  if (precision2 != null) {
    number2 = toFixed(number2, precision2);
  }
  return {
    roundedStr: removeLeadingZero(number2),
    rounded: number2
  };
};
const stringifyArgs = (command, args, precision2, disableSpaceAfterFlags) => {
  let result = "";
  let previous;
  for (let i = 0; i < args.length; i++) {
    const { roundedStr, rounded } = roundAndStringify(args[i], precision2);
    if (disableSpaceAfterFlags && (command === "A" || command === "a") && // consider combined arcs
    (i % 7 === 4 || i % 7 === 5)) {
      result += roundedStr;
    } else if (i === 0 || rounded < 0) {
      result += roundedStr;
    } else if (!Number.isInteger(previous) && !isDigit(roundedStr[0])) {
      result += roundedStr;
    } else {
      result += ` ${roundedStr}`;
    }
    previous = rounded;
  }
  return result;
};
const stringifyPathData = ({
  pathData,
  precision: precision2,
  disableSpaceAfterFlags
}) => {
  if (pathData.length === 1) {
    const { command, args } = pathData[0];
    return command + stringifyArgs(command, args, precision2, disableSpaceAfterFlags);
  }
  let result = "";
  let prev = { ...pathData[0] };
  if (pathData[1].command === "L") {
    prev.command = "M";
  } else if (pathData[1].command === "l") {
    prev.command = "m";
  }
  for (let i = 1; i < pathData.length; i++) {
    const { command, args } = pathData[i];
    if (prev.command === command && prev.command !== "M" && prev.command !== "m" || // combine matching moveto and lineto sequences
    prev.command === "M" && command === "L" || prev.command === "m" && command === "l") {
      prev.args = [...prev.args, ...args];
      if (i === pathData.length - 1) {
        result += prev.command + stringifyArgs(
          prev.command,
          prev.args,
          precision2,
          disableSpaceAfterFlags
        );
      }
    } else {
      result += prev.command + stringifyArgs(
        prev.command,
        prev.args,
        precision2,
        disableSpaceAfterFlags
      );
      if (i === pathData.length - 1) {
        result += command + stringifyArgs(command, args, precision2, disableSpaceAfterFlags);
      } else {
        prev = { command, args };
      }
    }
  }
  return result;
};
const nonRendering = elemsGroups.nonRendering;
const name$y = "removeHiddenElems";
const description$y = "removes hidden elements (zero sized, with absent attributes)";
const fn$y = (root, params) => {
  const {
    isHidden = true,
    displayNone = true,
    opacity0 = true,
    circleR0 = true,
    ellipseRX0 = true,
    ellipseRY0 = true,
    rectWidth0 = true,
    rectHeight0 = true,
    patternWidth0 = true,
    patternHeight0 = true,
    imageWidth0 = true,
    imageHeight0 = true,
    pathEmptyD = true,
    polylineEmptyPoints = true,
    polygonEmptyPoints = true
  } = params;
  const stylesheet = collectStylesheet(root);
  const nonRenderedNodes = /* @__PURE__ */ new Map();
  const removedDefIds = /* @__PURE__ */ new Set();
  const allDefs = /* @__PURE__ */ new Map();
  const allReferences = /* @__PURE__ */ new Set();
  const referencesById = /* @__PURE__ */ new Map();
  let deoptimized = false;
  function canRemoveNonRenderingNode(node2) {
    if (allReferences.has(node2.attributes.id)) {
      return false;
    }
    for (const child of node2.children) {
      if (child.type === "element" && !canRemoveNonRenderingNode(child)) {
        return false;
      }
    }
    return true;
  }
  function removeElement2(node2, parentNode) {
    if (node2.type === "element" && node2.attributes.id != null && parentNode.type === "element" && parentNode.name === "defs") {
      removedDefIds.add(node2.attributes.id);
    }
    detachNodeFromParent(node2, parentNode);
  }
  visit(root, {
    element: {
      enter: (node2, parentNode) => {
        if (nonRendering.has(node2.name)) {
          nonRenderedNodes.set(node2, parentNode);
          return visitSkip;
        }
        const computedStyle = computeStyle(stylesheet, node2);
        if (opacity0 && computedStyle.opacity && computedStyle.opacity.type === "static" && computedStyle.opacity.value === "0") {
          if (node2.name === "path") {
            nonRenderedNodes.set(node2, parentNode);
            return visitSkip;
          }
          removeElement2(node2, parentNode);
        }
      }
    }
  });
  return {
    element: {
      enter: (node2, parentNode) => {
        if (node2.name === "style" && node2.children.length !== 0 || hasScripts(node2)) {
          deoptimized = true;
          return;
        }
        if (node2.name === "defs") {
          allDefs.set(node2, parentNode);
        }
        if (node2.name === "use") {
          for (const attr of Object.keys(node2.attributes)) {
            if (attr !== "href" && !attr.endsWith(":href")) {
              continue;
            }
            const value2 = node2.attributes[attr];
            const id = value2.slice(1);
            let refs = referencesById.get(id);
            if (!refs) {
              refs = [];
              referencesById.set(id, refs);
            }
            refs.push({ node: node2, parentNode });
          }
        }
        const computedStyle = computeStyle(stylesheet, node2);
        if (isHidden && computedStyle.visibility && computedStyle.visibility.type === "static" && computedStyle.visibility.value === "hidden" && // keep if any descendant enables visibility
        querySelector(node2, "[visibility=visible]") == null) {
          removeElement2(node2, parentNode);
          return;
        }
        if (displayNone && computedStyle.display && computedStyle.display.type === "static" && computedStyle.display.value === "none" && // markers with display: none still rendered
        node2.name !== "marker") {
          removeElement2(node2, parentNode);
          return;
        }
        if (circleR0 && node2.name === "circle" && node2.children.length === 0 && node2.attributes.r === "0") {
          removeElement2(node2, parentNode);
          return;
        }
        if (ellipseRX0 && node2.name === "ellipse" && node2.children.length === 0 && node2.attributes.rx === "0") {
          removeElement2(node2, parentNode);
          return;
        }
        if (ellipseRY0 && node2.name === "ellipse" && node2.children.length === 0 && node2.attributes.ry === "0") {
          removeElement2(node2, parentNode);
          return;
        }
        if (rectWidth0 && node2.name === "rect" && node2.children.length === 0 && node2.attributes.width === "0") {
          removeElement2(node2, parentNode);
          return;
        }
        if (rectHeight0 && rectWidth0 && node2.name === "rect" && node2.children.length === 0 && node2.attributes.height === "0") {
          removeElement2(node2, parentNode);
          return;
        }
        if (patternWidth0 && node2.name === "pattern" && node2.attributes.width === "0") {
          removeElement2(node2, parentNode);
          return;
        }
        if (patternHeight0 && node2.name === "pattern" && node2.attributes.height === "0") {
          removeElement2(node2, parentNode);
          return;
        }
        if (imageWidth0 && node2.name === "image" && node2.attributes.width === "0") {
          removeElement2(node2, parentNode);
          return;
        }
        if (imageHeight0 && node2.name === "image" && node2.attributes.height === "0") {
          removeElement2(node2, parentNode);
          return;
        }
        if (pathEmptyD && node2.name === "path") {
          if (node2.attributes.d == null) {
            removeElement2(node2, parentNode);
            return;
          }
          const pathData = parsePathData(node2.attributes.d);
          if (pathData.length === 0) {
            removeElement2(node2, parentNode);
            return;
          }
          if (pathData.length === 1 && computedStyle["marker-start"] == null && computedStyle["marker-end"] == null) {
            removeElement2(node2, parentNode);
            return;
          }
        }
        if (polylineEmptyPoints && node2.name === "polyline" && node2.attributes.points == null) {
          removeElement2(node2, parentNode);
          return;
        }
        if (polygonEmptyPoints && node2.name === "polygon" && node2.attributes.points == null) {
          removeElement2(node2, parentNode);
          return;
        }
        for (const [name2, value2] of Object.entries(node2.attributes)) {
          const ids = findReferences(name2, value2);
          for (const id of ids) {
            allReferences.add(id);
          }
        }
      }
    },
    root: {
      exit: () => {
        for (const id of removedDefIds) {
          const refs = referencesById.get(id);
          if (refs) {
            for (const { node: node2, parentNode } of refs) {
              detachNodeFromParent(node2, parentNode);
            }
          }
        }
        if (!deoptimized) {
          for (const [
            nonRenderedNode,
            nonRenderedParent
          ] of nonRenderedNodes.entries()) {
            if (canRemoveNonRenderingNode(nonRenderedNode)) {
              detachNodeFromParent(nonRenderedNode, nonRenderedParent);
            }
          }
        }
        for (const [node2, parentNode] of allDefs.entries()) {
          if (node2.children.length === 0) {
            detachNodeFromParent(node2, parentNode);
          }
        }
      }
    }
  };
};
const removeHiddenElems = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$y,
  fn: fn$y,
  name: name$y
}, Symbol.toStringTag, { value: "Module" }));
const name$x = "removeEmptyText";
const description$x = "removes empty <text> elements";
const fn$x = (root, params) => {
  const { text = true, tspan = true, tref = true } = params;
  return {
    element: {
      enter: (node2, parentNode) => {
        if (text && node2.name === "text" && node2.children.length === 0) {
          detachNodeFromParent(node2, parentNode);
        }
        if (tspan && node2.name === "tspan" && node2.children.length === 0) {
          detachNodeFromParent(node2, parentNode);
        }
        if (tref && node2.name === "tref" && node2.attributes["xlink:href"] == null) {
          detachNodeFromParent(node2, parentNode);
        }
      }
    }
  };
};
const removeEmptyText = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$x,
  fn: fn$x,
  name: name$x
}, Symbol.toStringTag, { value: "Module" }));
const name$w = "convertShapeToPath";
const description$w = "converts basic shapes to more compact path form";
const regNumber = /[-+]?(?:\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;
const fn$w = (root, params) => {
  const { convertArcs = false, floatPrecision: precision2 } = params;
  return {
    element: {
      enter: (node2, parentNode) => {
        if (node2.name === "rect" && node2.attributes.width != null && node2.attributes.height != null && node2.attributes.rx == null && node2.attributes.ry == null) {
          const x = Number(node2.attributes.x || "0");
          const y = Number(node2.attributes.y || "0");
          const width = Number(node2.attributes.width);
          const height = Number(node2.attributes.height);
          if (Number.isNaN(x - y + width - height)) {
            return;
          }
          const pathData = [
            { command: "M", args: [x, y] },
            { command: "H", args: [x + width] },
            { command: "V", args: [y + height] },
            { command: "H", args: [x] },
            { command: "z", args: [] }
          ];
          node2.name = "path";
          node2.attributes.d = stringifyPathData({ pathData, precision: precision2 });
          delete node2.attributes.x;
          delete node2.attributes.y;
          delete node2.attributes.width;
          delete node2.attributes.height;
        }
        if (node2.name === "line") {
          const x1 = Number(node2.attributes.x1 || "0");
          const y1 = Number(node2.attributes.y1 || "0");
          const x2 = Number(node2.attributes.x2 || "0");
          const y2 = Number(node2.attributes.y2 || "0");
          if (Number.isNaN(x1 - y1 + x2 - y2)) {
            return;
          }
          const pathData = [
            { command: "M", args: [x1, y1] },
            { command: "L", args: [x2, y2] }
          ];
          node2.name = "path";
          node2.attributes.d = stringifyPathData({ pathData, precision: precision2 });
          delete node2.attributes.x1;
          delete node2.attributes.y1;
          delete node2.attributes.x2;
          delete node2.attributes.y2;
        }
        if ((node2.name === "polyline" || node2.name === "polygon") && node2.attributes.points != null) {
          const coords = (node2.attributes.points.match(regNumber) || []).map(
            Number
          );
          if (coords.length < 4) {
            detachNodeFromParent(node2, parentNode);
            return;
          }
          const pathData = [];
          for (let i = 0; i < coords.length; i += 2) {
            pathData.push({
              command: i === 0 ? "M" : "L",
              args: coords.slice(i, i + 2)
            });
          }
          if (node2.name === "polygon") {
            pathData.push({ command: "z", args: [] });
          }
          node2.name = "path";
          node2.attributes.d = stringifyPathData({ pathData, precision: precision2 });
          delete node2.attributes.points;
        }
        if (node2.name === "circle" && convertArcs) {
          const cx = Number(node2.attributes.cx || "0");
          const cy = Number(node2.attributes.cy || "0");
          const r = Number(node2.attributes.r || "0");
          if (Number.isNaN(cx - cy + r)) {
            return;
          }
          const pathData = [
            { command: "M", args: [cx, cy - r] },
            { command: "A", args: [r, r, 0, 1, 0, cx, cy + r] },
            { command: "A", args: [r, r, 0, 1, 0, cx, cy - r] },
            { command: "z", args: [] }
          ];
          node2.name = "path";
          node2.attributes.d = stringifyPathData({ pathData, precision: precision2 });
          delete node2.attributes.cx;
          delete node2.attributes.cy;
          delete node2.attributes.r;
        }
        if (node2.name === "ellipse" && convertArcs) {
          const ecx = Number(node2.attributes.cx || "0");
          const ecy = Number(node2.attributes.cy || "0");
          const rx = Number(node2.attributes.rx || "0");
          const ry = Number(node2.attributes.ry || "0");
          if (Number.isNaN(ecx - ecy + rx - ry)) {
            return;
          }
          const pathData = [
            { command: "M", args: [ecx, ecy - ry] },
            { command: "A", args: [rx, ry, 0, 1, 0, ecx, ecy + ry] },
            { command: "A", args: [rx, ry, 0, 1, 0, ecx, ecy - ry] },
            { command: "z", args: [] }
          ];
          node2.name = "path";
          node2.attributes.d = stringifyPathData({ pathData, precision: precision2 });
          delete node2.attributes.cx;
          delete node2.attributes.cy;
          delete node2.attributes.rx;
          delete node2.attributes.ry;
        }
      }
    }
  };
};
const convertShapeToPath = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$w,
  fn: fn$w,
  name: name$w
}, Symbol.toStringTag, { value: "Module" }));
const name$v = "convertEllipseToCircle";
const description$v = "converts non-eccentric <ellipse>s to <circle>s";
const fn$v = () => {
  return {
    element: {
      enter: (node2) => {
        if (node2.name === "ellipse") {
          const rx = node2.attributes.rx || "0";
          const ry = node2.attributes.ry || "0";
          if (rx === ry || rx === "auto" || ry === "auto") {
            node2.name = "circle";
            const radius = rx === "auto" ? ry : rx;
            delete node2.attributes.rx;
            delete node2.attributes.ry;
            node2.attributes.r = radius;
          }
        }
      }
    }
  };
};
const convertEllipseToCircle = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$v,
  fn: fn$v,
  name: name$v
}, Symbol.toStringTag, { value: "Module" }));
const name$u = "moveElemsAttrsToGroup";
const description$u = "Move common attributes of group children to the group";
const fn$u = (root) => {
  let deoptimizedWithStyles = false;
  visit(root, {
    element: {
      enter: (node2) => {
        if (node2.name === "style") {
          deoptimizedWithStyles = true;
        }
      }
    }
  });
  return {
    element: {
      exit: (node2) => {
        if (node2.name !== "g" || node2.children.length <= 1) {
          return;
        }
        if (deoptimizedWithStyles) {
          return;
        }
        const commonAttributes = /* @__PURE__ */ new Map();
        let initial = true;
        let everyChildIsPath = true;
        for (const child of node2.children) {
          if (child.type === "element") {
            if (!pathElems.has(child.name)) {
              everyChildIsPath = false;
            }
            if (initial) {
              initial = false;
              for (const [name2, value2] of Object.entries(child.attributes)) {
                if (inheritableAttrs.has(name2)) {
                  commonAttributes.set(name2, value2);
                }
              }
            } else {
              for (const [name2, value2] of commonAttributes) {
                if (child.attributes[name2] !== value2) {
                  commonAttributes.delete(name2);
                }
              }
            }
          }
        }
        if (node2.attributes["filter"] != null || node2.attributes["clip-path"] != null || node2.attributes.mask != null) {
          commonAttributes.delete("transform");
        }
        if (everyChildIsPath) {
          commonAttributes.delete("transform");
        }
        for (const [name2, value2] of commonAttributes) {
          if (name2 === "transform") {
            if (node2.attributes.transform != null) {
              node2.attributes.transform = `${node2.attributes.transform} ${value2}`;
            } else {
              node2.attributes.transform = value2;
            }
          } else {
            node2.attributes[name2] = value2;
          }
        }
        for (const child of node2.children) {
          if (child.type === "element") {
            for (const [name2] of commonAttributes) {
              delete child.attributes[name2];
            }
          }
        }
      }
    }
  };
};
const moveElemsAttrsToGroup = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$u,
  fn: fn$u,
  name: name$u
}, Symbol.toStringTag, { value: "Module" }));
const name$t = "moveGroupAttrsToElems";
const description$t = "moves some group attributes to the content elements";
const pathElemsWithGroupsAndText = [...pathElems, "g", "text"];
const fn$t = () => {
  return {
    element: {
      enter: (node2) => {
        if (node2.name === "g" && node2.children.length !== 0 && node2.attributes.transform != null && Object.entries(node2.attributes).some(
          ([name2, value2]) => referencesProps.has(name2) && includesUrlReference(value2)
        ) === false && node2.children.every(
          (child) => child.type === "element" && pathElemsWithGroupsAndText.includes(child.name) && child.attributes.id == null
        )) {
          for (const child of node2.children) {
            const value2 = node2.attributes.transform;
            if (child.type === "element") {
              if (child.attributes.transform != null) {
                child.attributes.transform = `${value2} ${child.attributes.transform}`;
              } else {
                child.attributes.transform = value2;
              }
            }
          }
          delete node2.attributes.transform;
        }
      }
    }
  };
};
const moveGroupAttrsToElems = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$t,
  fn: fn$t,
  name: name$t
}, Symbol.toStringTag, { value: "Module" }));
const name$s = "collapseGroups";
const description$s = "collapses useless groups";
const hasAnimatedAttr = (node2, name2) => {
  if (node2.type === "element") {
    if (elemsGroups.animation.has(node2.name) && node2.attributes.attributeName === name2) {
      return true;
    }
    for (const child of node2.children) {
      if (hasAnimatedAttr(child, name2)) {
        return true;
      }
    }
  }
  return false;
};
const fn$s = (root) => {
  const stylesheet = collectStylesheet(root);
  return {
    element: {
      exit: (node2, parentNode) => {
        if (parentNode.type === "root" || parentNode.name === "switch") {
          return;
        }
        if (node2.name !== "g" || node2.children.length === 0) {
          return;
        }
        if (Object.keys(node2.attributes).length !== 0 && node2.children.length === 1) {
          const firstChild = node2.children[0];
          const nodeHasFilter = !!(node2.attributes.filter || computeStyle(stylesheet, node2).filter);
          if (firstChild.type === "element" && firstChild.attributes.id == null && !nodeHasFilter && (node2.attributes.class == null || firstChild.attributes.class == null) && (node2.attributes["clip-path"] == null && node2.attributes.mask == null || firstChild.name === "g" && node2.attributes.transform == null && firstChild.attributes.transform == null)) {
            const newChildElemAttrs = { ...firstChild.attributes };
            for (const [name2, value2] of Object.entries(node2.attributes)) {
              if (hasAnimatedAttr(firstChild, name2)) {
                return;
              }
              if (newChildElemAttrs[name2] == null) {
                newChildElemAttrs[name2] = value2;
              } else if (name2 === "transform") {
                newChildElemAttrs[name2] = value2 + " " + newChildElemAttrs[name2];
              } else if (newChildElemAttrs[name2] === "inherit") {
                newChildElemAttrs[name2] = value2;
              } else if (!inheritableAttrs.has(name2) && newChildElemAttrs[name2] !== value2) {
                return;
              }
            }
            node2.attributes = {};
            firstChild.attributes = newChildElemAttrs;
          }
        }
        if (Object.keys(node2.attributes).length === 0) {
          for (const child of node2.children) {
            if (child.type === "element" && elemsGroups.animation.has(child.name)) {
              return;
            }
          }
          const index = parentNode.children.indexOf(node2);
          parentNode.children.splice(index, 1, ...node2.children);
        }
      }
    }
  };
};
const collapseGroups = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$s,
  fn: fn$s,
  name: name$s
}, Symbol.toStringTag, { value: "Module" }));
let prevCtrlPoint;
const path2js = (path) => {
  if (path.pathJS) {
    return path.pathJS;
  }
  const pathData = [];
  const newPathData = parsePathData(path.attributes.d);
  for (const { command, args } of newPathData) {
    pathData.push({ command, args });
  }
  if (pathData.length && pathData[0].command == "m") {
    pathData[0].command = "M";
  }
  path.pathJS = pathData;
  return pathData;
};
const convertRelativeToAbsolute = (data) => {
  const newData = [];
  const start = [0, 0];
  const cursor = [0, 0];
  for (let { command, args } of data) {
    args = args.slice();
    if (command === "m") {
      args[0] += cursor[0];
      args[1] += cursor[1];
      command = "M";
    }
    if (command === "M") {
      cursor[0] = args[0];
      cursor[1] = args[1];
      start[0] = cursor[0];
      start[1] = cursor[1];
    }
    if (command === "h") {
      args[0] += cursor[0];
      command = "H";
    }
    if (command === "H") {
      cursor[0] = args[0];
    }
    if (command === "v") {
      args[0] += cursor[1];
      command = "V";
    }
    if (command === "V") {
      cursor[1] = args[0];
    }
    if (command === "l") {
      args[0] += cursor[0];
      args[1] += cursor[1];
      command = "L";
    }
    if (command === "L") {
      cursor[0] = args[0];
      cursor[1] = args[1];
    }
    if (command === "c") {
      args[0] += cursor[0];
      args[1] += cursor[1];
      args[2] += cursor[0];
      args[3] += cursor[1];
      args[4] += cursor[0];
      args[5] += cursor[1];
      command = "C";
    }
    if (command === "C") {
      cursor[0] = args[4];
      cursor[1] = args[5];
    }
    if (command === "s") {
      args[0] += cursor[0];
      args[1] += cursor[1];
      args[2] += cursor[0];
      args[3] += cursor[1];
      command = "S";
    }
    if (command === "S") {
      cursor[0] = args[2];
      cursor[1] = args[3];
    }
    if (command === "q") {
      args[0] += cursor[0];
      args[1] += cursor[1];
      args[2] += cursor[0];
      args[3] += cursor[1];
      command = "Q";
    }
    if (command === "Q") {
      cursor[0] = args[2];
      cursor[1] = args[3];
    }
    if (command === "t") {
      args[0] += cursor[0];
      args[1] += cursor[1];
      command = "T";
    }
    if (command === "T") {
      cursor[0] = args[0];
      cursor[1] = args[1];
    }
    if (command === "a") {
      args[5] += cursor[0];
      args[6] += cursor[1];
      command = "A";
    }
    if (command === "A") {
      cursor[0] = args[5];
      cursor[1] = args[6];
    }
    if (command === "z" || command === "Z") {
      cursor[0] = start[0];
      cursor[1] = start[1];
      command = "z";
    }
    newData.push({ command, args });
  }
  return newData;
};
const js2path = function(path, data, params) {
  path.pathJS = data;
  const pathData = [];
  for (const item of data) {
    if (pathData.length !== 0 && (item.command === "M" || item.command === "m")) {
      const last = pathData[pathData.length - 1];
      if (last.command === "M" || last.command === "m") {
        pathData.pop();
      }
    }
    pathData.push({
      command: item.command,
      args: item.args
    });
  }
  path.attributes.d = stringifyPathData({
    pathData,
    precision: params.floatPrecision,
    disableSpaceAfterFlags: params.noSpaceAfterFlags
  });
};
function set(dest, source) {
  dest[0] = source[source.length - 2];
  dest[1] = source[source.length - 1];
  return dest;
}
const intersects = function(path1, path2) {
  const points1 = gatherPoints(convertRelativeToAbsolute(path1));
  const points2 = gatherPoints(convertRelativeToAbsolute(path2));
  if (points1.maxX <= points2.minX || points2.maxX <= points1.minX || points1.maxY <= points2.minY || points2.maxY <= points1.minY || points1.list.every((set1) => {
    return points2.list.every((set2) => {
      return set1.list[set1.maxX][0] <= set2.list[set2.minX][0] || set2.list[set2.maxX][0] <= set1.list[set1.minX][0] || set1.list[set1.maxY][1] <= set2.list[set2.minY][1] || set2.list[set2.maxY][1] <= set1.list[set1.minY][1];
    });
  })) {
    return false;
  }
  const hullNest1 = points1.list.map(convexHull);
  const hullNest2 = points2.list.map(convexHull);
  return hullNest1.some(function(hull1) {
    if (hull1.list.length < 3) {
      return false;
    }
    return hullNest2.some(function(hull2) {
      if (hull2.list.length < 3) {
        return false;
      }
      const simplex = [getSupport2(hull1, hull2, [1, 0])];
      const direction = minus(simplex[0]);
      let iterations = 1e4;
      while (true) {
        if (iterations-- == 0) {
          console.error(
            "Error: infinite loop while processing mergePaths plugin."
          );
          return true;
        }
        simplex.push(getSupport2(hull1, hull2, direction));
        if (dot(direction, simplex[simplex.length - 1]) <= 0) {
          return false;
        }
        if (processSimplex(simplex, direction)) {
          return true;
        }
      }
    });
  });
  function getSupport2(a, b, direction) {
    return sub(supportPoint(a, direction), supportPoint(b, minus(direction)));
  }
  function supportPoint(polygon, direction) {
    let index = direction[1] >= 0 ? direction[0] < 0 ? polygon.maxY : polygon.maxX : direction[0] < 0 ? polygon.minX : polygon.minY;
    let max = -Infinity;
    let value2;
    while ((value2 = dot(polygon.list[index], direction)) > max) {
      max = value2;
      index = ++index % polygon.list.length;
    }
    return polygon.list[(index || polygon.list.length) - 1];
  }
};
function processSimplex(simplex, direction) {
  if (simplex.length == 2) {
    const a = simplex[1];
    const b = simplex[0];
    const AO = minus(simplex[1]);
    const AB = sub(b, a);
    if (dot(AO, AB) > 0) {
      set(direction, orth(AB, a));
    } else {
      set(direction, AO);
      simplex.shift();
    }
  } else {
    const a = simplex[2];
    const b = simplex[1];
    const c = simplex[0];
    const AB = sub(b, a);
    const AC = sub(c, a);
    const AO = minus(a);
    const ACB = orth(AB, AC);
    const ABC = orth(AC, AB);
    if (dot(ACB, AO) > 0) {
      if (dot(AB, AO) > 0) {
        set(direction, ACB);
        simplex.shift();
      } else {
        set(direction, AO);
        simplex.splice(0, 2);
      }
    } else if (dot(ABC, AO) > 0) {
      if (dot(AC, AO) > 0) {
        set(direction, ABC);
        simplex.splice(1, 1);
      } else {
        set(direction, AO);
        simplex.splice(0, 2);
      }
    } else {
      return true;
    }
  }
  return false;
}
function minus(v) {
  return [-v[0], -v[1]];
}
function sub(v1, v2) {
  return [v1[0] - v2[0], v1[1] - v2[1]];
}
function dot(v1, v2) {
  return v1[0] * v2[0] + v1[1] * v2[1];
}
function orth(v, from) {
  const o = [-v[1], v[0]];
  return dot(o, minus(from)) < 0 ? minus(o) : o;
}
function gatherPoints(pathData) {
  const points = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 };
  const addPoint = (path, point) => {
    if (!path.list.length || point[1] > path.list[path.maxY][1]) {
      path.maxY = path.list.length;
      points.maxY = points.list.length ? Math.max(point[1], points.maxY) : point[1];
    }
    if (!path.list.length || point[0] > path.list[path.maxX][0]) {
      path.maxX = path.list.length;
      points.maxX = points.list.length ? Math.max(point[0], points.maxX) : point[0];
    }
    if (!path.list.length || point[1] < path.list[path.minY][1]) {
      path.minY = path.list.length;
      points.minY = points.list.length ? Math.min(point[1], points.minY) : point[1];
    }
    if (!path.list.length || point[0] < path.list[path.minX][0]) {
      path.minX = path.list.length;
      points.minX = points.list.length ? Math.min(point[0], points.minX) : point[0];
    }
    path.list.push(point);
  };
  for (let i = 0; i < pathData.length; i += 1) {
    const pathDataItem = pathData[i];
    let subPath = points.list.length === 0 ? { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 } : points.list[points.list.length - 1];
    const prev = i === 0 ? null : pathData[i - 1];
    let basePoint = subPath.list.length === 0 ? null : subPath.list[subPath.list.length - 1];
    const data = pathDataItem.args;
    let ctrlPoint = basePoint;
    const toAbsolute = (n, i2) => n + (basePoint == null ? 0 : basePoint[i2 % 2]);
    switch (pathDataItem.command) {
      case "M":
        subPath = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 };
        points.list.push(subPath);
        break;
      case "H":
        if (basePoint != null) {
          addPoint(subPath, [data[0], basePoint[1]]);
        }
        break;
      case "V":
        if (basePoint != null) {
          addPoint(subPath, [basePoint[0], data[0]]);
        }
        break;
      case "Q":
        addPoint(subPath, data.slice(0, 2));
        prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];
        break;
      case "T":
        if (basePoint != null && prev != null && (prev.command == "Q" || prev.command == "T")) {
          ctrlPoint = [
            basePoint[0] + prevCtrlPoint[0],
            basePoint[1] + prevCtrlPoint[1]
          ];
          addPoint(subPath, ctrlPoint);
          prevCtrlPoint = [data[0] - ctrlPoint[0], data[1] - ctrlPoint[1]];
        }
        break;
      case "C":
        if (basePoint != null) {
          addPoint(subPath, [
            0.5 * (basePoint[0] + data[0]),
            0.5 * (basePoint[1] + data[1])
          ]);
        }
        addPoint(subPath, [
          0.5 * (data[0] + data[2]),
          0.5 * (data[1] + data[3])
        ]);
        addPoint(subPath, [
          0.5 * (data[2] + data[4]),
          0.5 * (data[3] + data[5])
        ]);
        prevCtrlPoint = [data[4] - data[2], data[5] - data[3]];
        break;
      case "S":
        if (basePoint != null && prev != null && (prev.command == "C" || prev.command == "S")) {
          addPoint(subPath, [
            basePoint[0] + 0.5 * prevCtrlPoint[0],
            basePoint[1] + 0.5 * prevCtrlPoint[1]
          ]);
          ctrlPoint = [
            basePoint[0] + prevCtrlPoint[0],
            basePoint[1] + prevCtrlPoint[1]
          ];
        }
        if (ctrlPoint != null) {
          addPoint(subPath, [
            0.5 * (ctrlPoint[0] + data[0]),
            0.5 * (ctrlPoint[1] + data[1])
          ]);
        }
        addPoint(subPath, [
          0.5 * (data[0] + data[2]),
          0.5 * (data[1] + data[3])
        ]);
        prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];
        break;
      case "A":
        if (basePoint != null) {
          const curves = a2c.apply(0, basePoint.concat(data));
          for (var cData; (cData = curves.splice(0, 6).map(toAbsolute)).length; ) {
            if (basePoint != null) {
              addPoint(subPath, [
                0.5 * (basePoint[0] + cData[0]),
                0.5 * (basePoint[1] + cData[1])
              ]);
            }
            addPoint(subPath, [
              0.5 * (cData[0] + cData[2]),
              0.5 * (cData[1] + cData[3])
            ]);
            addPoint(subPath, [
              0.5 * (cData[2] + cData[4]),
              0.5 * (cData[3] + cData[5])
            ]);
            if (curves.length) {
              addPoint(subPath, basePoint = cData.slice(-2));
            }
          }
        }
        break;
    }
    if (data.length >= 2) {
      addPoint(subPath, data.slice(-2));
    }
  }
  return points;
}
function convexHull(points) {
  points.list.sort(function(a, b) {
    return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];
  });
  const lower = [];
  let minY = 0;
  let bottom = 0;
  for (let i = 0; i < points.list.length; i++) {
    while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points.list[i]) <= 0) {
      lower.pop();
    }
    if (points.list[i][1] < points.list[minY][1]) {
      minY = i;
      bottom = lower.length;
    }
    lower.push(points.list[i]);
  }
  const upper = [];
  let maxY = points.list.length - 1;
  let top = 0;
  for (let i = points.list.length; i--; ) {
    while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points.list[i]) <= 0) {
      upper.pop();
    }
    if (points.list[i][1] > points.list[maxY][1]) {
      maxY = i;
      top = upper.length;
    }
    upper.push(points.list[i]);
  }
  upper.pop();
  lower.pop();
  const hullList = lower.concat(upper);
  const hull = {
    list: hullList,
    minX: 0,
    // by sorting
    maxX: lower.length,
    minY: bottom,
    maxY: (lower.length + top) % hullList.length
  };
  return hull;
}
function cross(o, a, b) {
  return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
}
const a2c = (x1, y1, rx, ry, angle2, large_arc_flag, sweep_flag, x2, y2, recursive) => {
  const _120 = Math.PI * 120 / 180;
  const rad = Math.PI / 180 * (+angle2 || 0);
  let res = [];
  const rotateX = (x, y, rad2) => {
    return x * Math.cos(rad2) - y * Math.sin(rad2);
  };
  const rotateY = (x, y, rad2) => {
    return x * Math.sin(rad2) + y * Math.cos(rad2);
  };
  if (!recursive) {
    x1 = rotateX(x1, y1, -rad);
    y1 = rotateY(x1, y1, -rad);
    x2 = rotateX(x2, y2, -rad);
    y2 = rotateY(x2, y2, -rad);
    const x = (x1 - x2) / 2;
    const y = (y1 - y2) / 2;
    let h = x * x / (rx * rx) + y * y / (ry * ry);
    if (h > 1) {
      h = Math.sqrt(h);
      rx = h * rx;
      ry = h * ry;
    }
    const rx2 = rx * rx;
    const ry2 = ry * ry;
    const k = (large_arc_flag == sweep_flag ? -1 : 1) * Math.sqrt(
      Math.abs(
        (rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)
      )
    );
    var cx = k * rx * y / ry + (x1 + x2) / 2;
    var cy = k * -ry * x / rx + (y1 + y2) / 2;
    var f1 = Math.asin(Number(((y1 - cy) / ry).toFixed(9)));
    var f2 = Math.asin(Number(((y2 - cy) / ry).toFixed(9)));
    f1 = x1 < cx ? Math.PI - f1 : f1;
    f2 = x2 < cx ? Math.PI - f2 : f2;
    f1 < 0 && (f1 = Math.PI * 2 + f1);
    f2 < 0 && (f2 = Math.PI * 2 + f2);
    if (sweep_flag && f1 > f2) {
      f1 = f1 - Math.PI * 2;
    }
    if (!sweep_flag && f2 > f1) {
      f2 = f2 - Math.PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }
  let df = f2 - f1;
  if (Math.abs(df) > _120) {
    const f2old = f2;
    const x2old = x2;
    const y2old = y2;
    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * Math.cos(f2);
    y2 = cy + ry * Math.sin(f2);
    res = a2c(x2, y2, rx, ry, angle2, 0, sweep_flag, x2old, y2old, [
      f2,
      f2old,
      cx,
      cy
    ]);
  }
  df = f2 - f1;
  const c1 = Math.cos(f1);
  const s1 = Math.sin(f1);
  const c2 = Math.cos(f2);
  const s2 = Math.sin(f2);
  const t = Math.tan(df / 4);
  const hx = 4 / 3 * rx * t;
  const hy = 4 / 3 * ry * t;
  const m = [
    -hx * s1,
    hy * c1,
    x2 + hx * s2 - x1,
    y2 - hy * c2 - y1,
    x2 - x1,
    y2 - y1
  ];
  if (recursive) {
    return m.concat(res);
  } else {
    res = m.concat(res);
    const newres = [];
    for (let i = 0, n = res.length; i < n; i++) {
      newres[i] = i % 2 ? rotateY(res[i - 1], res[i], rad) : rotateX(res[i], res[i + 1], rad);
    }
    return newres;
  }
};
const transformTypes = /* @__PURE__ */ new Set([
  "matrix",
  "rotate",
  "scale",
  "skewX",
  "skewY",
  "translate"
]);
const regTransformSplit = /\s*(matrix|translate|scale|rotate|skewX|skewY)\s*\(\s*(.+?)\s*\)[\s,]*/;
const regNumericValues$2 = /[-+]?(?:\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;
const transform2js = (transformString) => {
  const transforms = [];
  let currentTransform = null;
  for (const item of transformString.split(regTransformSplit)) {
    if (!item) {
      continue;
    }
    if (transformTypes.has(item)) {
      currentTransform = { name: item, data: [] };
      transforms.push(currentTransform);
    } else {
      let num;
      while (num = regNumericValues$2.exec(item)) {
        num = Number(num);
        if (currentTransform != null) {
          currentTransform.data.push(num);
        }
      }
    }
  }
  return currentTransform == null || currentTransform.data.length == 0 ? [] : transforms;
};
const transformsMultiply = (transforms) => {
  const matrixData = transforms.map((transform) => {
    if (transform.name === "matrix") {
      return transform.data;
    }
    return transformToMatrix(transform);
  });
  const matrixTransform = {
    name: "matrix",
    data: matrixData.length > 0 ? matrixData.reduce(multiplyTransformMatrices) : []
  };
  return matrixTransform;
};
const mth = {
  /**
   * @param {number} deg
   * @returns {number}
   */
  rad: (deg) => {
    return deg * Math.PI / 180;
  },
  /**
   * @param {number} rad
   * @returns {number}
   */
  deg: (rad) => {
    return rad * 180 / Math.PI;
  },
  /**
   * @param {number} deg
   * @returns {number}
   */
  cos: (deg) => {
    return Math.cos(mth.rad(deg));
  },
  /**
   * @param {number} val
   * @param {number} floatPrecision
   * @returns {number}
   */
  acos: (val, floatPrecision) => {
    return toFixed(mth.deg(Math.acos(val)), floatPrecision);
  },
  /**
   * @param {number} deg
   * @returns {number}
   */
  sin: (deg) => {
    return Math.sin(mth.rad(deg));
  },
  /**
   * @param {number} val
   * @param {number} floatPrecision
   * @returns {number}
   */
  asin: (val, floatPrecision) => {
    return toFixed(mth.deg(Math.asin(val)), floatPrecision);
  },
  /**
   * @param {number} deg
   * @returns {number}
   */
  tan: (deg) => {
    return Math.tan(mth.rad(deg));
  },
  /**
   * @param {number} val
   * @param {number} floatPrecision
   * @returns {number}
   */
  atan: (val, floatPrecision) => {
    return toFixed(mth.deg(Math.atan(val)), floatPrecision);
  }
};
const getDecompositions = (matrix) => {
  const decompositions = [];
  const qrab = decomposeQRAB(matrix);
  const qrcd = decomposeQRCD(matrix);
  if (qrab) {
    decompositions.push(qrab);
  }
  if (qrcd) {
    decompositions.push(qrcd);
  }
  return decompositions;
};
const decomposeQRAB = (matrix) => {
  const data = matrix.data;
  const [a, b, c, d, e, f] = data;
  const delta = a * d - b * c;
  if (delta === 0) {
    return;
  }
  const r = Math.hypot(a, b);
  if (r === 0) {
    return;
  }
  const decomposition = [];
  const cosOfRotationAngle = a / r;
  if (e || f) {
    decomposition.push({
      name: "translate",
      data: [e, f]
    });
  }
  if (cosOfRotationAngle !== 1) {
    const rotationAngleRads = Math.acos(cosOfRotationAngle);
    decomposition.push({
      name: "rotate",
      data: [mth.deg(b < 0 ? -rotationAngleRads : rotationAngleRads), 0, 0]
    });
  }
  const sx = r;
  const sy = delta / sx;
  if (sx !== 1 || sy !== 1) {
    decomposition.push({ name: "scale", data: [sx, sy] });
  }
  const ac_plus_bd = a * c + b * d;
  if (ac_plus_bd) {
    decomposition.push({
      name: "skewX",
      data: [mth.deg(Math.atan(ac_plus_bd / (a * a + b * b)))]
    });
  }
  return decomposition;
};
const decomposeQRCD = (matrix) => {
  const data = matrix.data;
  const [a, b, c, d, e, f] = data;
  const delta = a * d - b * c;
  if (delta === 0) {
    return;
  }
  const s = Math.hypot(c, d);
  if (s === 0) {
    return;
  }
  const decomposition = [];
  if (e || f) {
    decomposition.push({
      name: "translate",
      data: [e, f]
    });
  }
  const rotationAngleRads = Math.PI / 2 - (d < 0 ? -1 : 1) * Math.acos(-c / s);
  decomposition.push({
    name: "rotate",
    data: [mth.deg(rotationAngleRads), 0, 0]
  });
  const sx = delta / s;
  const sy = s;
  if (sx !== 1 || sy !== 1) {
    decomposition.push({ name: "scale", data: [sx, sy] });
  }
  const ac_plus_bd = a * c + b * d;
  if (ac_plus_bd) {
    decomposition.push({
      name: "skewY",
      data: [mth.deg(Math.atan(ac_plus_bd / (c * c + d * d)))]
    });
  }
  return decomposition;
};
const mergeTranslateAndRotate = (tx, ty, a) => {
  const rotationAngleRads = mth.rad(a);
  const d = 1 - Math.cos(rotationAngleRads);
  const e = Math.sin(rotationAngleRads);
  const cy = (d * ty + e * tx) / (d * d + e * e);
  const cx = (tx - e * cy) / d;
  return { name: "rotate", data: [a, cx, cy] };
};
const isIdentityTransform = (t) => {
  switch (t.name) {
    case "rotate":
    case "skewX":
    case "skewY":
      return t.data[0] === 0;
    case "scale":
      return t.data[0] === 1 && t.data[1] === 1;
    case "translate":
      return t.data[0] === 0 && t.data[1] === 0;
  }
  return false;
};
const optimize = (roundedTransforms, rawTransforms) => {
  const optimizedTransforms = [];
  for (let index = 0; index < roundedTransforms.length; index++) {
    const roundedTransform = roundedTransforms[index];
    if (isIdentityTransform(roundedTransform)) {
      continue;
    }
    const data = roundedTransform.data;
    switch (roundedTransform.name) {
      case "rotate":
        switch (data[0]) {
          case 180:
          case -180:
            {
              const next = roundedTransforms[index + 1];
              if (next && next.name === "scale") {
                optimizedTransforms.push(
                  createScaleTransform(next.data.map((v) => -v))
                );
                index++;
              } else {
                optimizedTransforms.push({
                  name: "scale",
                  data: [-1]
                });
              }
            }
            continue;
        }
        optimizedTransforms.push({
          name: "rotate",
          data: data.slice(0, data[1] || data[2] ? 3 : 1)
        });
        break;
      case "scale":
        optimizedTransforms.push(createScaleTransform(data));
        break;
      case "skewX":
      case "skewY":
        optimizedTransforms.push({
          name: roundedTransform.name,
          data: [data[0]]
        });
        break;
      case "translate":
        {
          const next = roundedTransforms[index + 1];
          if (next && next.name === "rotate" && next.data[0] !== 180 && next.data[0] !== -180 && next.data[0] !== 0 && next.data[1] === 0 && next.data[2] === 0) {
            const data2 = rawTransforms[index].data;
            optimizedTransforms.push(
              mergeTranslateAndRotate(
                data2[0],
                data2[1],
                rawTransforms[index + 1].data[0]
              )
            );
            index++;
            continue;
          }
        }
        optimizedTransforms.push({
          name: "translate",
          data: data.slice(0, data[1] ? 2 : 1)
        });
        break;
    }
  }
  return optimizedTransforms.length ? optimizedTransforms : [{ name: "scale", data: [1] }];
};
const createScaleTransform = (data) => {
  const scaleData = data.slice(0, data[0] === data[1] ? 1 : 2);
  return {
    name: "scale",
    data: scaleData
  };
};
const matrixToTransform = (origMatrix, params) => {
  const decomposed = getDecompositions(origMatrix);
  let shortest;
  let shortestLen = Number.MAX_VALUE;
  for (const decomposition of decomposed) {
    const roundedTransforms = decomposition.map((transformItem) => {
      const transformCopy = {
        name: transformItem.name,
        data: [...transformItem.data]
      };
      return roundTransform(transformCopy, params);
    });
    const optimized = optimize(roundedTransforms, decomposition);
    const len = js2transform(optimized, params).length;
    if (len < shortestLen) {
      shortest = optimized;
      shortestLen = len;
    }
  }
  return shortest ?? [origMatrix];
};
const transformToMatrix = (transform) => {
  if (transform.name === "matrix") {
    return transform.data;
  }
  switch (transform.name) {
    case "translate":
      return [1, 0, 0, 1, transform.data[0], transform.data[1] || 0];
    case "scale":
      return [
        transform.data[0],
        0,
        0,
        transform.data[1] ?? transform.data[0],
        0,
        0
      ];
    case "rotate":
      var cos = mth.cos(transform.data[0]);
      var sin = mth.sin(transform.data[0]);
      var cx = transform.data[1] || 0;
      var cy = transform.data[2] || 0;
      return [
        cos,
        sin,
        -sin,
        cos,
        (1 - cos) * cx + sin * cy,
        (1 - cos) * cy - sin * cx
      ];
    case "skewX":
      return [1, 0, mth.tan(transform.data[0]), 1, 0, 0];
    case "skewY":
      return [1, mth.tan(transform.data[0]), 0, 1, 0, 0];
    default:
      throw Error(`Unknown transform ${transform.name}`);
  }
};
const transformArc = (cursor, arc, transform) => {
  const x = arc[5] - cursor[0];
  const y = arc[6] - cursor[1];
  let a = arc[0];
  let b = arc[1];
  const rot = arc[2] * Math.PI / 180;
  const cos = Math.cos(rot);
  const sin = Math.sin(rot);
  if (a > 0 && b > 0) {
    let h = Math.pow(x * cos + y * sin, 2) / (4 * a * a) + Math.pow(y * cos - x * sin, 2) / (4 * b * b);
    if (h > 1) {
      h = Math.sqrt(h);
      a *= h;
      b *= h;
    }
  }
  const ellipse = [a * cos, a * sin, -b * sin, b * cos, 0, 0];
  const m = multiplyTransformMatrices(transform, ellipse);
  const lastCol = m[2] * m[2] + m[3] * m[3];
  const squareSum = m[0] * m[0] + m[1] * m[1] + lastCol;
  const root = Math.hypot(m[0] - m[3], m[1] + m[2]) * Math.hypot(m[0] + m[3], m[1] - m[2]);
  if (!root) {
    arc[0] = arc[1] = Math.sqrt(squareSum / 2);
    arc[2] = 0;
  } else {
    const majorAxisSqr = (squareSum + root) / 2;
    const minorAxisSqr = (squareSum - root) / 2;
    const major = Math.abs(majorAxisSqr - lastCol) > 1e-6;
    const sub2 = (major ? majorAxisSqr : minorAxisSqr) - lastCol;
    const rowsSum = m[0] * m[2] + m[1] * m[3];
    const term1 = m[0] * sub2 + m[2] * rowsSum;
    const term2 = m[1] * sub2 + m[3] * rowsSum;
    arc[0] = Math.sqrt(majorAxisSqr);
    arc[1] = Math.sqrt(minorAxisSqr);
    arc[2] = ((major ? term2 < 0 : term1 > 0) ? -1 : 1) * Math.acos((major ? term1 : term2) / Math.hypot(term1, term2)) * 180 / Math.PI;
  }
  if (transform[0] < 0 !== transform[3] < 0) {
    arc[4] = 1 - arc[4];
  }
  return arc;
};
const multiplyTransformMatrices = (a, b) => {
  return [
    a[0] * b[0] + a[2] * b[1],
    a[1] * b[0] + a[3] * b[1],
    a[0] * b[2] + a[2] * b[3],
    a[1] * b[2] + a[3] * b[3],
    a[0] * b[4] + a[2] * b[5] + a[4],
    a[1] * b[4] + a[3] * b[5] + a[5]
  ];
};
const roundTransform = (transform, params) => {
  switch (transform.name) {
    case "translate":
      transform.data = floatRound(transform.data, params);
      break;
    case "rotate":
      transform.data = [
        ...degRound(transform.data.slice(0, 1), params),
        ...floatRound(transform.data.slice(1), params)
      ];
      break;
    case "skewX":
    case "skewY":
      transform.data = degRound(transform.data, params);
      break;
    case "scale":
      transform.data = transformRound(transform.data, params);
      break;
    case "matrix":
      transform.data = [
        ...transformRound(transform.data.slice(0, 4), params),
        ...floatRound(transform.data.slice(4), params)
      ];
      break;
  }
  return transform;
};
const degRound = (data, params) => {
  if (params.degPrecision != null && params.degPrecision >= 1 && params.floatPrecision < 20) {
    return smartRound(params.degPrecision, data);
  } else {
    return round$1(data);
  }
};
const floatRound = (data, params) => {
  if (params.floatPrecision >= 1 && params.floatPrecision < 20) {
    return smartRound(params.floatPrecision, data);
  } else {
    return round$1(data);
  }
};
const transformRound = (data, params) => {
  if (params.transformPrecision >= 1 && params.floatPrecision < 20) {
    return smartRound(params.transformPrecision, data);
  } else {
    return round$1(data);
  }
};
const round$1 = (data) => {
  return data.map(Math.round);
};
const smartRound = (precision2, data) => {
  for (let i = data.length, tolerance = +Math.pow(0.1, precision2).toFixed(precision2); i--; ) {
    if (toFixed(data[i], precision2) !== data[i]) {
      const rounded = +data[i].toFixed(precision2 - 1);
      data[i] = +Math.abs(rounded - data[i]).toFixed(precision2 + 1) >= tolerance ? +data[i].toFixed(precision2) : rounded;
    }
  }
  return data;
};
const js2transform = (transformJS, params) => {
  const transformString = transformJS.map((transform) => {
    roundTransform(transform, params);
    return `${transform.name}(${cleanupOutData(transform.data, params)})`;
  }).join("");
  return transformString;
};
const regNumericValues$1 = /[-+]?(\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;
const applyTransforms = (root, params) => {
  const stylesheet = collectStylesheet(root);
  return {
    element: {
      enter: (node2) => {
        if (node2.attributes.d == null) {
          return;
        }
        if (node2.attributes.id != null) {
          return;
        }
        if (node2.attributes.transform == null || node2.attributes.transform === "" || // styles are not considered when applying transform
        // can be fixed properly with new style engine
        node2.attributes.style != null || Object.entries(node2.attributes).some(
          ([name2, value2]) => referencesProps.has(name2) && includesUrlReference(value2)
        )) {
          return;
        }
        const computedStyle = computeStyle(stylesheet, node2);
        const transformStyle = computedStyle.transform;
        if (transformStyle.type === "static" && transformStyle.value !== node2.attributes.transform) {
          return;
        }
        const matrix = transformsMultiply(
          transform2js(node2.attributes.transform)
        );
        const stroke = computedStyle.stroke?.type === "static" ? computedStyle.stroke.value : null;
        const strokeWidth = computedStyle["stroke-width"]?.type === "static" ? computedStyle["stroke-width"].value : null;
        const transformPrecision = params.transformPrecision;
        if (computedStyle.stroke?.type === "dynamic" || computedStyle["stroke-width"]?.type === "dynamic") {
          return;
        }
        const scale = Number(
          Math.hypot(matrix.data[0], matrix.data[1]).toFixed(
            transformPrecision
          )
        );
        if (stroke && stroke != "none") {
          if (!params.applyTransformsStroked) {
            return;
          }
          if ((matrix.data[0] !== matrix.data[3] || matrix.data[1] !== -matrix.data[2]) && (matrix.data[0] !== -matrix.data[3] || matrix.data[1] !== matrix.data[2])) {
            return;
          }
          if (scale !== 1) {
            if (node2.attributes["vector-effect"] !== "non-scaling-stroke") {
              node2.attributes["stroke-width"] = (strokeWidth || attrsGroupsDefaults.presentation["stroke-width"]).trim().replace(
                regNumericValues$1,
                (num) => removeLeadingZero(Number(num) * scale)
              );
              if (node2.attributes["stroke-dashoffset"] != null) {
                node2.attributes["stroke-dashoffset"] = node2.attributes["stroke-dashoffset"].trim().replace(
                  regNumericValues$1,
                  (num) => removeLeadingZero(Number(num) * scale)
                );
              }
              if (node2.attributes["stroke-dasharray"] != null) {
                node2.attributes["stroke-dasharray"] = node2.attributes["stroke-dasharray"].trim().replace(
                  regNumericValues$1,
                  (num) => removeLeadingZero(Number(num) * scale)
                );
              }
            }
          }
        }
        const pathData = path2js(node2);
        applyMatrixToPathData(pathData, matrix.data);
        delete node2.attributes.transform;
      }
    }
  };
};
const transformAbsolutePoint = (matrix, x, y) => {
  const newX = matrix[0] * x + matrix[2] * y + matrix[4];
  const newY = matrix[1] * x + matrix[3] * y + matrix[5];
  return [newX, newY];
};
const transformRelativePoint = (matrix, x, y) => {
  const newX = matrix[0] * x + matrix[2] * y;
  const newY = matrix[1] * x + matrix[3] * y;
  return [newX, newY];
};
const applyMatrixToPathData = (pathData, matrix) => {
  const start = [0, 0];
  const cursor = [0, 0];
  for (const pathItem of pathData) {
    let { command, args } = pathItem;
    if (command === "M") {
      cursor[0] = args[0];
      cursor[1] = args[1];
      start[0] = cursor[0];
      start[1] = cursor[1];
      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
      args[0] = x;
      args[1] = y;
    }
    if (command === "m") {
      cursor[0] += args[0];
      cursor[1] += args[1];
      start[0] = cursor[0];
      start[1] = cursor[1];
      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
      args[0] = x;
      args[1] = y;
    }
    if (command === "H") {
      command = "L";
      args = [args[0], cursor[1]];
    }
    if (command === "h") {
      command = "l";
      args = [args[0], 0];
    }
    if (command === "V") {
      command = "L";
      args = [cursor[0], args[0]];
    }
    if (command === "v") {
      command = "l";
      args = [0, args[0]];
    }
    if (command === "L") {
      cursor[0] = args[0];
      cursor[1] = args[1];
      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
      args[0] = x;
      args[1] = y;
    }
    if (command === "l") {
      cursor[0] += args[0];
      cursor[1] += args[1];
      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
      args[0] = x;
      args[1] = y;
    }
    if (command === "C") {
      cursor[0] = args[4];
      cursor[1] = args[5];
      const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);
      const [x2, y2] = transformAbsolutePoint(matrix, args[2], args[3]);
      const [x, y] = transformAbsolutePoint(matrix, args[4], args[5]);
      args[0] = x1;
      args[1] = y1;
      args[2] = x2;
      args[3] = y2;
      args[4] = x;
      args[5] = y;
    }
    if (command === "c") {
      cursor[0] += args[4];
      cursor[1] += args[5];
      const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);
      const [x2, y2] = transformRelativePoint(matrix, args[2], args[3]);
      const [x, y] = transformRelativePoint(matrix, args[4], args[5]);
      args[0] = x1;
      args[1] = y1;
      args[2] = x2;
      args[3] = y2;
      args[4] = x;
      args[5] = y;
    }
    if (command === "S") {
      cursor[0] = args[2];
      cursor[1] = args[3];
      const [x2, y2] = transformAbsolutePoint(matrix, args[0], args[1]);
      const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);
      args[0] = x2;
      args[1] = y2;
      args[2] = x;
      args[3] = y;
    }
    if (command === "s") {
      cursor[0] += args[2];
      cursor[1] += args[3];
      const [x2, y2] = transformRelativePoint(matrix, args[0], args[1]);
      const [x, y] = transformRelativePoint(matrix, args[2], args[3]);
      args[0] = x2;
      args[1] = y2;
      args[2] = x;
      args[3] = y;
    }
    if (command === "Q") {
      cursor[0] = args[2];
      cursor[1] = args[3];
      const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);
      const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);
      args[0] = x1;
      args[1] = y1;
      args[2] = x;
      args[3] = y;
    }
    if (command === "q") {
      cursor[0] += args[2];
      cursor[1] += args[3];
      const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);
      const [x, y] = transformRelativePoint(matrix, args[2], args[3]);
      args[0] = x1;
      args[1] = y1;
      args[2] = x;
      args[3] = y;
    }
    if (command === "T") {
      cursor[0] = args[0];
      cursor[1] = args[1];
      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
      args[0] = x;
      args[1] = y;
    }
    if (command === "t") {
      cursor[0] += args[0];
      cursor[1] += args[1];
      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
      args[0] = x;
      args[1] = y;
    }
    if (command === "A") {
      transformArc(cursor, args, matrix);
      cursor[0] = args[5];
      cursor[1] = args[6];
      if (Math.abs(args[2]) > 80) {
        const a = args[0];
        const rotation = args[2];
        args[0] = args[1];
        args[1] = a;
        args[2] = rotation + (rotation > 0 ? -90 : 90);
      }
      const [x, y] = transformAbsolutePoint(matrix, args[5], args[6]);
      args[5] = x;
      args[6] = y;
    }
    if (command === "a") {
      transformArc([0, 0], args, matrix);
      cursor[0] += args[5];
      cursor[1] += args[6];
      if (Math.abs(args[2]) > 80) {
        const a = args[0];
        const rotation = args[2];
        args[0] = args[1];
        args[1] = a;
        args[2] = rotation + (rotation > 0 ? -90 : 90);
      }
      const [x, y] = transformRelativePoint(matrix, args[5], args[6]);
      args[5] = x;
      args[6] = y;
    }
    if (command === "z" || command === "Z") {
      cursor[0] = start[0];
      cursor[1] = start[1];
    }
    pathItem.command = command;
    pathItem.args = args;
  }
};
const name$r = "convertPathData";
const description$r = "optimizes path data: writes in shorter form, applies transformations";
let roundData;
let precision;
let error;
let arcThreshold;
let arcTolerance;
const fn$r = (root, params) => {
  const {
    // TODO convert to separate plugin in v3
    applyTransforms: _applyTransforms = true,
    applyTransformsStroked = true,
    makeArcs = {
      threshold: 2.5,
      // coefficient of rounding error
      tolerance: 0.5
      // percentage of radius
    },
    straightCurves = true,
    convertToQ = true,
    lineShorthands = true,
    convertToZ = true,
    curveSmoothShorthands = true,
    floatPrecision = 3,
    transformPrecision = 5,
    smartArcRounding = true,
    removeUseless: removeUseless2 = true,
    collapseRepeated = true,
    utilizeAbsolute = true,
    leadingZero = true,
    negativeExtraSpace = true,
    noSpaceAfterFlags = false,
    // a20 60 45 0 1 30 20 → a20 60 45 0130 20
    forceAbsolutePath = false
  } = params;
  const newParams = {
    applyTransforms: _applyTransforms,
    applyTransformsStroked,
    makeArcs,
    straightCurves,
    convertToQ,
    lineShorthands,
    convertToZ,
    curveSmoothShorthands,
    floatPrecision,
    transformPrecision,
    smartArcRounding,
    removeUseless: removeUseless2,
    collapseRepeated,
    utilizeAbsolute,
    leadingZero,
    negativeExtraSpace,
    noSpaceAfterFlags,
    forceAbsolutePath
  };
  if (_applyTransforms) {
    visit(
      root,
      // @ts-expect-error
      applyTransforms(root, {
        transformPrecision,
        applyTransformsStroked
      })
    );
  }
  const stylesheet = collectStylesheet(root);
  return {
    element: {
      enter: (node2) => {
        if (pathElems.has(node2.name) && node2.attributes.d != null) {
          const computedStyle = computeStyle(stylesheet, node2);
          precision = floatPrecision;
          error = precision !== false ? +Math.pow(0.1, precision).toFixed(precision) : 0.01;
          roundData = precision && precision > 0 && precision < 20 ? strongRound : round;
          if (makeArcs) {
            arcThreshold = makeArcs.threshold;
            arcTolerance = makeArcs.tolerance;
          }
          const hasMarkerMid = computedStyle["marker-mid"] != null;
          const maybeHasStroke = computedStyle.stroke && (computedStyle.stroke.type === "dynamic" || computedStyle.stroke.value !== "none");
          const maybeHasLinecap = computedStyle["stroke-linecap"] && (computedStyle["stroke-linecap"].type === "dynamic" || computedStyle["stroke-linecap"].value !== "butt");
          const maybeHasStrokeAndLinecap = maybeHasStroke && maybeHasLinecap;
          const isSafeToUseZ = maybeHasStroke ? computedStyle["stroke-linecap"]?.type === "static" && computedStyle["stroke-linecap"].value === "round" && computedStyle["stroke-linejoin"]?.type === "static" && computedStyle["stroke-linejoin"].value === "round" : true;
          let data = path2js(node2);
          if (data.length) {
            const includesVertices = data.some(
              (item) => item.command !== "m" && item.command !== "M"
            );
            convertToRelative(data);
            data = filters(data, newParams, {
              isSafeToUseZ,
              maybeHasStrokeAndLinecap,
              hasMarkerMid
            });
            if (utilizeAbsolute) {
              data = convertToMixed(data, newParams);
            }
            const hasMarker = node2.attributes["marker-start"] != null || node2.attributes["marker-end"] != null;
            const isMarkersOnlyPath = hasMarker && includesVertices && data.every(
              (item) => item.command === "m" || item.command === "M"
            );
            if (isMarkersOnlyPath) {
              data.push({
                command: "z",
                args: []
              });
            }
            js2path(node2, data, newParams);
          }
        }
      }
    }
  };
};
const convertToRelative = (pathData) => {
  const start = [0, 0];
  const cursor = [0, 0];
  let prevCoords = [0, 0];
  for (let i = 0; i < pathData.length; i += 1) {
    const pathItem = pathData[i];
    let { command, args } = pathItem;
    if (command === "m") {
      cursor[0] += args[0];
      cursor[1] += args[1];
      start[0] = cursor[0];
      start[1] = cursor[1];
    }
    if (command === "M") {
      if (i !== 0) {
        command = "m";
      }
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      cursor[0] += args[0];
      cursor[1] += args[1];
      start[0] = cursor[0];
      start[1] = cursor[1];
    }
    if (command === "l") {
      cursor[0] += args[0];
      cursor[1] += args[1];
    }
    if (command === "L") {
      command = "l";
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      cursor[0] += args[0];
      cursor[1] += args[1];
    }
    if (command === "h") {
      cursor[0] += args[0];
    }
    if (command === "H") {
      command = "h";
      args[0] -= cursor[0];
      cursor[0] += args[0];
    }
    if (command === "v") {
      cursor[1] += args[0];
    }
    if (command === "V") {
      command = "v";
      args[0] -= cursor[1];
      cursor[1] += args[0];
    }
    if (command === "c") {
      cursor[0] += args[4];
      cursor[1] += args[5];
    }
    if (command === "C") {
      command = "c";
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      args[2] -= cursor[0];
      args[3] -= cursor[1];
      args[4] -= cursor[0];
      args[5] -= cursor[1];
      cursor[0] += args[4];
      cursor[1] += args[5];
    }
    if (command === "s") {
      cursor[0] += args[2];
      cursor[1] += args[3];
    }
    if (command === "S") {
      command = "s";
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      args[2] -= cursor[0];
      args[3] -= cursor[1];
      cursor[0] += args[2];
      cursor[1] += args[3];
    }
    if (command === "q") {
      cursor[0] += args[2];
      cursor[1] += args[3];
    }
    if (command === "Q") {
      command = "q";
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      args[2] -= cursor[0];
      args[3] -= cursor[1];
      cursor[0] += args[2];
      cursor[1] += args[3];
    }
    if (command === "t") {
      cursor[0] += args[0];
      cursor[1] += args[1];
    }
    if (command === "T") {
      command = "t";
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      cursor[0] += args[0];
      cursor[1] += args[1];
    }
    if (command === "a") {
      cursor[0] += args[5];
      cursor[1] += args[6];
    }
    if (command === "A") {
      command = "a";
      args[5] -= cursor[0];
      args[6] -= cursor[1];
      cursor[0] += args[5];
      cursor[1] += args[6];
    }
    if (command === "Z" || command === "z") {
      cursor[0] = start[0];
      cursor[1] = start[1];
    }
    pathItem.command = command;
    pathItem.args = args;
    pathItem.base = prevCoords;
    pathItem.coords = [cursor[0], cursor[1]];
    prevCoords = pathItem.coords;
  }
  return pathData;
};
function filters(path, params, { isSafeToUseZ, maybeHasStrokeAndLinecap, hasMarkerMid }) {
  const stringify = data2Path.bind(null, params);
  const relSubpoint = [0, 0];
  const pathBase = [0, 0];
  let prev = {};
  let prevQControlPoint;
  path = path.filter(function(item, index, path2) {
    const qControlPoint = prevQControlPoint;
    let command = item.command;
    let data = item.args;
    let next = path2[index + 1];
    if (command !== "Z" && command !== "z") {
      let sdata = data;
      let circle;
      if (command === "s") {
        sdata = [0, 0].concat(data);
        const pdata = prev.args;
        const n = pdata.length;
        sdata[0] = pdata[n - 2] - pdata[n - 4];
        sdata[1] = pdata[n - 1] - pdata[n - 3];
      }
      if (params.makeArcs && (command == "c" || command == "s") && isConvex(sdata) && (circle = findCircle(sdata))) {
        const r = roundData([circle.radius])[0];
        let angle2 = findArcAngle(sdata, circle);
        const sweep = sdata[5] * sdata[0] - sdata[4] * sdata[1] > 0 ? 1 : 0;
        let arc = {
          command: "a",
          args: [r, r, 0, 0, sweep, sdata[4], sdata[5]],
          // @ts-expect-error
          coords: item.coords.slice(),
          // @ts-expect-error
          base: item.base
        };
        const output = [arc];
        const relCenter = [
          circle.center[0] - sdata[4],
          circle.center[1] - sdata[5]
        ];
        const relCircle = { center: relCenter, radius: circle.radius };
        const arcCurves = [item];
        let hasPrev = 0;
        let suffix = "";
        let nextLonghand;
        if (prev.command == "c" && isConvex(prev.args) && isArcPrev(prev.args, circle) || prev.command == "a" && prev.sdata && isArcPrev(prev.sdata, circle)) {
          arcCurves.unshift(prev);
          arc.base = prev.base;
          arc.args[5] = arc.coords[0] - arc.base[0];
          arc.args[6] = arc.coords[1] - arc.base[1];
          const prevData = prev.command == "a" ? prev.sdata : prev.args;
          const prevAngle = findArcAngle(prevData, {
            center: [
              prevData[4] + circle.center[0],
              prevData[5] + circle.center[1]
            ],
            radius: circle.radius
          });
          angle2 += prevAngle;
          if (angle2 > Math.PI) {
            arc.args[3] = 1;
          }
          hasPrev = 1;
        }
        for (var j = index; (next = path2[++j]) && (next.command === "c" || next.command === "s"); ) {
          let nextData = next.args;
          if (next.command == "s") {
            nextLonghand = makeLonghand(
              { command: "s", args: next.args.slice() },
              path2[j - 1].args
            );
            nextData = nextLonghand.args;
            nextLonghand.args = nextData.slice(0, 2);
            suffix = stringify([nextLonghand]);
          }
          if (isConvex(nextData) && isArc(nextData, relCircle)) {
            angle2 += findArcAngle(nextData, relCircle);
            if (angle2 - 2 * Math.PI > 1e-3) {
              break;
            }
            if (angle2 > Math.PI) {
              arc.args[3] = 1;
            }
            arcCurves.push(next);
            if (2 * Math.PI - angle2 > 1e-3) {
              arc.coords = next.coords;
              arc.args[5] = arc.coords[0] - arc.base[0];
              arc.args[6] = arc.coords[1] - arc.base[1];
            } else {
              arc.args[5] = 2 * (relCircle.center[0] - nextData[4]);
              arc.args[6] = 2 * (relCircle.center[1] - nextData[5]);
              arc.coords = [
                // @ts-expect-error
                arc.base[0] + arc.args[5],
                // @ts-expect-error
                arc.base[1] + arc.args[6]
              ];
              arc = {
                command: "a",
                args: [
                  r,
                  r,
                  0,
                  0,
                  sweep,
                  // @ts-expect-error
                  next.coords[0] - arc.coords[0],
                  // @ts-expect-error
                  next.coords[1] - arc.coords[1]
                ],
                // @ts-expect-error
                coords: next.coords,
                // @ts-expect-error
                base: arc.coords
              };
              output.push(arc);
              j++;
              break;
            }
            relCenter[0] -= nextData[4];
            relCenter[1] -= nextData[5];
          } else {
            break;
          }
        }
        if ((stringify(output) + suffix).length < stringify(arcCurves).length) {
          if (path2[j] && path2[j].command == "s") {
            makeLonghand(path2[j], path2[j - 1].args);
          }
          if (hasPrev) {
            const prevArc = output.shift();
            roundData(prevArc.args);
            relSubpoint[0] += prevArc.args[5] - prev.args[prev.args.length - 2];
            relSubpoint[1] += prevArc.args[6] - prev.args[prev.args.length - 1];
            prev.command = "a";
            prev.args = prevArc.args;
            item.base = prev.coords = prevArc.coords;
          }
          arc = output.shift();
          if (arcCurves.length == 1) {
            item.sdata = sdata.slice();
          } else if (arcCurves.length - 1 - hasPrev > 0) {
            path2.splice(index + 1, arcCurves.length - 1 - hasPrev, ...output);
          }
          if (!arc) {
            return false;
          }
          command = "a";
          data = arc.args;
          item.coords = arc.coords;
        }
      }
      if (precision !== false) {
        if (command === "m" || command === "l" || command === "t" || command === "q" || command === "s" || command === "c") {
          for (let i = data.length; i--; ) {
            data[i] += item.base[i % 2] - relSubpoint[i % 2];
          }
        } else if (command == "h") {
          data[0] += item.base[0] - relSubpoint[0];
        } else if (command == "v") {
          data[0] += item.base[1] - relSubpoint[1];
        } else if (command == "a") {
          data[5] += item.base[0] - relSubpoint[0];
          data[6] += item.base[1] - relSubpoint[1];
        }
        roundData(data);
        if (command == "h") {
          relSubpoint[0] += data[0];
        } else if (command == "v") {
          relSubpoint[1] += data[0];
        } else {
          relSubpoint[0] += data[data.length - 2];
          relSubpoint[1] += data[data.length - 1];
        }
        roundData(relSubpoint);
        if (command === "M" || command === "m") {
          pathBase[0] = relSubpoint[0];
          pathBase[1] = relSubpoint[1];
        }
      }
      const sagitta = command === "a" ? calculateSagitta(data) : void 0;
      if (params.smartArcRounding && sagitta !== void 0 && precision) {
        for (let precisionNew = precision; precisionNew >= 0; precisionNew--) {
          const radius = toFixed(data[0], precisionNew);
          const sagittaNew = (
            /** @type {number} */
            calculateSagitta([radius, radius, ...data.slice(2)])
          );
          if (Math.abs(sagitta - sagittaNew) < error) {
            data[0] = radius;
            data[1] = radius;
          } else {
            break;
          }
        }
      }
      if (params.straightCurves) {
        if (command === "c" && isCurveStraightLine(data) || command === "s" && isCurveStraightLine(sdata)) {
          if (next && next.command == "s") {
            makeLonghand(next, data);
          }
          command = "l";
          data = data.slice(-2);
        } else if (command === "q" && isCurveStraightLine(data)) {
          if (next && next.command == "t") {
            makeLonghand(next, data);
          }
          command = "l";
          data = data.slice(-2);
        } else if (command === "t" && prev.command !== "q" && prev.command !== "t") {
          command = "l";
          data = data.slice(-2);
        } else if (command === "a" && (data[0] === 0 || data[1] === 0 || sagitta !== void 0 && sagitta < error)) {
          command = "l";
          data = data.slice(-2);
        }
      }
      if (params.convertToQ && command == "c") {
        const x1 = (
          // @ts-expect-error
          0.75 * (item.base[0] + data[0]) - 0.25 * item.base[0]
        );
        const x2 = (
          // @ts-expect-error
          0.75 * (item.base[0] + data[2]) - 0.25 * (item.base[0] + data[4])
        );
        if (Math.abs(x1 - x2) < error * 2) {
          const y1 = (
            // @ts-expect-error
            0.75 * (item.base[1] + data[1]) - 0.25 * item.base[1]
          );
          const y2 = (
            // @ts-expect-error
            0.75 * (item.base[1] + data[3]) - 0.25 * (item.base[1] + data[5])
          );
          if (Math.abs(y1 - y2) < error * 2) {
            const newData = data.slice();
            newData.splice(
              0,
              4,
              // @ts-expect-error
              x1 + x2 - item.base[0],
              // @ts-expect-error
              y1 + y2 - item.base[1]
            );
            roundData(newData);
            const originalLength = cleanupOutData(data, params).length;
            const newLength = cleanupOutData(newData, params).length;
            if (newLength < originalLength) {
              command = "q";
              data = newData;
              if (next && next.command == "s") {
                makeLonghand(next, data);
              }
            }
          }
        }
      }
      if (params.lineShorthands && command === "l") {
        if (data[1] === 0) {
          command = "h";
          data.pop();
        } else if (data[0] === 0) {
          command = "v";
          data.shift();
        }
      }
      if (params.collapseRepeated && hasMarkerMid === false && (command === "m" || command === "h" || command === "v") && prev.command && command == prev.command.toLowerCase() && (command != "h" && command != "v" || prev.args[0] >= 0 == data[0] >= 0)) {
        prev.args[0] += data[0];
        if (command != "h" && command != "v") {
          prev.args[1] += data[1];
        }
        prev.coords = item.coords;
        path2[index] = prev;
        return false;
      }
      if (params.curveSmoothShorthands && prev.command) {
        if (command === "c") {
          if (prev.command === "c" && Math.abs(data[0] - -(prev.args[2] - prev.args[4])) < error && Math.abs(data[1] - -(prev.args[3] - prev.args[5])) < error) {
            command = "s";
            data = data.slice(2);
          } else if (prev.command === "s" && Math.abs(data[0] - -(prev.args[0] - prev.args[2])) < error && Math.abs(data[1] - -(prev.args[1] - prev.args[3])) < error) {
            command = "s";
            data = data.slice(2);
          } else if (prev.command !== "c" && prev.command !== "s" && Math.abs(data[0]) < error && Math.abs(data[1]) < error) {
            command = "s";
            data = data.slice(2);
          }
        } else if (command === "q") {
          if (prev.command === "q" && Math.abs(data[0] - (prev.args[2] - prev.args[0])) < error && Math.abs(data[1] - (prev.args[3] - prev.args[1])) < error) {
            command = "t";
            data = data.slice(2);
          } else if (prev.command === "t") {
            const predictedControlPoint = reflectPoint(
              // @ts-expect-error
              qControlPoint,
              // @ts-expect-error
              item.base
            );
            const realControlPoint = [
              // @ts-expect-error
              data[0] + item.base[0],
              // @ts-expect-error
              data[1] + item.base[1]
            ];
            if (Math.abs(predictedControlPoint[0] - realControlPoint[0]) < error && Math.abs(predictedControlPoint[1] - realControlPoint[1]) < error) {
              command = "t";
              data = data.slice(2);
            }
          }
        }
      }
      if (params.removeUseless && !maybeHasStrokeAndLinecap) {
        if ((command === "l" || command === "h" || command === "v" || command === "q" || command === "t" || command === "c" || command === "s") && data.every(function(i) {
          return i === 0;
        })) {
          path2[index] = prev;
          return false;
        }
        if (command === "a" && data[5] === 0 && data[6] === 0) {
          path2[index] = prev;
          return false;
        }
      }
      if (params.convertToZ && (isSafeToUseZ || next?.command === "Z" || next?.command === "z") && (command === "l" || command === "h" || command === "v")) {
        if (
          // @ts-expect-error
          Math.abs(pathBase[0] - item.coords[0]) < error && // @ts-expect-error
          Math.abs(pathBase[1] - item.coords[1]) < error
        ) {
          command = "z";
          data = [];
        }
      }
      item.command = command;
      item.args = data;
    } else {
      relSubpoint[0] = pathBase[0];
      relSubpoint[1] = pathBase[1];
      if (prev.command === "Z" || prev.command === "z") {
        return false;
      }
    }
    if ((command === "Z" || command === "z") && params.removeUseless && isSafeToUseZ && // @ts-expect-error
    Math.abs(item.base[0] - item.coords[0]) < error / 10 && // @ts-expect-error
    Math.abs(item.base[1] - item.coords[1]) < error / 10) {
      return false;
    }
    if (command === "q") {
      prevQControlPoint = [data[0] + item.base[0], data[1] + item.base[1]];
    } else if (command === "t") {
      if (qControlPoint) {
        prevQControlPoint = reflectPoint(qControlPoint, item.base);
      } else {
        prevQControlPoint = item.coords;
      }
    } else {
      prevQControlPoint = void 0;
    }
    prev = item;
    return true;
  });
  return path;
}
function convertToMixed(path, params) {
  let prev = path[0];
  path = path.filter(function(item, index) {
    if (index == 0) {
      return true;
    }
    if (item.command === "Z" || item.command === "z") {
      prev = item;
      return true;
    }
    const command = item.command;
    const data = item.args;
    const adata = data.slice();
    const rdata = data.slice();
    if (command === "m" || command === "l" || command === "t" || command === "q" || command === "s" || command === "c") {
      for (let i = adata.length; i--; ) {
        adata[i] += item.base[i % 2];
      }
    } else if (command == "h") {
      adata[0] += item.base[0];
    } else if (command == "v") {
      adata[0] += item.base[1];
    } else if (command == "a") {
      adata[5] += item.base[0];
      adata[6] += item.base[1];
    }
    roundData(adata);
    roundData(rdata);
    const absoluteDataStr = cleanupOutData(adata, params);
    const relativeDataStr = cleanupOutData(rdata, params);
    if (params.forceAbsolutePath || absoluteDataStr.length < relativeDataStr.length && !(params.negativeExtraSpace && command == prev.command && prev.command.charCodeAt(0) > 96 && absoluteDataStr.length == relativeDataStr.length - 1 && (data[0] < 0 || Math.floor(data[0]) === 0 && !Number.isInteger(data[0]) && prev.args[prev.args.length - 1] % 1))) {
      item.command = command.toUpperCase();
      item.args = adata;
    }
    prev = item;
    return true;
  });
  return path;
}
function isConvex(data) {
  const center = getIntersection([
    0,
    0,
    data[2],
    data[3],
    data[0],
    data[1],
    data[4],
    data[5]
  ]);
  return center != null && data[2] < center[0] == center[0] < 0 && data[3] < center[1] == center[1] < 0 && data[4] < center[0] == center[0] < data[0] && data[5] < center[1] == center[1] < data[1];
}
function getIntersection(coords) {
  const a1 = coords[1] - coords[3];
  const b1 = coords[2] - coords[0];
  const c1 = coords[0] * coords[3] - coords[2] * coords[1];
  const a2 = coords[5] - coords[7];
  const b2 = coords[6] - coords[4];
  const c2 = coords[4] * coords[7] - coords[5] * coords[6];
  const denom = a1 * b2 - a2 * b1;
  if (!denom) {
    return;
  }
  const cross2 = [(b1 * c2 - b2 * c1) / denom, (a1 * c2 - a2 * c1) / -denom];
  if (!isNaN(cross2[0]) && !isNaN(cross2[1]) && isFinite(cross2[0]) && isFinite(cross2[1])) {
    return cross2;
  }
}
function strongRound(data) {
  const precisionNum = precision || 0;
  for (let i = data.length; i-- > 0; ) {
    const fixed = toFixed(data[i], precisionNum);
    if (fixed !== data[i]) {
      const rounded = toFixed(data[i], precisionNum - 1);
      data[i] = toFixed(Math.abs(rounded - data[i]), precisionNum + 1) >= error ? fixed : rounded;
    }
  }
  return data;
}
function round(data) {
  for (let i = data.length; i-- > 0; ) {
    data[i] = Math.round(data[i]);
  }
  return data;
}
function isCurveStraightLine(data) {
  let i = data.length - 2;
  const a = -data[i + 1];
  const b = data[i];
  const d = 1 / (a * a + b * b);
  if (i <= 1 || !isFinite(d)) {
    return false;
  }
  while ((i -= 2) >= 0) {
    if (Math.sqrt(Math.pow(a * data[i] + b * data[i + 1], 2) * d) > error) {
      return false;
    }
  }
  return true;
}
function calculateSagitta(data) {
  if (data[3] === 1) {
    return void 0;
  }
  const [rx, ry] = data;
  if (Math.abs(rx - ry) > error) {
    return void 0;
  }
  const chord = Math.hypot(data[5], data[6]);
  if (chord > rx * 2) {
    return void 0;
  }
  return rx - Math.sqrt(rx ** 2 - 0.25 * chord ** 2);
}
function makeLonghand(item, data) {
  switch (item.command) {
    case "s":
      item.command = "c";
      break;
    case "t":
      item.command = "q";
      break;
  }
  item.args.unshift(
    data[data.length - 2] - data[data.length - 4],
    data[data.length - 1] - data[data.length - 3]
  );
  return item;
}
function getDistance(point1, point2) {
  return Math.hypot(point1[0] - point2[0], point1[1] - point2[1]);
}
function reflectPoint(controlPoint, base) {
  return [2 * base[0] - controlPoint[0], 2 * base[1] - controlPoint[1]];
}
function getCubicBezierPoint(curve, t) {
  const sqrT = t * t;
  const cubT = sqrT * t;
  const mt = 1 - t;
  const sqrMt = mt * mt;
  return [
    3 * sqrMt * t * curve[0] + 3 * mt * sqrT * curve[2] + cubT * curve[4],
    3 * sqrMt * t * curve[1] + 3 * mt * sqrT * curve[3] + cubT * curve[5]
  ];
}
function findCircle(curve) {
  const midPoint = getCubicBezierPoint(curve, 1 / 2);
  const m1 = [midPoint[0] / 2, midPoint[1] / 2];
  const m2 = [(midPoint[0] + curve[4]) / 2, (midPoint[1] + curve[5]) / 2];
  const center = getIntersection([
    m1[0],
    m1[1],
    m1[0] + m1[1],
    m1[1] - m1[0],
    m2[0],
    m2[1],
    m2[0] + (m2[1] - midPoint[1]),
    m2[1] - (m2[0] - midPoint[0])
  ]);
  const radius = center && getDistance([0, 0], center);
  const tolerance = Math.min(
    arcThreshold * error,
    // @ts-expect-error
    arcTolerance * radius / 100
  );
  if (center && // @ts-expect-error
  radius < 1e15 && [1 / 4, 3 / 4].every(function(point) {
    return Math.abs(
      // @ts-expect-error
      getDistance(getCubicBezierPoint(curve, point), center) - radius
    ) <= tolerance;
  })) {
    return { center, radius };
  }
}
function isArc(curve, circle) {
  const tolerance = Math.min(
    arcThreshold * error,
    arcTolerance * circle.radius / 100
  );
  return [0, 1 / 4, 1 / 2, 3 / 4, 1].every(function(point) {
    return Math.abs(
      getDistance(getCubicBezierPoint(curve, point), circle.center) - circle.radius
    ) <= tolerance;
  });
}
function isArcPrev(curve, circle) {
  return isArc(curve, {
    center: [circle.center[0] + curve[4], circle.center[1] + curve[5]],
    radius: circle.radius
  });
}
function findArcAngle(curve, relCircle) {
  const x1 = -relCircle.center[0];
  const y1 = -relCircle.center[1];
  const x2 = curve[4] - relCircle.center[0];
  const y2 = curve[5] - relCircle.center[1];
  return Math.acos(
    (x1 * x2 + y1 * y2) / Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))
  );
}
function data2Path(params, pathData) {
  return pathData.reduce(function(pathString, item) {
    let strData = "";
    if (item.args) {
      strData = cleanupOutData(roundData(item.args.slice()), params);
    }
    return pathString + item.command + strData;
  }, "");
}
const convertPathData = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$r,
  fn: fn$r,
  name: name$r
}, Symbol.toStringTag, { value: "Module" }));
const name$q = "convertTransform";
const description$q = "collapses multiple transformations and optimizes it";
const fn$q = (_root, params) => {
  const {
    convertToShorts: convertToShorts2 = true,
    // degPrecision = 3, // transformPrecision (or matrix precision) - 2 by default
    degPrecision,
    floatPrecision = 3,
    transformPrecision = 5,
    matrixToTransform: matrixToTransform2 = true,
    shortTranslate = true,
    shortScale = true,
    shortRotate = true,
    removeUseless: removeUseless2 = true,
    collapseIntoOne = true,
    leadingZero = true,
    negativeExtraSpace = false
  } = params;
  const newParams = {
    convertToShorts: convertToShorts2,
    degPrecision,
    floatPrecision,
    transformPrecision,
    matrixToTransform: matrixToTransform2,
    shortTranslate,
    shortScale,
    shortRotate,
    removeUseless: removeUseless2,
    collapseIntoOne,
    leadingZero,
    negativeExtraSpace
  };
  return {
    element: {
      enter: (node2) => {
        if (node2.attributes.transform != null) {
          convertTransform(node2, "transform", newParams);
        }
        if (node2.attributes.gradientTransform != null) {
          convertTransform(node2, "gradientTransform", newParams);
        }
        if (node2.attributes.patternTransform != null) {
          convertTransform(node2, "patternTransform", newParams);
        }
      }
    }
  };
};
const convertTransform = (item, attrName, params) => {
  let data = transform2js(item.attributes[attrName]);
  params = definePrecision(data, params);
  if (params.collapseIntoOne && data.length > 1) {
    data = [transformsMultiply(data)];
  }
  if (params.convertToShorts) {
    data = convertToShorts(data, params);
  } else {
    data.forEach((item2) => roundTransform(item2, params));
  }
  if (params.removeUseless) {
    data = removeUseless(data);
  }
  if (data.length) {
    item.attributes[attrName] = js2transform(data, params);
  } else {
    delete item.attributes[attrName];
  }
};
const definePrecision = (data, { ...newParams }) => {
  const matrixData = [];
  for (const item of data) {
    if (item.name == "matrix") {
      matrixData.push(...item.data.slice(0, 4));
    }
  }
  let numberOfDigits = newParams.transformPrecision;
  if (matrixData.length) {
    newParams.transformPrecision = Math.min(
      newParams.transformPrecision,
      Math.max.apply(Math, matrixData.map(floatDigits)) || newParams.transformPrecision
    );
    numberOfDigits = Math.max.apply(
      Math,
      matrixData.map(
        (n) => n.toString().replace(/\D+/g, "").length
        // Number of digits in a number. 123.45 → 5
      )
    );
  }
  if (newParams.degPrecision == null) {
    newParams.degPrecision = Math.max(
      0,
      Math.min(newParams.floatPrecision, numberOfDigits - 2)
    );
  }
  return newParams;
};
const floatDigits = (n) => {
  const str = n.toString();
  return str.slice(str.indexOf(".")).length - 1;
};
const convertToShorts = (transforms, params) => {
  for (let i = 0; i < transforms.length; i++) {
    let transform = transforms[i];
    if (params.matrixToTransform && transform.name === "matrix") {
      const decomposed = matrixToTransform(transform, params);
      if (js2transform(decomposed, params).length <= js2transform([transform], params).length) {
        transforms.splice(i, 1, ...decomposed);
      }
      transform = transforms[i];
    }
    roundTransform(transform, params);
    if (params.shortTranslate && transform.name === "translate" && transform.data.length === 2 && !transform.data[1]) {
      transform.data.pop();
    }
    if (params.shortScale && transform.name === "scale" && transform.data.length === 2 && transform.data[0] === transform.data[1]) {
      transform.data.pop();
    }
    if (params.shortRotate && transforms[i - 2]?.name === "translate" && transforms[i - 1].name === "rotate" && transforms[i].name === "translate" && transforms[i - 2].data[0] === -transforms[i].data[0] && transforms[i - 2].data[1] === -transforms[i].data[1]) {
      transforms.splice(i - 2, 3, {
        name: "rotate",
        data: [
          transforms[i - 1].data[0],
          transforms[i - 2].data[0],
          transforms[i - 2].data[1]
        ]
      });
      i -= 2;
    }
  }
  return transforms;
};
const removeUseless = (transforms) => {
  return transforms.filter((transform) => {
    if (["translate", "rotate", "skewX", "skewY"].indexOf(transform.name) > -1 && (transform.data.length == 1 || transform.name == "rotate") && !transform.data[0] || // translate(0, 0)
    transform.name == "translate" && !transform.data[0] && !transform.data[1] || // scale(1)
    transform.name == "scale" && transform.data[0] == 1 && (transform.data.length < 2 || transform.data[1] == 1) || // matrix(1 0 0 1 0 0)
    transform.name == "matrix" && transform.data[0] == 1 && transform.data[3] == 1 && !(transform.data[1] || transform.data[2] || transform.data[4] || transform.data[5])) {
      return false;
    }
    return true;
  });
};
const convertTransform$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$q,
  fn: fn$q,
  name: name$q
}, Symbol.toStringTag, { value: "Module" }));
const name$p = "removeEmptyAttrs";
const description$p = "removes empty attributes";
const fn$p = () => {
  return {
    element: {
      enter: (node2) => {
        for (const [name2, value2] of Object.entries(node2.attributes)) {
          if (value2 === "" && // empty conditional processing attributes prevents elements from rendering
          !attrsGroups.conditionalProcessing.has(name2)) {
            delete node2.attributes[name2];
          }
        }
      }
    }
  };
};
const removeEmptyAttrs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$p,
  fn: fn$p,
  name: name$p
}, Symbol.toStringTag, { value: "Module" }));
const name$o = "removeEmptyContainers";
const description$o = "removes empty container elements";
const fn$o = (root) => {
  const stylesheet = collectStylesheet(root);
  return {
    element: {
      exit: (node2, parentNode) => {
        if (node2.name === "svg" || !elemsGroups.container.has(node2.name) || node2.children.length !== 0) {
          return;
        }
        if (node2.name === "pattern" && Object.keys(node2.attributes).length !== 0) {
          return;
        }
        if (node2.name === "mask" && node2.attributes.id != null) {
          return;
        }
        if (parentNode.type === "element" && parentNode.name === "switch") {
          return;
        }
        if (node2.name === "g" && (node2.attributes.filter != null || computeStyle(stylesheet, node2).filter)) {
          return;
        }
        detachNodeFromParent(node2, parentNode);
      }
    }
  };
};
const removeEmptyContainers = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$o,
  fn: fn$o,
  name: name$o
}, Symbol.toStringTag, { value: "Module" }));
const name$n = "mergePaths";
const description$n = "merges multiple paths in one if possible";
function elementHasUrl(computedStyle, attName) {
  const style = computedStyle[attName];
  if (style?.type === "static") {
    return includesUrlReference(style.value);
  }
  return false;
}
const fn$n = (root, params) => {
  const {
    force = false,
    floatPrecision = 3,
    noSpaceAfterFlags = false
    // a20 60 45 0 1 30 20 → a20 60 45 0130 20
  } = params;
  const stylesheet = collectStylesheet(root);
  return {
    element: {
      enter: (node2) => {
        if (node2.children.length <= 1) {
          return;
        }
        const elementsToRemove = [];
        let prevChild = node2.children[0];
        let prevPathData = null;
        const updatePreviousPath = (child, pathData) => {
          js2path(child, pathData, {
            floatPrecision,
            noSpaceAfterFlags
          });
          prevPathData = null;
        };
        for (let i = 1; i < node2.children.length; i++) {
          const child = node2.children[i];
          if (prevChild.type !== "element" || prevChild.name !== "path" || prevChild.children.length !== 0 || prevChild.attributes.d == null) {
            if (prevPathData && prevChild.type === "element") {
              updatePreviousPath(prevChild, prevPathData);
            }
            prevChild = child;
            continue;
          }
          if (child.type !== "element" || child.name !== "path" || child.children.length !== 0 || child.attributes.d == null) {
            if (prevPathData) {
              updatePreviousPath(prevChild, prevPathData);
            }
            prevChild = child;
            continue;
          }
          const computedStyle = computeStyle(stylesheet, child);
          if (computedStyle["marker-start"] || computedStyle["marker-mid"] || computedStyle["marker-end"] || computedStyle["clip-path"] || computedStyle["mask"] || computedStyle["mask-image"] || ["fill", "filter", "stroke"].some(
            (attName) => elementHasUrl(computedStyle, attName)
          )) {
            if (prevPathData) {
              updatePreviousPath(prevChild, prevPathData);
            }
            prevChild = child;
            continue;
          }
          const childAttrs = Object.keys(child.attributes);
          if (childAttrs.length !== Object.keys(prevChild.attributes).length) {
            if (prevPathData) {
              updatePreviousPath(prevChild, prevPathData);
            }
            prevChild = child;
            continue;
          }
          const areAttrsEqual = childAttrs.some((attr) => {
            return attr !== "d" && prevChild.type === "element" && prevChild.attributes[attr] !== child.attributes[attr];
          });
          if (areAttrsEqual) {
            if (prevPathData) {
              updatePreviousPath(prevChild, prevPathData);
            }
            prevChild = child;
            continue;
          }
          const hasPrevPath = prevPathData != null;
          const currentPathData = path2js(child);
          prevPathData = prevPathData ?? path2js(prevChild);
          if (force || !intersects(prevPathData, currentPathData)) {
            prevPathData.push(...currentPathData);
            elementsToRemove.push(child);
            continue;
          }
          if (hasPrevPath) {
            updatePreviousPath(prevChild, prevPathData);
          }
          prevChild = child;
          prevPathData = null;
        }
        if (prevPathData && prevChild.type === "element") {
          updatePreviousPath(prevChild, prevPathData);
        }
        node2.children = node2.children.filter(
          (child) => !elementsToRemove.includes(child)
        );
      }
    }
  };
};
const mergePaths = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$n,
  fn: fn$n,
  name: name$n
}, Symbol.toStringTag, { value: "Module" }));
const name$m = "removeUnusedNS";
const description$m = "removes unused namespaces declaration";
const fn$m = () => {
  const unusedNamespaces = /* @__PURE__ */ new Set();
  return {
    element: {
      enter: (node2, parentNode) => {
        if (node2.name === "svg" && parentNode.type === "root") {
          for (const name2 of Object.keys(node2.attributes)) {
            if (name2.startsWith("xmlns:")) {
              const local = name2.slice("xmlns:".length);
              unusedNamespaces.add(local);
            }
          }
        }
        if (unusedNamespaces.size !== 0) {
          if (node2.name.includes(":")) {
            const [ns] = node2.name.split(":");
            if (unusedNamespaces.has(ns)) {
              unusedNamespaces.delete(ns);
            }
          }
          for (const name2 of Object.keys(node2.attributes)) {
            if (name2.includes(":")) {
              const [ns] = name2.split(":");
              unusedNamespaces.delete(ns);
            }
          }
        }
      },
      exit: (node2, parentNode) => {
        if (node2.name === "svg" && parentNode.type === "root") {
          for (const name2 of unusedNamespaces) {
            delete node2.attributes[`xmlns:${name2}`];
          }
        }
      }
    }
  };
};
const removeUnusedNS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$m,
  fn: fn$m,
  name: name$m
}, Symbol.toStringTag, { value: "Module" }));
const name$l = "sortAttrs";
const description$l = "Sort element attributes for better compression";
const fn$l = (_root, params) => {
  const {
    order = [
      "id",
      "width",
      "height",
      "x",
      "x1",
      "x2",
      "y",
      "y1",
      "y2",
      "cx",
      "cy",
      "r",
      "fill",
      "stroke",
      "marker",
      "d",
      "points"
    ],
    xmlnsOrder = "front"
  } = params;
  const getNsPriority = (name2) => {
    if (xmlnsOrder === "front") {
      if (name2 === "xmlns") {
        return 3;
      }
      if (name2.startsWith("xmlns:")) {
        return 2;
      }
    }
    if (name2.includes(":")) {
      return 1;
    }
    return 0;
  };
  const compareAttrs = ([aName], [bName]) => {
    const aPriority = getNsPriority(aName);
    const bPriority = getNsPriority(bName);
    const priorityNs = bPriority - aPriority;
    if (priorityNs !== 0) {
      return priorityNs;
    }
    const [aPart] = aName.split("-");
    const [bPart] = bName.split("-");
    if (aPart !== bPart) {
      const aInOrderFlag = order.includes(aPart) ? 1 : 0;
      const bInOrderFlag = order.includes(bPart) ? 1 : 0;
      if (aInOrderFlag === 1 && bInOrderFlag === 1) {
        return order.indexOf(aPart) - order.indexOf(bPart);
      }
      const priorityOrder = bInOrderFlag - aInOrderFlag;
      if (priorityOrder !== 0) {
        return priorityOrder;
      }
    }
    return aName < bName ? -1 : 1;
  };
  return {
    element: {
      enter: (node2) => {
        const attrs = Object.entries(node2.attributes);
        attrs.sort(compareAttrs);
        const sortedAttributes = {};
        for (const [name2, value2] of attrs) {
          sortedAttributes[name2] = value2;
        }
        node2.attributes = sortedAttributes;
      }
    }
  };
};
const sortAttrs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$l,
  fn: fn$l,
  name: name$l
}, Symbol.toStringTag, { value: "Module" }));
const name$k = "sortDefsChildren";
const description$k = "Sorts children of <defs> to improve compression";
const fn$k = () => {
  return {
    element: {
      enter: (node2) => {
        if (node2.name === "defs") {
          const frequencies = /* @__PURE__ */ new Map();
          for (const child of node2.children) {
            if (child.type === "element") {
              const frequency2 = frequencies.get(child.name);
              if (frequency2 == null) {
                frequencies.set(child.name, 1);
              } else {
                frequencies.set(child.name, frequency2 + 1);
              }
            }
          }
          node2.children.sort((a, b) => {
            if (a.type !== "element" || b.type !== "element") {
              return 0;
            }
            const aFrequency = frequencies.get(a.name);
            const bFrequency = frequencies.get(b.name);
            if (aFrequency != null && bFrequency != null) {
              const frequencyComparison = bFrequency - aFrequency;
              if (frequencyComparison !== 0) {
                return frequencyComparison;
              }
            }
            const lengthComparison = b.name.length - a.name.length;
            if (lengthComparison !== 0) {
              return lengthComparison;
            }
            if (a.name !== b.name) {
              return a.name > b.name ? -1 : 1;
            }
            return 0;
          });
        }
      }
    }
  };
};
const sortDefsChildren = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$k,
  fn: fn$k,
  name: name$k
}, Symbol.toStringTag, { value: "Module" }));
const name$j = "removeDesc";
const description$j = "removes <desc>";
const standardDescs = /^(Created with|Created using)/;
const fn$j = (root, params) => {
  const { removeAny = false } = params;
  return {
    element: {
      enter: (node2, parentNode) => {
        if (node2.name === "desc") {
          if (removeAny || node2.children.length === 0 || node2.children[0].type === "text" && standardDescs.test(node2.children[0].value)) {
            detachNodeFromParent(node2, parentNode);
          }
        }
      }
    }
  };
};
const removeDesc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$j,
  fn: fn$j,
  name: name$j
}, Symbol.toStringTag, { value: "Module" }));
const presetDefault = createPreset({
  name: "preset-default",
  plugins: [
    removeDoctype,
    removeXMLProcInst,
    removeComments,
    removeDeprecatedAttrs,
    removeMetadata,
    removeEditorsNSData,
    cleanupAttrs,
    mergeStyles,
    inlineStyles,
    minifyStyles,
    cleanupIds,
    removeUselessDefs,
    cleanupNumericValues,
    convertColors,
    removeUnknownsAndDefaults,
    removeNonInheritableGroupAttrs,
    removeUselessStrokeAndFill,
    cleanupEnableBackground,
    removeHiddenElems,
    removeEmptyText,
    convertShapeToPath,
    convertEllipseToCircle,
    moveElemsAttrsToGroup,
    moveGroupAttrsToElems,
    collapseGroups,
    convertPathData,
    convertTransform$1,
    removeEmptyAttrs,
    removeEmptyContainers,
    mergePaths,
    removeUnusedNS,
    sortAttrs,
    sortDefsChildren,
    removeDesc
  ]
});
const name$i = "addAttributesToSVGElement";
const description$i = "adds attributes to an outer <svg> element";
const ENOCLS$1 = `Error in plugin "addAttributesToSVGElement": absent parameters.
It should have a list of "attributes" or one "attribute".
Config example:

plugins: [
  {
    name: 'addAttributesToSVGElement',
    params: {
      attribute: "mySvg"
    }
  }
]

plugins: [
  {
    name: 'addAttributesToSVGElement',
    params: {
      attributes: ["mySvg", "size-big"]
    }
  }
]

plugins: [
  {
    name: 'addAttributesToSVGElement',
    params: {
      attributes: [
        {
          focusable: false
        },
        {
          'data-image': icon
        }
      ]
    }
  }
]
`;
const fn$i = (root, params) => {
  if (!Array.isArray(params.attributes) && !params.attribute) {
    console.error(ENOCLS$1);
    return null;
  }
  const attributes2 = params.attributes || [params.attribute];
  return {
    element: {
      enter: (node2, parentNode) => {
        if (node2.name === "svg" && parentNode.type === "root") {
          for (const attribute of attributes2) {
            if (typeof attribute === "string") {
              if (node2.attributes[attribute] == null) {
                node2.attributes[attribute] = void 0;
              }
            }
            if (typeof attribute === "object") {
              for (const key of Object.keys(attribute)) {
                if (node2.attributes[key] == null) {
                  node2.attributes[key] = attribute[key];
                }
              }
            }
          }
        }
      }
    }
  };
};
const addAttributesToSVGElement = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$i,
  fn: fn$i,
  name: name$i
}, Symbol.toStringTag, { value: "Module" }));
const name$h = "addClassesToSVGElement";
const description$h = "adds classnames to an outer <svg> element";
const ENOCLS = `Error in plugin "addClassesToSVGElement": absent parameters.
It should have a list of classes in "classNames" or one "className".
Config example:

plugins: [
  {
    name: "addClassesToSVGElement",
    params: {
      className: "mySvg"
    }
  }
]

plugins: [
  {
    name: "addClassesToSVGElement",
    params: {
      classNames: ["mySvg", "size-big"]
    }
  }
]
`;
const fn$h = (root, params, info) => {
  if (!(Array.isArray(params.classNames) && params.classNames.length !== 0) && !params.className) {
    console.error(ENOCLS);
    return null;
  }
  const classNames = params.classNames || [params.className];
  return {
    element: {
      enter: (node2, parentNode) => {
        if (node2.name === "svg" && parentNode.type === "root") {
          const classList = new Set(
            node2.attributes.class == null ? null : node2.attributes.class.split(" ")
          );
          for (const className of classNames) {
            if (className != null) {
              const classToAdd = typeof className === "string" ? className : className(node2, info);
              classList.add(classToAdd);
            }
          }
          node2.attributes.class = Array.from(classList).join(" ");
        }
      }
    }
  };
};
const addClassesToSVGElement = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$h,
  fn: fn$h,
  name: name$h
}, Symbol.toStringTag, { value: "Module" }));
const name$g = "cleanupListOfValues";
const description$g = "rounds list of values to the fixed precision";
const regNumericValues = /^([-+]?\d*\.?\d+([eE][-+]?\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/;
const regSeparator = /\s+,?\s*|,\s*/;
const absoluteLengths = {
  // relative to px
  cm: 96 / 2.54,
  mm: 96 / 25.4,
  in: 96,
  pt: 4 / 3,
  pc: 16,
  px: 1
};
const fn$g = (_root, params) => {
  const {
    floatPrecision = 3,
    leadingZero = true,
    defaultPx = true,
    convertToPx = true
  } = params;
  const roundValues = (lists) => {
    const roundedList = [];
    for (const elem of lists.split(regSeparator)) {
      const match = elem.match(regNumericValues);
      const matchNew = elem.match(/new/);
      if (match) {
        let num = Number(Number(match[1]).toFixed(floatPrecision));
        const matchedUnit = match[3] || "";
        let units2 = matchedUnit;
        if (convertToPx && units2 && units2 in absoluteLengths) {
          const pxNum = Number(
            (absoluteLengths[units2] * Number(match[1])).toFixed(floatPrecision)
          );
          if (pxNum.toString().length < match[0].length) {
            num = pxNum;
            units2 = "px";
          }
        }
        let str;
        if (leadingZero) {
          str = removeLeadingZero(num);
        } else {
          str = num.toString();
        }
        if (defaultPx && units2 === "px") {
          units2 = "";
        }
        roundedList.push(str + units2);
      } else if (matchNew) {
        roundedList.push("new");
      } else if (elem) {
        roundedList.push(elem);
      }
    }
    return roundedList.join(" ");
  };
  return {
    element: {
      enter: (node2) => {
        if (node2.attributes.points != null) {
          node2.attributes.points = roundValues(node2.attributes.points);
        }
        if (node2.attributes["enable-background"] != null) {
          node2.attributes["enable-background"] = roundValues(
            node2.attributes["enable-background"]
          );
        }
        if (node2.attributes.viewBox != null) {
          node2.attributes.viewBox = roundValues(node2.attributes.viewBox);
        }
        if (node2.attributes["stroke-dasharray"] != null) {
          node2.attributes["stroke-dasharray"] = roundValues(
            node2.attributes["stroke-dasharray"]
          );
        }
        if (node2.attributes.dx != null) {
          node2.attributes.dx = roundValues(node2.attributes.dx);
        }
        if (node2.attributes.dy != null) {
          node2.attributes.dy = roundValues(node2.attributes.dy);
        }
        if (node2.attributes.x != null) {
          node2.attributes.x = roundValues(node2.attributes.x);
        }
        if (node2.attributes.y != null) {
          node2.attributes.y = roundValues(node2.attributes.y);
        }
      }
    }
  };
};
const cleanupListOfValues = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$g,
  fn: fn$g,
  name: name$g
}, Symbol.toStringTag, { value: "Module" }));
const name$f = "convertOneStopGradients";
const description$f = "converts one-stop (single color) gradients to a plain color";
const fn$f = (root) => {
  const stylesheet = collectStylesheet(root);
  const effectedDefs = /* @__PURE__ */ new Set();
  const allDefs = /* @__PURE__ */ new Map();
  const gradientsToDetach = /* @__PURE__ */ new Map();
  let xlinkHrefCount = 0;
  return {
    element: {
      enter: (node2, parentNode) => {
        if (node2.attributes["xlink:href"] != null) {
          xlinkHrefCount++;
        }
        if (node2.name === "defs") {
          allDefs.set(node2, parentNode);
          return;
        }
        if (node2.name !== "linearGradient" && node2.name !== "radialGradient") {
          return;
        }
        const stops = node2.children.filter((child) => {
          return child.type === "element" && child.name === "stop";
        });
        const href = node2.attributes["xlink:href"] || node2.attributes["href"];
        const effectiveNode = stops.length === 0 && href != null && href.startsWith("#") ? querySelector(root, href) : node2;
        if (effectiveNode == null || effectiveNode.type !== "element") {
          gradientsToDetach.set(node2, parentNode);
          return;
        }
        const effectiveStops = effectiveNode.children.filter((child) => {
          return child.type === "element" && child.name === "stop";
        });
        if (effectiveStops.length !== 1 || effectiveStops[0].type !== "element") {
          return;
        }
        if (parentNode.type === "element" && parentNode.name === "defs") {
          effectedDefs.add(parentNode);
        }
        gradientsToDetach.set(node2, parentNode);
        let color;
        const style = computeStyle(stylesheet, effectiveStops[0])["stop-color"];
        if (style != null && style.type === "static") {
          color = style.value;
        }
        const selectorVal = `url(#${node2.attributes.id})`;
        const selector2 = [...colorsProps].map((attr) => `[${attr}="${selectorVal}"]`).join(",");
        const elements = querySelectorAll(root, selector2);
        for (const element of elements) {
          if (element.type !== "element") {
            continue;
          }
          for (const attr of colorsProps) {
            if (element.attributes[attr] !== selectorVal) {
              continue;
            }
            if (color != null) {
              element.attributes[attr] = color;
            } else {
              delete element.attributes[attr];
            }
          }
        }
        const styledElements = querySelectorAll(
          root,
          `[style*=${selectorVal}]`
        );
        for (const element of styledElements) {
          if (element.type !== "element") {
            continue;
          }
          element.attributes.style = element.attributes.style.replace(
            selectorVal,
            color || attrsGroupsDefaults.presentation["stop-color"]
          );
        }
      },
      exit: (node2) => {
        if (node2.name === "svg") {
          for (const [gradient, parent] of gradientsToDetach.entries()) {
            if (gradient.attributes["xlink:href"] != null) {
              xlinkHrefCount--;
            }
            detachNodeFromParent(gradient, parent);
          }
          if (xlinkHrefCount === 0) {
            delete node2.attributes["xmlns:xlink"];
          }
          for (const [defs, parent] of allDefs.entries()) {
            if (effectedDefs.has(defs) && defs.children.length === 0) {
              detachNodeFromParent(defs, parent);
            }
          }
        }
      }
    }
  };
};
const convertOneStopGradients = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$f,
  fn: fn$f,
  name: name$f
}, Symbol.toStringTag, { value: "Module" }));
const name$e = "convertStyleToAttrs";
const description$e = "converts style to attributes";
const g = (...args) => {
  return "(?:" + args.join("|") + ")";
};
const stylingProps = attrsGroups.presentation;
const rEscape = "\\\\(?:[0-9a-f]{1,6}\\s?|\\r\\n|.)";
const rAttr = "\\s*(" + g("[^:;\\\\]", rEscape) + "*?)\\s*";
const rSingleQuotes = "'(?:[^'\\n\\r\\\\]|" + rEscape + ")*?(?:'|$)";
const rQuotes = '"(?:[^"\\n\\r\\\\]|' + rEscape + ')*?(?:"|$)';
const rQuotedString = new RegExp("^" + g(rSingleQuotes, rQuotes) + "$");
const rParenthesis = "\\(" + g(`[^'"()\\\\]+`, rEscape, rSingleQuotes, rQuotes) + "*?\\)";
const rValue = "\\s*(" + g(
  `[^!'"();\\\\]+?`,
  rEscape,
  rSingleQuotes,
  rQuotes,
  rParenthesis,
  "[^;]*?"
) + "*?)";
const rDeclEnd = "\\s*(?:;\\s*|$)";
const rImportant = "(\\s*!important(?![-(\\w]))?";
const regDeclarationBlock = new RegExp(
  rAttr + ":" + rValue + rImportant + rDeclEnd,
  "ig"
);
const regStripComments = new RegExp(
  g(rEscape, rSingleQuotes, rQuotes, "/\\*[^]*?\\*/"),
  "ig"
);
const fn$e = (_root, params) => {
  const { keepImportant = false } = params;
  return {
    element: {
      enter: (node2) => {
        if (node2.attributes.style != null) {
          let styles = [];
          const newAttributes = {};
          const styleValue = node2.attributes.style.replace(
            regStripComments,
            (match) => {
              return match[0] == "/" ? "" : match[0] == "\\" && /[-g-z]/i.test(match[1]) ? match[1] : match;
            }
          );
          regDeclarationBlock.lastIndex = 0;
          for (var rule; rule = regDeclarationBlock.exec(styleValue); ) {
            if (!keepImportant || !rule[3]) {
              styles.push([rule[1], rule[2]]);
            }
          }
          if (styles.length) {
            styles = styles.filter(function(style) {
              if (style[0]) {
                const prop = style[0].toLowerCase();
                let val = style[1];
                if (rQuotedString.test(val)) {
                  val = val.slice(1, -1);
                }
                if (stylingProps.has(prop)) {
                  newAttributes[prop] = val;
                  return false;
                }
              }
              return true;
            });
            Object.assign(node2.attributes, newAttributes);
            if (styles.length) {
              node2.attributes.style = styles.map((declaration) => declaration.join(":")).join(";");
            } else {
              delete node2.attributes.style;
            }
          }
        }
      }
    }
  };
};
const convertStyleToAttrs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$e,
  fn: fn$e,
  name: name$e
}, Symbol.toStringTag, { value: "Module" }));
const name$d = "prefixIds";
const description$d = "prefix IDs";
const getBasename = (path) => {
  const matched = /[/\\]?([^/\\]+)$/.exec(path);
  if (matched) {
    return matched[1];
  }
  return "";
};
const escapeIdentifierName = (str) => {
  return str.replace(/[. ]/g, "_");
};
const unquote = (string) => {
  if (string.startsWith('"') && string.endsWith('"') || string.startsWith("'") && string.endsWith("'")) {
    return string.slice(1, -1);
  }
  return string;
};
const prefixId = (prefixGenerator, body) => {
  const prefix = prefixGenerator(body);
  if (body.startsWith(prefix)) {
    return body;
  }
  return prefix + body;
};
const prefixReference = (prefixGenerator, reference) => {
  if (reference.startsWith("#")) {
    return "#" + prefixId(prefixGenerator, reference.slice(1));
  }
  return null;
};
const generatePrefix = (body, node2, info, prefixGenerator, delim, history) => {
  if (typeof prefixGenerator === "function") {
    let prefix = history.get(body);
    if (prefix != null) {
      return prefix;
    }
    prefix = prefixGenerator(node2, info) + delim;
    history.set(body, prefix);
    return prefix;
  }
  if (typeof prefixGenerator === "string") {
    return prefixGenerator + delim;
  }
  if (prefixGenerator === false) {
    return "";
  }
  if (info.path != null && info.path.length > 0) {
    return escapeIdentifierName(getBasename(info.path)) + delim;
  }
  return "prefix" + delim;
};
const fn$d = (_root, params, info) => {
  const {
    delim = "__",
    prefix,
    prefixIds: prefixIds2 = true,
    prefixClassNames = true
  } = params;
  const prefixMap = /* @__PURE__ */ new Map();
  return {
    element: {
      enter: (node2) => {
        const prefixGenerator = (id) => generatePrefix(id, node2, info, prefix, delim, prefixMap);
        if (node2.name === "style") {
          if (node2.children.length === 0) {
            return;
          }
          for (const child of node2.children) {
            if (child.type !== "text" && child.type !== "cdata") {
              continue;
            }
            const cssText = child.value;
            let cssAst;
            try {
              cssAst = parse$I(cssText, {
                parseValue: true,
                parseCustomProperty: false
              });
            } catch {
              return;
            }
            walk$3(cssAst, (node3) => {
              if (prefixIds2 && node3.type === "IdSelector" || prefixClassNames && node3.type === "ClassSelector") {
                node3.name = prefixId(prefixGenerator, node3.name);
                return;
              }
              if (node3.type === "Url" && node3.value.length > 0) {
                const prefixed = prefixReference(
                  prefixGenerator,
                  unquote(node3.value)
                );
                if (prefixed != null) {
                  node3.value = prefixed;
                }
              }
            });
            child.value = generate$I(cssAst);
          }
        }
        if (prefixIds2 && node2.attributes.id != null && node2.attributes.id.length !== 0) {
          node2.attributes.id = prefixId(prefixGenerator, node2.attributes.id);
        }
        if (prefixClassNames && node2.attributes.class != null && node2.attributes.class.length !== 0) {
          node2.attributes.class = node2.attributes.class.split(/\s+/).map((name2) => prefixId(prefixGenerator, name2)).join(" ");
        }
        for (const name2 of ["href", "xlink:href"]) {
          if (node2.attributes[name2] != null && node2.attributes[name2].length !== 0) {
            const prefixed = prefixReference(
              prefixGenerator,
              node2.attributes[name2]
            );
            if (prefixed != null) {
              node2.attributes[name2] = prefixed;
            }
          }
        }
        for (const name2 of referencesProps) {
          if (node2.attributes[name2] != null && node2.attributes[name2].length !== 0) {
            node2.attributes[name2] = node2.attributes[name2].replace(
              /\burl\((["'])?(#.+?)\1\)/gi,
              (match, _, url) => {
                const prefixed = prefixReference(prefixGenerator, url);
                if (prefixed == null) {
                  return match;
                }
                return `url(${prefixed})`;
              }
            );
          }
        }
        for (const name2 of ["begin", "end"]) {
          if (node2.attributes[name2] != null && node2.attributes[name2].length !== 0) {
            const parts = node2.attributes[name2].split(/\s*;\s+/).map((val) => {
              if (val.endsWith(".end") || val.endsWith(".start")) {
                const [id, postfix] = val.split(".");
                return `${prefixId(prefixGenerator, id)}.${postfix}`;
              }
              return val;
            });
            node2.attributes[name2] = parts.join("; ");
          }
        }
      }
    }
  };
};
const prefixIds = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$d,
  fn: fn$d,
  name: name$d
}, Symbol.toStringTag, { value: "Module" }));
const name$c = "removeAttributesBySelector";
const description$c = "removes attributes of elements that match a css selector";
const fn$c = (root, params) => {
  const selectors = Array.isArray(params.selectors) ? params.selectors : [params];
  for (const { selector: selector2, attributes: attributes2 } of selectors) {
    const nodes = querySelectorAll(root, selector2);
    for (const node2 of nodes) {
      if (node2.type === "element") {
        if (Array.isArray(attributes2)) {
          for (const name2 of attributes2) {
            delete node2.attributes[name2];
          }
        } else {
          delete node2.attributes[attributes2];
        }
      }
    }
  }
  return {};
};
const removeAttributesBySelector = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$c,
  fn: fn$c,
  name: name$c
}, Symbol.toStringTag, { value: "Module" }));
const name$b = "removeAttrs";
const description$b = "removes specified attributes";
const DEFAULT_SEPARATOR = ":";
const ENOATTRS = `Warning: The plugin "removeAttrs" requires the "attrs" parameter.
It should have a pattern to remove, otherwise the plugin is a noop.
Config example:

plugins: [
  {
    name: "removeAttrs",
    params: {
      attrs: "(fill|stroke)"
    }
  }
]
`;
const fn$b = (root, params) => {
  if (typeof params.attrs == "undefined") {
    console.warn(ENOATTRS);
    return null;
  }
  const elemSeparator = typeof params.elemSeparator == "string" ? params.elemSeparator : DEFAULT_SEPARATOR;
  const preserveCurrentColor = typeof params.preserveCurrentColor == "boolean" ? params.preserveCurrentColor : false;
  const attrs = Array.isArray(params.attrs) ? params.attrs : [params.attrs];
  return {
    element: {
      enter: (node2) => {
        for (let pattern of attrs) {
          if (!pattern.includes(elemSeparator)) {
            pattern = [".*", pattern, ".*"].join(elemSeparator);
          } else if (pattern.split(elemSeparator).length < 3) {
            pattern = [pattern, ".*"].join(elemSeparator);
          }
          const list = pattern.split(elemSeparator).map((value2) => {
            if (value2 === "*") {
              value2 = ".*";
            }
            return new RegExp(["^", value2, "$"].join(""), "i");
          });
          if (list[0].test(node2.name)) {
            for (const [name2, value2] of Object.entries(node2.attributes)) {
              const isCurrentColor = value2.toLowerCase() === "currentcolor";
              const isFillCurrentColor = preserveCurrentColor && name2 == "fill" && isCurrentColor;
              const isStrokeCurrentColor = preserveCurrentColor && name2 == "stroke" && isCurrentColor;
              if (!isFillCurrentColor && !isStrokeCurrentColor && // matches attribute name
              list[1].test(name2) && // matches attribute value
              list[2].test(value2)) {
                delete node2.attributes[name2];
              }
            }
          }
        }
      }
    }
  };
};
const removeAttrs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$b,
  fn: fn$b,
  name: name$b
}, Symbol.toStringTag, { value: "Module" }));
const name$a = "removeDimensions";
const description$a = "removes width and height in presence of viewBox (opposite to removeViewBox)";
const fn$a = () => {
  return {
    element: {
      enter: (node2) => {
        if (node2.name === "svg") {
          if (node2.attributes.viewBox != null) {
            delete node2.attributes.width;
            delete node2.attributes.height;
          } else if (node2.attributes.width != null && node2.attributes.height != null && Number.isNaN(Number(node2.attributes.width)) === false && Number.isNaN(Number(node2.attributes.height)) === false) {
            const width = Number(node2.attributes.width);
            const height = Number(node2.attributes.height);
            node2.attributes.viewBox = `0 0 ${width} ${height}`;
            delete node2.attributes.width;
            delete node2.attributes.height;
          }
        }
      }
    }
  };
};
const removeDimensions = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$a,
  fn: fn$a,
  name: name$a
}, Symbol.toStringTag, { value: "Module" }));
const name$9 = "removeElementsByAttr";
const description$9 = "removes arbitrary elements by ID or className (disabled by default)";
const fn$9 = (root, params) => {
  const ids = params.id == null ? [] : Array.isArray(params.id) ? params.id : [params.id];
  const classes2 = params.class == null ? [] : Array.isArray(params.class) ? params.class : [params.class];
  return {
    element: {
      enter: (node2, parentNode) => {
        if (node2.attributes.id != null && ids.length !== 0) {
          if (ids.includes(node2.attributes.id)) {
            detachNodeFromParent(node2, parentNode);
          }
        }
        if (node2.attributes.class && classes2.length !== 0) {
          const classList = node2.attributes.class.split(" ");
          for (const item of classes2) {
            if (classList.includes(item)) {
              detachNodeFromParent(node2, parentNode);
              break;
            }
          }
        }
      }
    }
  };
};
const removeElementsByAttr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$9,
  fn: fn$9,
  name: name$9
}, Symbol.toStringTag, { value: "Module" }));
const name$8 = "removeOffCanvasPaths";
const description$8 = "removes elements that are drawn outside of the viewBox (disabled by default)";
const fn$8 = () => {
  let viewBoxData = null;
  return {
    element: {
      enter: (node2, parentNode) => {
        if (node2.name === "svg" && parentNode.type === "root") {
          let viewBox = "";
          if (node2.attributes.viewBox != null) {
            viewBox = node2.attributes.viewBox;
          } else if (node2.attributes.height != null && node2.attributes.width != null) {
            viewBox = `0 0 ${node2.attributes.width} ${node2.attributes.height}`;
          }
          viewBox = viewBox.replace(/[,+]|px/g, " ").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
          const m = /^(-?\d*\.?\d+) (-?\d*\.?\d+) (\d*\.?\d+) (\d*\.?\d+)$/.exec(
            viewBox
          );
          if (m == null) {
            return;
          }
          const left = Number.parseFloat(m[1]);
          const top = Number.parseFloat(m[2]);
          const width = Number.parseFloat(m[3]);
          const height = Number.parseFloat(m[4]);
          viewBoxData = {
            left,
            top,
            right: left + width,
            bottom: top + height,
            width,
            height
          };
        }
        if (node2.attributes.transform != null) {
          return visitSkip;
        }
        if (node2.name === "path" && node2.attributes.d != null && viewBoxData != null) {
          const pathData = parsePathData(node2.attributes.d);
          let visible = false;
          for (const pathDataItem of pathData) {
            if (pathDataItem.command === "M") {
              const [x, y] = pathDataItem.args;
              if (x >= viewBoxData.left && x <= viewBoxData.right && y >= viewBoxData.top && y <= viewBoxData.bottom) {
                visible = true;
              }
            }
          }
          if (visible) {
            return;
          }
          if (pathData.length === 2) {
            pathData.push({ command: "z", args: [] });
          }
          const { left, top, width, height } = viewBoxData;
          const viewBoxPathData = [
            { command: "M", args: [left, top] },
            { command: "h", args: [width] },
            { command: "v", args: [height] },
            { command: "H", args: [left] },
            { command: "z", args: [] }
          ];
          if (intersects(viewBoxPathData, pathData) === false) {
            detachNodeFromParent(node2, parentNode);
          }
        }
      }
    }
  };
};
const removeOffCanvasPaths = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$8,
  fn: fn$8,
  name: name$8
}, Symbol.toStringTag, { value: "Module" }));
const name$7 = "removeRasterImages";
const description$7 = "removes raster images (disabled by default)";
const fn$7 = () => {
  return {
    element: {
      enter: (node2, parentNode) => {
        if (node2.name === "image" && node2.attributes["xlink:href"] != null && /(\.|image\/)(jpe?g|png|gif)/.test(node2.attributes["xlink:href"])) {
          detachNodeFromParent(node2, parentNode);
        }
      }
    }
  };
};
const removeRasterImages = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$7,
  fn: fn$7,
  name: name$7
}, Symbol.toStringTag, { value: "Module" }));
const name$6 = "removeScripts";
const description$6 = "removes scripts (disabled by default)";
const eventAttrs = [
  ...attrsGroups.animationEvent,
  ...attrsGroups.documentEvent,
  ...attrsGroups.documentElementEvent,
  ...attrsGroups.globalEvent,
  ...attrsGroups.graphicalEvent
];
const fn$6 = () => {
  return {
    element: {
      enter: (node2, parentNode) => {
        if (node2.name === "script") {
          detachNodeFromParent(node2, parentNode);
          return;
        }
        for (const attr of eventAttrs) {
          if (node2.attributes[attr] != null) {
            delete node2.attributes[attr];
          }
        }
      },
      exit: (node2, parentNode) => {
        if (node2.name !== "a") {
          return;
        }
        for (const attr of Object.keys(node2.attributes)) {
          if (attr === "href" || attr.endsWith(":href")) {
            if (node2.attributes[attr] == null || !node2.attributes[attr].trimStart().startsWith("javascript:")) {
              continue;
            }
            const index = parentNode.children.indexOf(node2);
            const usefulChildren = node2.children.filter(
              (child) => child.type !== "text"
            );
            parentNode.children.splice(index, 1, ...usefulChildren);
          }
        }
      }
    }
  };
};
const removeScripts = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$6,
  fn: fn$6,
  name: name$6
}, Symbol.toStringTag, { value: "Module" }));
const name$5 = "removeStyleElement";
const description$5 = "removes <style> element (disabled by default)";
const fn$5 = () => {
  return {
    element: {
      enter: (node2, parentNode) => {
        if (node2.name === "style") {
          detachNodeFromParent(node2, parentNode);
        }
      }
    }
  };
};
const removeStyleElement = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$5,
  fn: fn$5,
  name: name$5
}, Symbol.toStringTag, { value: "Module" }));
const name$4 = "removeTitle";
const description$4 = "removes <title>";
const fn$4 = () => {
  return {
    element: {
      enter: (node2, parentNode) => {
        if (node2.name === "title") {
          detachNodeFromParent(node2, parentNode);
        }
      }
    }
  };
};
const removeTitle = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$4,
  fn: fn$4,
  name: name$4
}, Symbol.toStringTag, { value: "Module" }));
const name$3 = "removeViewBox";
const description$3 = "removes viewBox attribute when possible";
const viewBoxElems = /* @__PURE__ */ new Set(["pattern", "svg", "symbol"]);
const fn$3 = () => {
  return {
    element: {
      enter: (node2, parentNode) => {
        if (viewBoxElems.has(node2.name) && node2.attributes.viewBox != null && node2.attributes.width != null && node2.attributes.height != null) {
          if (node2.name === "svg" && parentNode.type !== "root") {
            return;
          }
          const nums = node2.attributes.viewBox.split(/[ ,]+/g);
          if (nums[0] === "0" && nums[1] === "0" && node2.attributes.width.replace(/px$/, "") === nums[2] && // could use parseFloat too
          node2.attributes.height.replace(/px$/, "") === nums[3]) {
            delete node2.attributes.viewBox;
          }
        }
      }
    }
  };
};
const removeViewBox = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$3,
  fn: fn$3,
  name: name$3
}, Symbol.toStringTag, { value: "Module" }));
const name$2 = "removeXlink";
const description$2 = "remove xlink namespace and replaces attributes with the SVG 2 equivalent where applicable";
const XLINK_NAMESPACE = "http://www.w3.org/1999/xlink";
const SHOW_TO_TARGET = {
  new: "_blank",
  replace: "_self"
};
const LEGACY_ELEMENTS = /* @__PURE__ */ new Set([
  "cursor",
  "filter",
  "font-face-uri",
  "glyphRef",
  "tref"
]);
const findPrefixedAttrs = (node2, prefixes, attr) => {
  return prefixes.map((prefix) => `${prefix}:${attr}`).filter((attr2) => node2.attributes[attr2] != null);
};
const fn$2 = (_, params) => {
  const { includeLegacy } = params;
  const xlinkPrefixes = [];
  const overriddenPrefixes = [];
  const usedInLegacyElement = [];
  return {
    element: {
      enter: (node2) => {
        for (const [key, value2] of Object.entries(node2.attributes)) {
          if (key.startsWith("xmlns:")) {
            const prefix = key.split(":", 2)[1];
            if (value2 === XLINK_NAMESPACE) {
              xlinkPrefixes.push(prefix);
              continue;
            }
            if (xlinkPrefixes.includes(prefix)) {
              overriddenPrefixes.push(prefix);
            }
          }
        }
        if (overriddenPrefixes.some((prefix) => xlinkPrefixes.includes(prefix))) {
          return;
        }
        const showAttrs = findPrefixedAttrs(node2, xlinkPrefixes, "show");
        let showHandled = node2.attributes.target != null;
        for (let i = showAttrs.length - 1; i >= 0; i--) {
          const attr = showAttrs[i];
          const value2 = node2.attributes[attr];
          const mapping = SHOW_TO_TARGET[value2];
          if (showHandled || mapping == null) {
            delete node2.attributes[attr];
            continue;
          }
          if (mapping !== elems[node2.name]?.defaults?.target) {
            node2.attributes.target = mapping;
          }
          delete node2.attributes[attr];
          showHandled = true;
        }
        const titleAttrs = findPrefixedAttrs(node2, xlinkPrefixes, "title");
        for (let i = titleAttrs.length - 1; i >= 0; i--) {
          const attr = titleAttrs[i];
          const value2 = node2.attributes[attr];
          const hasTitle = node2.children.filter(
            (child) => child.type === "element" && child.name === "title"
          );
          if (hasTitle.length > 0) {
            delete node2.attributes[attr];
            continue;
          }
          const titleTag = {
            type: "element",
            name: "title",
            attributes: {},
            children: [
              {
                type: "text",
                value: value2
              }
            ]
          };
          Object.defineProperty(titleTag, "parentNode", {
            writable: true,
            value: node2
          });
          node2.children.unshift(titleTag);
          delete node2.attributes[attr];
        }
        const hrefAttrs = findPrefixedAttrs(node2, xlinkPrefixes, "href");
        if (hrefAttrs.length > 0 && LEGACY_ELEMENTS.has(node2.name) && !includeLegacy) {
          hrefAttrs.map((attr) => attr.split(":", 1)[0]).forEach((prefix) => usedInLegacyElement.push(prefix));
          return;
        }
        for (let i = hrefAttrs.length - 1; i >= 0; i--) {
          const attr = hrefAttrs[i];
          const value2 = node2.attributes[attr];
          if (node2.attributes.href != null) {
            delete node2.attributes[attr];
            continue;
          }
          node2.attributes.href = value2;
          delete node2.attributes[attr];
        }
      },
      exit: (node2) => {
        for (const [key, value2] of Object.entries(node2.attributes)) {
          const [prefix, attr] = key.split(":", 2);
          if (xlinkPrefixes.includes(prefix) && !overriddenPrefixes.includes(prefix) && !usedInLegacyElement.includes(prefix) && !includeLegacy) {
            delete node2.attributes[key];
            continue;
          }
          if (key.startsWith("xmlns:") && !usedInLegacyElement.includes(attr)) {
            if (value2 === XLINK_NAMESPACE) {
              const index = xlinkPrefixes.indexOf(attr);
              xlinkPrefixes.splice(index, 1);
              delete node2.attributes[key];
              continue;
            }
            if (overriddenPrefixes.includes(prefix)) {
              const index = overriddenPrefixes.indexOf(attr);
              overriddenPrefixes.splice(index, 1);
            }
          }
        }
      }
    }
  };
};
const removeXlink = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$2,
  fn: fn$2,
  name: name$2
}, Symbol.toStringTag, { value: "Module" }));
const name$1 = "removeXMLNS";
const description$1 = "removes xmlns attribute (for inline svg, disabled by default)";
const fn$1 = () => {
  return {
    element: {
      enter: (node2) => {
        if (node2.name === "svg") {
          delete node2.attributes.xmlns;
        }
      }
    }
  };
};
const removeXMLNS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description: description$1,
  fn: fn$1,
  name: name$1
}, Symbol.toStringTag, { value: "Module" }));
const name = "reusePaths";
const description = "Finds <path> elements with the same d, fill, and stroke, and converts them to <use> elements referencing a single <path> def.";
const fn = (root) => {
  const stylesheet = collectStylesheet(root);
  const paths = /* @__PURE__ */ new Map();
  let svgDefs;
  const hrefs = /* @__PURE__ */ new Set();
  return {
    element: {
      enter: (node2, parentNode) => {
        if (node2.name === "path" && node2.attributes.d != null) {
          const d = node2.attributes.d;
          const fill = node2.attributes.fill || "";
          const stroke = node2.attributes.stroke || "";
          const key = d + ";s:" + stroke + ";f:" + fill;
          let list = paths.get(key);
          if (list == null) {
            list = [];
            paths.set(key, list);
          }
          list.push(node2);
        }
        if (svgDefs == null && node2.name === "defs" && parentNode.type === "element" && parentNode.name === "svg") {
          svgDefs = node2;
        }
        if (node2.name === "use") {
          for (const name2 of ["href", "xlink:href"]) {
            const href = node2.attributes[name2];
            if (href != null && href.startsWith("#") && href.length > 1) {
              hrefs.add(href.slice(1));
            }
          }
        }
      },
      exit: (node2, parentNode) => {
        if (node2.name === "svg" && parentNode.type === "root") {
          let defsTag = svgDefs;
          if (defsTag == null) {
            defsTag = {
              type: "element",
              name: "defs",
              attributes: {},
              children: []
            };
          }
          let index = 0;
          for (const list of paths.values()) {
            if (list.length > 1) {
              const reusablePath = {
                type: "element",
                name: "path",
                attributes: {},
                children: []
              };
              for (const attr of ["fill", "stroke", "d"]) {
                if (list[0].attributes[attr] != null) {
                  reusablePath.attributes[attr] = list[0].attributes[attr];
                }
              }
              const originalId = list[0].attributes.id;
              if (originalId == null || hrefs.has(originalId) || stylesheet.rules.some(
                (rule) => rule.selector === `#${originalId}`
              )) {
                reusablePath.attributes.id = "reuse-" + index++;
              } else {
                reusablePath.attributes.id = originalId;
                delete list[0].attributes.id;
              }
              defsTag.children.push(reusablePath);
              for (const pathNode of list) {
                delete pathNode.attributes.d;
                delete pathNode.attributes.stroke;
                delete pathNode.attributes.fill;
                if (defsTag.children.includes(pathNode) && pathNode.children.length === 0) {
                  if (Object.keys(pathNode.attributes).length === 0) {
                    detachNodeFromParent(pathNode, defsTag);
                    continue;
                  }
                  if (Object.keys(pathNode.attributes).length === 1 && pathNode.attributes.id != null) {
                    detachNodeFromParent(pathNode, defsTag);
                    const selector2 = `[xlink\\:href=#${pathNode.attributes.id}], [href=#${pathNode.attributes.id}]`;
                    for (const child of querySelectorAll(node2, selector2)) {
                      if (child.type !== "element") {
                        continue;
                      }
                      for (const name2 of ["href", "xlink:href"]) {
                        if (child.attributes[name2] != null) {
                          child.attributes[name2] = "#" + reusablePath.attributes.id;
                        }
                      }
                    }
                    continue;
                  }
                }
                pathNode.name = "use";
                pathNode.attributes["xlink:href"] = "#" + reusablePath.attributes.id;
              }
            }
          }
          if (defsTag.children.length !== 0) {
            if (node2.attributes["xmlns:xlink"] == null) {
              node2.attributes["xmlns:xlink"] = "http://www.w3.org/1999/xlink";
            }
            if (svgDefs == null) {
              node2.children.unshift(defsTag);
            }
          }
        }
      }
    }
  };
};
const reusePaths = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  description,
  fn,
  name
}, Symbol.toStringTag, { value: "Module" }));
const builtinPlugins = Object.freeze([
  presetDefault,
  addAttributesToSVGElement,
  addClassesToSVGElement,
  cleanupAttrs,
  cleanupEnableBackground,
  cleanupIds,
  cleanupListOfValues,
  cleanupNumericValues,
  collapseGroups,
  convertColors,
  convertEllipseToCircle,
  convertOneStopGradients,
  convertPathData,
  convertShapeToPath,
  convertStyleToAttrs,
  convertTransform$1,
  inlineStyles,
  mergePaths,
  mergeStyles,
  minifyStyles,
  moveElemsAttrsToGroup,
  moveGroupAttrsToElems,
  prefixIds,
  removeAttributesBySelector,
  removeAttrs,
  removeComments,
  removeDeprecatedAttrs,
  removeDesc,
  removeDimensions,
  removeDoctype,
  removeEditorsNSData,
  removeElementsByAttr,
  removeEmptyAttrs,
  removeEmptyContainers,
  removeEmptyText,
  removeHiddenElems,
  removeMetadata,
  removeNonInheritableGroupAttrs,
  removeOffCanvasPaths,
  removeRasterImages,
  removeScripts,
  removeStyleElement,
  removeTitle,
  removeUnknownsAndDefaults,
  removeUnusedNS,
  removeUselessDefs,
  removeUselessStrokeAndFill,
  removeViewBox,
  removeXlink,
  removeXMLNS,
  removeXMLProcInst,
  reusePaths,
  sortAttrs,
  sortDefsChildren
]);
var sax = {};
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal);
var string_decoder = {};
var safeBuffer = { exports: {} };
var buffer = {};
var base64Js = {};
var hasRequiredBase64Js;
function requireBase64Js() {
  if (hasRequiredBase64Js) return base64Js;
  hasRequiredBase64Js = 1;
  base64Js.byteLength = byteLength;
  base64Js.toByteArray = toByteArray;
  base64Js.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code2.length; i < len; ++i) {
    lookup[i] = code2[i];
    revLookup[code2.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i2;
    for (i2 = 0; i2 < len2; i2 += 4) {
      tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i2 = start; i2 < end; i2 += 3) {
      tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(
        lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
      );
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(
        lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
      );
    }
    return parts.join("");
  }
  return base64Js;
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredIeee754;
function requireIeee754() {
  if (hasRequiredIeee754) return ieee754;
  hasRequiredIeee754 = 1;
  ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer2[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {
    }
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  ieee754.write = function(buffer2, value2, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
    value2 = Math.abs(value2);
    if (isNaN(value2) || value2 === Infinity) {
      m = isNaN(value2) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value2) / Math.LN2);
      if (value2 * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value2 += rt / c;
      } else {
        value2 += rt * Math.pow(2, 1 - eBias);
      }
      if (value2 * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value2 * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
    }
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
    }
    buffer2[offset + i - d] |= s * 128;
  };
  return ieee754;
}
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  (function(exports) {
    const base642 = requireBase64Js();
    const ieee7542 = requireIeee754();
    const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    const K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length2) {
      if (length2 > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length2);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length2) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length2);
    }
    Buffer2.poolSize = 8192;
    function from(value2, encodingOrOffset, length2) {
      if (typeof value2 === "string") {
        return fromString(value2, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value2)) {
        return fromArrayView(value2);
      }
      if (value2 == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
        );
      }
      if (isInstance(value2, ArrayBuffer) || value2 && isInstance(value2.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value2, encodingOrOffset, length2);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value2, SharedArrayBuffer) || value2 && isInstance(value2.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value2, encodingOrOffset, length2);
      }
      if (typeof value2 === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value2.valueOf && value2.valueOf();
      if (valueOf != null && valueOf !== value2) {
        return Buffer2.from(valueOf, encodingOrOffset, length2);
      }
      const b = fromObject(value2);
      if (b) return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value2[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value2[Symbol.toPrimitive]("string"), encodingOrOffset, length2);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
      );
    }
    Buffer2.from = function(value2, encodingOrOffset, length2) {
      return from(value2, encodingOrOffset, length2);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length2 = byteLength(string, encoding) | 0;
      let buf = createBuffer(length2);
      const actual = buf.write(string, encoding);
      if (actual !== length2) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length2 = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length2);
      for (let i = 0; i < length2; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy2 = new Uint8Array(arrayView);
        return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length2) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length2 || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length2 === void 0) {
        buf = new Uint8Array(array);
      } else if (length2 === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length2);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length2) {
      if (length2 >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length2 | 0;
    }
    function SlowBuffer(length2) {
      if (+length2 != length2) {
        length2 = 0;
      }
      return Buffer2.alloc(+length2);
    }
    Buffer2.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b) return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length2) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i;
      if (length2 === void 0) {
        length2 = 0;
        for (i = 0; i < list.length; ++i) {
          length2 += list[i].length;
        }
      }
      const buffer2 = Buffer2.allocUnsafe(length2);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);
            buf.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      const length2 = this.length;
      if (length2 === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length2);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b) {
      if (!Buffer2.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      if (this === b) return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir) return -1;
        else byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length2) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length2) {
        length2 = remaining;
      } else {
        length2 = Number(length2);
        if (length2 > remaining) {
          length2 = remaining;
        }
      }
      const strLen = string.length;
      if (length2 > strLen / 2) {
        length2 = strLen / 2;
      }
      let i;
      for (i = 0; i < length2; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length2) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length2);
    }
    function asciiWrite(buf, string, offset, length2) {
      return blitBuffer(asciiToBytes(string), buf, offset, length2);
    }
    function base64Write(buf, string, offset, length2) {
      return blitBuffer(base64ToBytes(string), buf, offset, length2);
    }
    function ucs2Write(buf, string, offset, length2) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length2);
    }
    Buffer2.prototype.write = function write(string, offset, length2, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length2 = this.length;
        offset = 0;
      } else if (length2 === void 0 && typeof offset === "string") {
        encoding = offset;
        length2 = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length2)) {
          length2 = length2 >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length2;
          length2 = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length2 === void 0 || length2 > remaining) length2 = remaining;
      if (string.length > 0 && (length2 < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length2);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length2);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length2);
          case "base64":
            return base64Write(this, string, offset, length2);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length2);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base642.fromByteArray(buf);
      } else {
        return base642.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    const MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length2) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length2) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee7542.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee7542.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee7542.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee7542.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value2, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value2 > max || value2 < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value2, offset, byteLength2, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value2, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value2 & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value2 / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value2, offset, byteLength2, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value2, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value2 & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value2 / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value2, offset, 1, 255, 0);
      this[offset] = value2 & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value2, offset, 2, 65535, 0);
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value2, offset, 2, 65535, 0);
      this[offset] = value2 >>> 8;
      this[offset + 1] = value2 & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value2, offset, 4, 4294967295, 0);
      this[offset + 3] = value2 >>> 24;
      this[offset + 2] = value2 >>> 16;
      this[offset + 1] = value2 >>> 8;
      this[offset] = value2 & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value2, offset, 4, 4294967295, 0);
      this[offset] = value2 >>> 24;
      this[offset + 1] = value2 >>> 16;
      this[offset + 2] = value2 >>> 8;
      this[offset + 3] = value2 & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value2, offset, min, max) {
      checkIntBI(value2, min, max, buf, offset, 7);
      let lo = Number(value2 & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value2 >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value2, offset, min, max) {
      checkIntBI(value2, min, max, buf, offset, 7);
      let lo = Number(value2 & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value2 >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value2, offset = 0) {
      return wrtBigUInt64LE(this, value2, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value2, offset = 0) {
      return wrtBigUInt64BE(this, value2, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value2, offset, byteLength2, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value2, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub2 = 0;
      this[offset] = value2 & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value2 < 0 && sub2 === 0 && this[offset + i - 1] !== 0) {
          sub2 = 1;
        }
        this[offset + i] = (value2 / mul >> 0) - sub2 & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value2, offset, byteLength2, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value2, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub2 = 0;
      this[offset + i] = value2 & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value2 < 0 && sub2 === 0 && this[offset + i + 1] !== 0) {
          sub2 = 1;
        }
        this[offset + i] = (value2 / mul >> 0) - sub2 & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value2, offset, 1, 127, -128);
      if (value2 < 0) value2 = 255 + value2 + 1;
      this[offset] = value2 & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value2, offset, 2, 32767, -32768);
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value2, offset, 2, 32767, -32768);
      this[offset] = value2 >>> 8;
      this[offset + 1] = value2 & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value2, offset, 4, 2147483647, -2147483648);
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >>> 8;
      this[offset + 2] = value2 >>> 16;
      this[offset + 3] = value2 >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value2, offset, 4, 2147483647, -2147483648);
      if (value2 < 0) value2 = 4294967295 + value2 + 1;
      this[offset] = value2 >>> 24;
      this[offset + 1] = value2 >>> 16;
      this[offset + 2] = value2 >>> 8;
      this[offset + 3] = value2 & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value2, offset = 0) {
      return wrtBigUInt64LE(this, value2, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value2, offset = 0) {
      return wrtBigUInt64BE(this, value2, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value2, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value2, offset, littleEndian, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value2, offset, 4);
      }
      ieee7542.write(buf, value2, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value2, offset, noAssert) {
      return writeFloat(this, value2, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value2, offset, noAssert) {
      return writeFloat(this, value2, offset, false, noAssert);
    };
    function writeDouble(buf, value2, offset, littleEndian, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value2, offset, 8);
      }
      ieee7542.write(buf, value2, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value2, offset, noAssert) {
      return writeDouble(this, value2, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value2, offset, noAssert) {
      return writeDouble(this, value2, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy2(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code2 = val.charCodeAt(0);
          if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
            val = code2;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    const errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value2) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value: value2,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name2) {
        if (name2) {
          return `${name2} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name2, actual) {
        return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value2, min, max, buf, offset, byteLength2) {
      if (value2 > max || value2 < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value2);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value2, name2) {
      if (typeof value2 !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value2);
      }
    }
    function boundsError(value2, length2, type) {
      if (Math.floor(value2) !== value2) {
        validateNumber(value2, type);
        throw new errors.ERR_OUT_OF_RANGE("offset", "an integer", value2);
      }
      if (length2 < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        "offset",
        `>= ${0} and <= ${length2}`,
        value2
      );
    }
    const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units2) {
      units2 = units2 || Infinity;
      let codePoint;
      const length2 = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length2; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units2 -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length2) {
              if ((units2 -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units2 -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units2 -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units2 -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units2 -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units2 -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units2 -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units2) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units2 -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base642.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length2) {
      let i;
      for (i = 0; i < length2; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    const hexSliceLookupTable = (function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    })();
    function defineBigIntMethod(fn2) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn2;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  })(buffer);
  return buffer;
}
var hasRequiredSafeBuffer;
function requireSafeBuffer() {
  if (hasRequiredSafeBuffer) return safeBuffer.exports;
  hasRequiredSafeBuffer = 1;
  (function(module, exports) {
    var buffer2 = requireBuffer();
    var Buffer2 = buffer2.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer2;
    } else {
      copyProps(buffer2, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length2) {
      return Buffer2(arg, encodingOrOffset, length2);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length2) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length2);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  })(safeBuffer, safeBuffer.exports);
  return safeBuffer.exports;
}
var hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var Buffer2 = requireSafeBuffer().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried) return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === void 0) return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127) return 0;
    else if (byte >> 5 === 6) return 2;
    else if (byte >> 4 === 14) return 3;
    else if (byte >> 3 === 30) return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0;
        else self.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self.lastNeed = 0;
      return "�";
    }
    if (self.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self.lastNeed = 1;
        return "�";
      }
      if (self.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self.lastNeed = 2;
          return "�";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== void 0) return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "�";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder;
}
var hasRequiredSax;
function requireSax() {
  if (hasRequiredSax) return sax;
  hasRequiredSax = 1;
  (function(exports) {
    (function(sax2) {
      sax2.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax2.SAXParser = SAXParser;
      sax2.SAXStream = SAXStream;
      sax2.createStream = createStream;
      sax2.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax2.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax2.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax2.XML_ENTITIES) : Object.create(sax2.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        if (parser.opt.unquotedAttributeValues === void 0) {
          parser.opt.unquotedAttributeValues = !strict;
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit(parser, "onready");
      }
      if (!Object.create) {
        Object.create = function(o) {
          function F2() {
          }
          F2.prototype = o;
          var newf = new F2();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o) {
          var a = [];
          for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
          return a;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax2.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i = 0, l = buffers.length; i < l; i++) {
          var len = parser[buffers[i]].length;
          if (len > maxAllowed) {
            switch (buffers[i]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error2(parser, "Max buffer length exceeded: " + buffers[i]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m = sax2.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
      }
      function clearBuffers(parser) {
        for (var i = 0, l = buffers.length; i < l; i++) {
          parser[buffers[i]] = "";
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream;
      try {
        Stream = require$$0.Stream;
      } catch (ex) {
        Stream = function() {
        };
      }
      if (!Stream) Stream = function() {
      };
      var streamWraps = sax2.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h) {
              if (!h) {
                me.removeAllListeners(ev);
                me._parser["on" + ev] = h;
                return h;
              }
              me.on(ev, h);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream.prototype, {
        constructor: {
          value: SAXStream
        }
      });
      SAXStream.prototype.write = function(data) {
        if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
          if (!this._decoder) {
            var SD = requireString_decoder().StringDecoder;
            this._decoder = new SD("utf8");
          }
          data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
          this.write(chunk);
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream.prototype.on.call(me, ev, handler);
      };
      var CDATA2 = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace2(c) {
        return c === " " || c === "\n" || c === "\r" || c === "	";
      }
      function isQuote2(c) {
        return c === '"' || c === "'";
      }
      function isAttribEnd(c) {
        return c === ">" || isWhitespace2(c);
      }
      function isMatch(regex, c) {
        return regex.test(c);
      }
      function notMatch(regex, c) {
        return !isMatch(regex, c);
      }
      var S = 0;
      sax2.STATE = {
        BEGIN: S++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: S++,
        // leading whitespace
        TEXT: S++,
        // general stuff
        TEXT_ENTITY: S++,
        // &amp and such.
        OPEN_WAKA: S++,
        // <
        SGML_DECL: S++,
        // <!BLARG
        SGML_DECL_QUOTED: S++,
        // <!BLARG foo "bar
        DOCTYPE: S++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: S++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: S++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: S++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: S++,
        // <!-
        COMMENT: S++,
        // <!--
        COMMENT_ENDING: S++,
        // <!-- blah -
        COMMENT_ENDED: S++,
        // <!-- blah --
        CDATA: S++,
        // <![CDATA[ something
        CDATA_ENDING: S++,
        // ]
        CDATA_ENDING_2: S++,
        // ]]
        PROC_INST: S++,
        // <?hi
        PROC_INST_BODY: S++,
        // <?hi there
        PROC_INST_ENDING: S++,
        // <?hi "there" ?
        OPEN_TAG: S++,
        // <strong
        OPEN_TAG_SLASH: S++,
        // <strong /
        ATTRIB: S++,
        // <a
        ATTRIB_NAME: S++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: S++,
        // <a foo _
        ATTRIB_VALUE: S++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: S++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: S++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: S++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: S++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: S++,
        // <foo bar=&quot
        CLOSE_TAG: S++,
        // </a
        CLOSE_TAG_SAW_WHITE: S++,
        // </a   >
        SCRIPT: S++,
        // <script> ...
        SCRIPT_ENDING: S++
        // <script> ... <
      };
      sax2.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
      };
      sax2.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax2.ENTITIES).forEach(function(key) {
        var e = sax2.ENTITIES[key];
        var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
        sax2.ENTITIES[key] = s2;
      });
      for (var s in sax2.STATE) {
        sax2.STATE[sax2.STATE[s]] = s;
      }
      S = sax2.STATE;
      function emit(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode) closeText(parser);
        emit(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode) emit(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text) {
        if (opt.trim) text = text.trim();
        if (opt.normalize) text = text.replace(/\s+/g, " ");
        return text;
      }
      function error2(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
          er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit(parser, "onerror", er);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot) strictFail(parser, "Unclosed root tag");
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
          error2(parser, "Unexpected end");
        }
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser.strict) {
          error2(parser, message);
        }
      }
      function newTag(parser) {
        if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = { name: parser.tagName, attributes: {} };
        if (parser.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
      }
      function qname(name2, attribute) {
        var i = name2.indexOf(":");
        var qualName = i < 0 ? ["", name2] : name2.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name2 === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(
                parser,
                "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(
                parser,
                "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else {
              var tag = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              emitNode(parser, "onopennamespace", {
                prefix: p,
                uri: tag.ns[p]
              });
            });
          }
          for (var i = 0, l = parser.attribList.length; i < l; i++) {
            var nv = parser.attribList[i];
            var name2 = nv[0];
            var value2 = nv[1];
            var qualName = qname(name2, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri = prefix === "" ? "" : tag.ns[prefix] || "";
            var a = {
              name: name2,
              value: value2,
              prefix,
              local,
              uri
            };
            if (prefix && prefix !== "xmlns" && !uri) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a.uri = prefix;
            }
            parser.tag.attributes[name2] = a;
            emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S.SCRIPT;
          } else {
            parser.state = S.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t--) {
          var close = parser.tags[t];
          if (close.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s2 = parser.tags.length;
        while (s2-- > t) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x = {};
          for (var i in tag.ns) {
            x[i] = tag.ns[i];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              var n = tag.ns[p];
              emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
            });
          }
        }
        if (t === 0) parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c) {
        if (c === "<") {
          parser.state = S.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace2(c)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c;
          parser.state = S.TEXT;
        }
      }
      function charAt(chunk, i) {
        var result = "";
        if (i < chunk.length) {
          result = chunk.charAt(i);
        }
        return result;
      }
      function write(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error2(
            parser,
            "Cannot write after close. Assign an onready handler."
          );
        }
        if (chunk === null) {
          return end(parser);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i = 0;
        var c = "";
        while (true) {
          c = charAt(chunk, i++);
          parser.c = c;
          if (!c) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c === "\n") {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S.BEGIN:
              parser.state = S.BEGIN_WHITESPACE;
              if (c === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser, c);
              continue;
            case S.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c);
              continue;
            case S.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i - 1;
                while (c && c !== "<" && c !== "&") {
                  c = charAt(chunk, i++);
                  if (c && parser.trackPosition) {
                    parser.position++;
                    if (c === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i - 1);
              }
              if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace2(c) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, "Text data outside of root node.");
                }
                if (c === "&") {
                  parser.state = S.TEXT_ENTITY;
                } else {
                  parser.textNode += c;
                }
              }
              continue;
            case S.SCRIPT:
              if (c === "<") {
                parser.state = S.SCRIPT_ENDING;
              } else {
                parser.script += c;
              }
              continue;
            case S.SCRIPT_ENDING:
              if (c === "/") {
                parser.state = S.CLOSE_TAG;
              } else {
                parser.script += "<" + c;
                parser.state = S.SCRIPT;
              }
              continue;
            case S.OPEN_WAKA:
              if (c === "!") {
                parser.state = S.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace2(c)) ;
              else if (isMatch(nameStart, c)) {
                parser.state = S.OPEN_TAG;
                parser.tagName = c;
              } else if (c === "/") {
                parser.state = S.CLOSE_TAG;
                parser.tagName = "";
              } else if (c === "?") {
                parser.state = S.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c = new Array(pad).join(" ") + c;
                }
                parser.textNode += "<" + c;
                parser.state = S.TEXT;
              }
              continue;
            case S.SGML_DECL:
              if (parser.sgmlDecl + c === "--") {
                parser.state = S.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
                continue;
              }
              if (parser.doctype && parser.doctype !== true && parser.sgmlDecl) {
                parser.state = S.DOCTYPE_DTD;
                parser.doctype += "<!" + parser.sgmlDecl + c;
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === CDATA2) {
                emitNode(parser, "onopencdata");
                parser.state = S.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser.state = S.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(
                    parser,
                    "Inappropriately located doctype declaration"
                  );
                }
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S.TEXT;
              } else if (isQuote2(c)) {
                parser.state = S.SGML_DECL_QUOTED;
                parser.sgmlDecl += c;
              } else {
                parser.sgmlDecl += c;
              }
              continue;
            case S.SGML_DECL_QUOTED:
              if (c === parser.q) {
                parser.state = S.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c;
              continue;
            case S.DOCTYPE:
              if (c === ">") {
                parser.state = S.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c;
                if (c === "[") {
                  parser.state = S.DOCTYPE_DTD;
                } else if (isQuote2(c)) {
                  parser.state = S.DOCTYPE_QUOTED;
                  parser.q = c;
                }
              }
              continue;
            case S.DOCTYPE_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.q = "";
                parser.state = S.DOCTYPE;
              }
              continue;
            case S.DOCTYPE_DTD:
              if (c === "]") {
                parser.doctype += c;
                parser.state = S.DOCTYPE;
              } else if (c === "<") {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else if (isQuote2(c)) {
                parser.doctype += c;
                parser.state = S.DOCTYPE_DTD_QUOTED;
                parser.q = c;
              } else {
                parser.doctype += c;
              }
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.state = S.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S.COMMENT:
              if (c === "-") {
                parser.state = S.COMMENT_ENDING;
              } else {
                parser.comment += c;
              }
              continue;
            case S.COMMENT_ENDING:
              if (c === "-") {
                parser.state = S.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, "oncomment", parser.comment);
                }
                parser.comment = "";
              } else {
                parser.comment += "-" + c;
                parser.state = S.COMMENT;
              }
              continue;
            case S.COMMENT_ENDED:
              if (c !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c;
                parser.state = S.COMMENT;
              } else if (parser.doctype && parser.doctype !== true) {
                parser.state = S.DOCTYPE_DTD;
              } else {
                parser.state = S.TEXT;
              }
              continue;
            case S.CDATA:
              if (c === "]") {
                parser.state = S.CDATA_ENDING;
              } else {
                parser.cdata += c;
              }
              continue;
            case S.CDATA_ENDING:
              if (c === "]") {
                parser.state = S.CDATA_ENDING_2;
              } else {
                parser.cdata += "]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.CDATA_ENDING_2:
              if (c === ">") {
                if (parser.cdata) {
                  emitNode(parser, "oncdata", parser.cdata);
                }
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S.TEXT;
              } else if (c === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.PROC_INST:
              if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else if (isWhitespace2(c)) {
                parser.state = S.PROC_INST_BODY;
              } else {
                parser.procInstName += c;
              }
              continue;
            case S.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace2(c)) {
                continue;
              } else if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c;
              }
              continue;
            case S.PROC_INST_ENDING:
              if (c === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S.TEXT;
              } else {
                parser.procInstBody += "?" + c;
                parser.state = S.PROC_INST_BODY;
              }
              continue;
            case S.OPEN_TAG:
              if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else {
                newTag(parser);
                if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace2(c)) {
                    strictFail(parser, "Invalid character in tag name");
                  }
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.OPEN_TAG_SLASH:
              if (c === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S.ATTRIB;
              }
              continue;
            case S.ATTRIB:
              if (isWhitespace2(c)) {
                continue;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (c === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace2(c)) {
                parser.state = S.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c)) {
                parser.attribName += c;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (isWhitespace2(c)) {
                continue;
              } else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c === ">") {
                  openTag(parser);
                } else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.ATTRIB_VALUE:
              if (isWhitespace2(c)) {
                continue;
              } else if (isQuote2(c)) {
                parser.q = c;
                parser.state = S.ATTRIB_VALUE_QUOTED;
              } else {
                if (!parser.opt.unquotedAttributeValues) {
                  error2(parser, "Unquoted attribute value");
                }
                parser.state = S.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c;
              }
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              if (isWhitespace2(c)) {
                parser.state = S.ATTRIB;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c)) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              if (c === ">") {
                openTag(parser);
              } else {
                parser.state = S.ATTRIB;
              }
              continue;
            case S.CLOSE_TAG:
              if (!parser.tagName) {
                if (isWhitespace2(c)) {
                  continue;
                } else if (notMatch(nameStart, c)) {
                  if (parser.script) {
                    parser.script += "</" + c;
                    parser.state = S.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser.tagName = c;
                }
              } else if (c === ">") {
                closeTag(parser);
              } else if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S.SCRIPT;
              } else {
                if (!isWhitespace2(c)) {
                  strictFail(parser, "Invalid tagname in closing tag");
                }
                parser.state = S.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace2(c)) {
                continue;
              }
              if (c === ">") {
                closeTag(parser);
              } else {
                strictFail(parser, "Invalid characters in closing tag");
              }
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer2;
              switch (parser.state) {
                case S.TEXT_ENTITY:
                  returnState = S.TEXT;
                  buffer2 = "textNode";
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S.ATTRIB_VALUE_QUOTED;
                  buffer2 = "attribValue";
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  returnState = S.ATTRIB_VALUE_UNQUOTED;
                  buffer2 = "attribValue";
                  break;
              }
              if (c === ";") {
                var parsedEntity = parseEntity(parser);
                if (parser.opt.unparsedEntities && !Object.values(sax2.XML_ENTITIES).includes(parsedEntity)) {
                  parser.entity = "";
                  parser.state = returnState;
                  parser.write(parsedEntity);
                } else {
                  parser[buffer2] += parsedEntity;
                  parser.entity = "";
                  parser.state = returnState;
                }
              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                parser.entity += c;
              } else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer2] += "&" + parser.entity + c;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default: {
              throw new Error(parser, "Unknown state: " + parser.state);
            }
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
      /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
      if (!String.fromCodePoint) {
        (function() {
          var stringFromCharCode = String.fromCharCode;
          var floor = Math.floor;
          var fromCodePoint = function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length2 = arguments.length;
            if (!length2) {
              return "";
            }
            var result = "";
            while (++index < length2) {
              var codePoint = Number(arguments[index]);
              if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
              codePoint < 0 || // not a valid Unicode code point
              codePoint > 1114111 || // not a valid Unicode code point
              floor(codePoint) !== codePoint) {
                throw RangeError("Invalid code point: " + codePoint);
              }
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index + 1 === length2 || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          };
          if (Object.defineProperty) {
            Object.defineProperty(String, "fromCodePoint", {
              value: fromCodePoint,
              configurable: true,
              writable: true
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        })();
      }
    })(exports);
  })(sax);
  return sax;
}
requireSax();
const pluginsMap = /* @__PURE__ */ new Map();
for (const plugin of builtinPlugins) {
  pluginsMap.set(plugin.name, plugin);
}
let catalogueData = null;
const slidesRoot = document.getElementById("slides-root");
const sidebar = document.querySelector(".sidebar");
const arrow = document.querySelector(".sidebar__arrow");
fetch("./files/catalogue.json").then((res) => res.json()).then((data) => {
  catalogueData = data.catalogue;
  let active = document.querySelector(".sidebar__category.active");
  if (active) {
    updateContent(active.id);
  }
});
function updateContent(id) {
  if (!catalogueData) return;
  const category = catalogueData.find((c) => c.id === id);
  if (!category) return;
  document.getElementById("categoryTitle").textContent = category.categoryTitle;
  document.getElementById("categoryDesc").textContent = category.categoryDesc;
  slidesRoot.innerHTML = "";
  category.products.forEach((product) => {
    const slide2 = document.createElement("div");
    slide2.classList.add("swiper-category__slide", "swiper-slide");
    slide2.innerHTML = `
			<div class="product">
				<div class="product__image">
					<img class="product__img" src="${product.image}" alt="${product.title}">
				</div>
				<div class="product__info">
					<a href="#" class="product__title">${product.title}</a>
					<div class="product__price">${product.price}</div>
					<button class="product__cart catr --icon-cart"></button>
				</div>
			</div>
		`;
    slidesRoot.appendChild(slide2);
  });
  if (window.categorySwiper) {
    window.categorySwiper.update();
  }
}
function setActiveIcon(icon) {
  sidebar.querySelector(".active")?.classList.remove("active");
  icon.classList.add("active");
  updateContent(icon.id);
}
sidebar.addEventListener("click", (e) => {
  const icon = e.target.closest(".sidebar__category");
  if (icon && !icon.classList.contains("sidebar__arrow")) {
    setActiveIcon(icon);
    sidebar.insertBefore(icon, sidebar.firstElementChild);
  }
});
arrow.addEventListener("click", () => {
  const firstIcon = sidebar.querySelector(".sidebar__category");
  if (firstIcon) {
    sidebar.insertBefore(firstIcon, arrow);
    const newFirst = sidebar.querySelector(".sidebar__category");
    if (newFirst) setActiveIcon(newFirst);
  }
});
class MousePRLX {
  constructor(props, data = null) {
    let defaultConfig = {
      init: true,
      logging: true
    };
    this.config = Object.assign(defaultConfig, props);
    if (this.config.init) {
      const paralaxMouse = document.querySelectorAll("[data-prlx-mouse]");
      if (paralaxMouse.length) {
        this.paralaxMouseInit(paralaxMouse);
      }
    }
  }
  paralaxMouseInit(paralaxMouse) {
    paralaxMouse.forEach((el) => {
      const paralaxMouseWrapper = el.closest("[data-prlx-mouse-wrapper]");
      const paramСoefficientX = el.dataset.prlxCx ? +el.dataset.prlxCx : 100;
      const paramСoefficientY = el.dataset.prlxCy ? +el.dataset.prlxCy : 100;
      const directionX = el.hasAttribute("data-prlx-dxr") ? -1 : 1;
      const directionY = el.hasAttribute("data-prlx-dyr") ? -1 : 1;
      const paramAnimation = el.dataset.prlxA ? +el.dataset.prlxA : 50;
      let positionX = 0, positionY = 0;
      let coordXprocent = 0, coordYprocent = 0;
      setMouseParallaxStyle();
      if (paralaxMouseWrapper) {
        mouseMoveParalax(paralaxMouseWrapper);
      } else {
        mouseMoveParalax();
      }
      function setMouseParallaxStyle() {
        const distX = coordXprocent - positionX;
        const distY = coordYprocent - positionY;
        positionX = positionX + distX * paramAnimation / 1e3;
        positionY = positionY + distY * paramAnimation / 1e3;
        el.style.cssText = `transform: translate3D(${directionX * positionX / (paramСoefficientX / 10)}%,${directionY * positionY / (paramСoefficientY / 10)}%,0) rotate(0.02deg);`;
        requestAnimationFrame(setMouseParallaxStyle);
      }
      function mouseMoveParalax(wrapper = window) {
        wrapper.addEventListener("mousemove", function(e) {
          const offsetTop = el.getBoundingClientRect().top + window.scrollY;
          if (offsetTop >= window.scrollY || offsetTop + el.offsetHeight >= window.scrollY) {
            const parallaxWidth = window.innerWidth;
            const parallaxHeight = window.innerHeight;
            const coordX = e.clientX - parallaxWidth / 2;
            const coordY = e.clientY - parallaxHeight / 2;
            coordXprocent = coordX / parallaxWidth * 100;
            coordYprocent = coordY / parallaxHeight * 100;
          }
        });
      }
    });
  }
}
if (typeof window !== "undefined" && document.querySelector("[data-prlx-mouse]")) {
  window.addEventListener("load", () => new MousePRLX({}));
}
function windowLoad() {
  document.documentElement.classList.add("loaded");
}
window.addEventListener("load", windowLoad);
